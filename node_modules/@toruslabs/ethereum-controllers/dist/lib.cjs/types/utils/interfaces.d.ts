import { Implementation, toMetaMaskSmartAccount } from "@metamask/delegation-toolkit";
import { BASE_TX_EVENT_TYPE, BaseBlockTrackerState, BaseControllerEvents, BaseFormattedTransactionActivity, BaseTokenInfo, BaseTransactionEvents, MESSAGE_EVENTS, MessageStatus, NetworkConfig, NetworkState, PaymentTransaction, PollingBlockTrackerConfig, PopupWhitelabelData, ProviderConfig, TRANSACTION_TYPE, TransactionMeta, TransactionState, TransactionStatus, TX_CONFIRMED_EVENT_TYPE, TX_DROPPED_EVENT_TYPE, TX_EVENTS, TX_FAILED_EVENT_TYPE, TX_WARNING_EVENT_TYPE, User } from "@toruslabs/base-controllers";
import { JRPCRequest, Json } from "@web3auth/auth";
import { MutexInterface } from "async-mutex";
import { AccessList, TypedDataDomain, TypedDataField } from "ethers";
import { ToBiconomySmartAccountParameters, toEcdsaKernelSmartAccount, ToLightSmartAccountParameters, ToNexusSmartAccountParameters, toSafeSmartAccount, toSimpleSmartAccount, toTrustSmartAccount } from "permissionless/accounts";
import { Client, Hex, WalletClient } from "viem";
import { createBundlerClient, createPaymasterClient, SmartAccount, UserOperationReceipt, WebAuthnAccount } from "viem/account-abstraction";
import { METHOD_TYPES, SMART_ACCOUNT, TRANSACTION_ENVELOPE_TYPES } from "./constants";
export type CustomTokenInfo = BaseTokenInfo & {
    erc20: boolean;
    customTokenId?: string;
    isEtherScan?: boolean;
};
export interface EthereumBlock {
    blockHash: string;
    idempotencyKey: string;
    timestamp: string;
    baseFeePerGas: string;
    gasLimit: string;
}
export interface UserRequestApprovalParams {
    windowId?: string;
    origin?: string;
}
export interface BaseRequestParams {
    /**
     * Unique id for each request
     */
    id?: string;
    /**
     * Address to send this transaction from.
     */
    from: string;
    /**
     * Domain requested from
     */
    origin?: string;
}
export interface MessageParams extends BaseRequestParams {
    data: string;
}
export type MessageStatusType = (typeof MessageStatus)[keyof typeof MessageStatus];
export interface AbstractMessage {
    id: string;
    time: number;
    status: MessageStatusType;
    /**
     * JRPC method for which sig request is made
     */
    type: string;
    rawSig?: string;
    metadata?: Json;
    error?: string;
}
export interface Message extends AbstractMessage {
    messageParams: MessageParams;
}
export type SignTypedDataMessageV4 = {
    types: Record<string, TypedDataField[]>;
    domain: TypedDataDomain;
    message: Record<string, unknown>;
};
export interface AddChainMessageParams extends BaseRequestParams {
    chainId: string;
    chainName: string;
    nativeCurrency: {
        name: string;
        symbol: string;
        decimals: number;
    };
    rpcUrls: string[];
    blockExplorerUrls?: string[];
}
export interface AddChainMessage extends AbstractMessage {
    messageParams: AddChainMessageParams;
}
export interface TypedMessageParams extends BaseRequestParams {
    data: string | SignTypedDataMessageV4;
}
export interface TypedMessage extends AbstractMessage {
    messageParams: TypedMessageParams;
}
export type TRANSACTION_ENVELOPE_TYPES_TYPE = (typeof TRANSACTION_ENVELOPE_TYPES)[keyof typeof TRANSACTION_ENVELOPE_TYPES];
export interface TransactionParams extends BaseRequestParams {
    /**
     * Network ID as per EIP-155.
     */
    chainId?: string;
    /**
     * Data to pass with this transaction.
     */
    data?: string;
    /**
     * Error message for gas estimation failure.
     */
    estimateGasError?: string;
    /**
     * Estimated base fee for this transaction.
     */
    estimatedBaseFee?: string;
    /**
     * Gas to send with this transaction.
     */
    gas?: string;
    /**
     * Price of gas with this transaction.
     */
    gasPrice?: string;
    /**
     * Gas used in the transaction.
     */
    gasUsed?: string;
    /**
     * Maximum fee per gas for this transaction.
     */
    maxFeePerGas?: string;
    /**
     * Maximum priority fee per gas for this transaction.
     */
    maxPriorityFeePerGas?: string;
    /**
     * Unique number to prevent replay attacks.
     */
    nonce?: string;
    /**
     * Address to send this transaction to.
     */
    to?: string;
    /**
     * Value associated with this transaction.
     */
    value?: string;
    /**
     * EIP 2930
     */
    accessList?: AccessList;
    /**
     * Custom Nonce passed by the user
     */
    customNonceValue?: string;
    /**
     * Transaction envelope type
     */
    type?: TRANSACTION_ENVELOPE_TYPES_TYPE;
    /**
     * Max Gas to send with this transaction.
     */
    gasLimit?: string;
    /**
     * The amount of gas to allocate the main execution call
     */
    callGasLimit?: string;
    /**
     * Extra gas to pay the Bundler.
     */
    preVerificationGas?: string;
    /**
     * The amount of gas to allocate for the verification step
     */
    verificationGasLimit?: string;
    /**
     * The amount of gas to allocate for the Paymaster validation code
     */
    paymasterVerificationGasLimit?: string;
    /**
     * The amount of gas to allocate for the Paymaster post-operation code
     */
    paymasterPostOpGasLimit?: string;
}
export type Nonce = {
    name: string;
    nonce: number;
    details: {
        startPoint?: number;
        highest?: number;
        block?: EthereumBlock;
        baseCount?: number;
    };
};
export type NonceDetails = {
    params: {
        highestLocallyConfirmed: number;
        nextNetworkNonce: number;
        highestSuggested: number;
    };
    local: Nonce;
    network: Nonce;
};
/**
 * Ref - https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt
 */
export interface TransactionReceipt {
    transactionHash: string;
    transactionIndex: string;
    blockNumber: string;
    blockHash: string;
    from: string;
    to: string | null;
    cumulativeGasUsed: string;
    effectiveGasPrice: string;
    gasUsed: string;
    contractAddress: string | null;
    logs: unknown[];
    logsBloom: string;
    type: TRANSACTION_ENVELOPE_TYPES_TYPE;
    root?: string;
    status?: "0x0" | "0x1";
}
export type BlockTag = "earliest" | "finalized" | "safe" | "latest" | "pending";
export type BlockParams = string | BlockTag;
export interface TransactionRPCMeta {
    v: string;
    r: string;
    s: string;
    to: string | null;
    gas: string;
    from: string;
    hash: string;
    nonce: string;
    input: string;
    value: string;
    accessList?: string[];
    blockHash: string | null;
    blockNumber: string | null;
    transactionIndex: string | null;
    maxFeePerGas?: string;
    maxPriorityFeePerGas?: string;
    gasPrice?: string;
    type: TRANSACTION_ENVELOPE_TYPES_TYPE;
    chainID?: string;
}
export type PollingBlockTrackerState = BaseBlockTrackerState<EthereumBlock>;
export interface EthereumProviderConfig extends ProviderConfig {
    isErc20?: boolean;
    tokenAddress?: string;
}
export interface EthereumNetworkState extends NetworkState {
    providerConfig: EthereumProviderConfig;
}
export interface EthereumNetworkConfig extends NetworkConfig, Partial<PollingBlockTrackerConfig> {
    providerConfig: EthereumProviderConfig;
}
export type CustomNetworkPayload = Partial<EthereumProviderConfig> & Pick<EthereumProviderConfig, "chainId" | "displayName" | "rpcTarget" | "ticker">;
export interface CustomNetworks {
    id: number;
    created_at: Date;
    updated_at: Date;
    network_name: string;
    public_address: string;
    chain_id: string;
    rpc_url: string;
    symbol?: string;
    symbol_name?: string;
    decimals?: string;
    logo?: string;
    block_explorer_url?: string;
    is_testnet?: boolean;
}
export interface EthereumUser extends User {
    customNetworks: CustomNetworks[];
}
export interface ContractParams {
    erc20?: boolean;
    erc721?: boolean;
    erc1155?: boolean;
    isSpecial?: boolean;
    symbol?: string;
    logo?: string;
    decimals?: number;
}
export interface DappSuggestedGasFees {
    gasPrice?: string;
    maxPriorityFeePerGas?: string;
    maxFeePerGas?: string;
    gas?: string;
}
export interface EthereumTransactionMeta extends TransactionMeta<TransactionParams> {
    r?: string;
    s?: string;
    v?: string;
    type: string;
    txReceipt?: TransactionReceipt;
    history: Record<string, unknown>[];
    accessList?: string[];
    firstRetryBlockNumber?: string;
    retryCount?: number;
    simulationFails?: Record<string, unknown>;
    loadingDefaults?: boolean;
    transactionCategory?: TRANSACTION_TYPE;
    contractType?: string;
    nonceDetails?: NonceDetails;
    methodParams?: unknown[];
    dappSuggestedGasFees?: DappSuggestedGasFees;
    isUserOperation?: boolean;
    userOpHash?: string;
    userOpReceipt?: UserOperationReceipt;
}
export interface TransactionPayload {
    created_at: Date;
    from: string;
    to: string;
    total_amount: string;
    currency_amount: string;
    selected_currency: string;
    status?: TransactionStatus;
    chain_id: string;
    transaction_hash: string;
    transaction_category: string;
    gas: string;
    gasPrice: string;
    nonce: string;
    type: string;
    type_name: string;
    type_image_link: string;
    symbol: string;
    is_cancel: boolean;
    contract_address?: string;
    from_aa_address?: string;
    isEtherscan?: boolean;
    token_id?: string;
    input?: string;
    etherscanLink?: string;
}
export interface FetchedTransaction extends TransactionPayload {
    id: string;
}
export interface FetchCommonTransaction extends PaymentTransaction {
    etherscanLink?: string | null;
}
export interface FormattedTransactionActivity extends BaseFormattedTransactionActivity {
    from_aa_address?: string;
    etherscanLink: string;
    ethRate: string;
    isEtherscan?: boolean;
    nonce: string;
    gas: string;
    gasPrice: string;
    cancelGas?: string;
    cancelGasPrice?: string;
}
export interface ProviderChangeChannelEventData {
    newNetwork: EthereumProviderConfig;
    whitelabelData: PopupWhitelabelData;
    origin: string;
    currentChainId: string;
}
export interface NonceLockRes {
    nextNonce: number;
    nonceDetails: NonceDetails;
    releaseLock: MutexInterface.Releaser;
}
export type METHOD_TYPES_TYPE = (typeof METHOD_TYPES)[keyof typeof METHOD_TYPES];
export interface EtherscanTransaction {
    blockNumber: string;
    timeStamp: string;
    hash: string;
    nonce: string;
    blockHash: string;
    transactionIndex: string;
    from: string;
    to: string;
    value: string;
    gas: string;
    gasPrice: string;
    isError: string;
    txreceipt_status: string;
    input: string;
    contractAddress: string;
    cumulativeGasUsed: string;
    gasUsed: string;
    confirmations: string;
    methodId: string;
    functionName: string;
    transaction_category: string;
    type_name: string;
    type: string;
    type_image_link: string;
    chainId: string;
    tokenSymbol: string;
    tokenName: string;
    tokenID: string;
    tokenValue: string;
    tokenDecimal: string;
}
export interface NetworkControllerEvents<S> extends BaseControllerEvents<S> {
    networkDidChange: () => void;
}
export interface AbstractMessageControllerEvents<S, M> extends BaseControllerEvents<S> {
    [event: `${string}:${MessageStatusType}`]: (message: M) => void;
    [event: `${string}:finished`]: (message: M) => void;
    [MESSAGE_EVENTS.UNAPPROVED_MESSAGE]: (args: {
        messageData: M;
        req: JRPCRequest<unknown> & UserRequestApprovalParams;
    }) => void;
}
export type TX_BLOCK_EVENT_TYPE = {
    txMeta: EthereumTransactionMeta;
    latestBlockNumber?: string;
} & BASE_TX_EVENT_TYPE;
export type PendingTransactionTrackerEvents<S> = BaseControllerEvents<S> & {
    [TX_EVENTS.TX_WARNING]: (args: TX_WARNING_EVENT_TYPE<TransactionParams, EthereumTransactionMeta>) => void;
    [TX_EVENTS.TX_BLOCK_UPDATE]: (args: TX_BLOCK_EVENT_TYPE) => void;
    [TX_EVENTS.TX_RETRY]: (args: {
        txMeta: EthereumTransactionMeta;
    } & BASE_TX_EVENT_TYPE) => void;
    [TX_EVENTS.TX_FAILED]: (args: TX_FAILED_EVENT_TYPE) => void;
    [TX_EVENTS.TX_DROPPED]: (args: TX_DROPPED_EVENT_TYPE) => void;
    [TX_EVENTS.TX_CONFIRMED]: (args: TX_CONFIRMED_EVENT_TYPE) => void;
};
export type EthereumTransactionEvents<T, U> = BaseTransactionEvents<TransactionState<T, TransactionMeta<T>>, U> & {
    [TX_EVENTS.TX_UNAPPROVED]: (data: {
        txMeta: U;
        req: JRPCRequest<TransactionParams> & UserRequestApprovalParams;
    }) => void;
} & {
    [event: `${string}:unapproved`]: (txMeta: U) => void;
    [event: `${string}:${Exclude<TransactionStatus, "unapproved">}`]: (txId: string) => void;
};
type Transport = Parameters<typeof createBundlerClient>[0]["transport"];
export type BundlerConfig = Omit<Parameters<typeof createBundlerClient>[0], "account" | "client" | "transport" | "paymaster"> & ({
    url: string;
    transport?: Transport;
} | {
    url?: string;
    transport: Transport;
});
export type PaymasterConfig = Omit<Parameters<typeof createPaymasterClient>[0], "transport"> & ({
    url: string;
    transport?: Transport;
} | {
    url?: string;
    transport: Transport;
});
export type BiconomySmartAccountConfig = Pick<ToBiconomySmartAccountParameters, "entryPoint" | "ecdsaModuleAddress" | "factoryAddress">;
export type KernelSmartAccountParameters = Parameters<typeof toEcdsaKernelSmartAccount>[0];
export type KernelSmartAccountConfig = Omit<KernelSmartAccountParameters, "owners" | "client" | "address" | "nonceKey" | "index">;
export type ToMetaMaskSmartAccountParameters<TImplementation extends Implementation> = Parameters<typeof toMetaMaskSmartAccount<TImplementation>>[0];
export type MetamaskSmartAccountConfig<TImplementation extends Implementation = Implementation.Hybrid> = Omit<ToMetaMaskSmartAccountParameters<TImplementation>, "client" | "signatory" | "deployParams" | "implementation"> & {
    implementation?: TImplementation;
    hybridParams?: {
        p256KeyIds?: string[];
        p256XValues?: bigint[];
        p256YValues?: bigint[];
        webAuthnAccount?: WebAuthnAccount;
        keyId?: Hex;
    };
    multiSigParams?: {
        additionalSignerAddresses: Hex[];
        additionalSignerWalletClients: WalletClient[];
        threshold: bigint;
    };
};
export type LightSmartAccountConfig = Omit<ToLightSmartAccountParameters, "owner" | "client" | "index" | "address" | "nonceKey">;
export type NexusSmartAccountConfig = Omit<ToNexusSmartAccountParameters, "owners" | "client" | "index" | "address">;
export type SafeSmartAccountParameters = Parameters<typeof toSafeSmartAccount>[0];
export type SafeSmartAccountConfig = Omit<SafeSmartAccountParameters, "owners" | "client" | "address" | "nonceKey" | "saltNonce" | "validUntil" | "validAfter">;
export type SimpleSmartAccountParameters = Parameters<typeof toSimpleSmartAccount>[0];
export type SimpleSmartAccountConfig = Omit<SimpleSmartAccountParameters, "owner" | "client">;
export type TrustSmartAccountParameters = Parameters<typeof toTrustSmartAccount>[0];
export type TrustSmartAccountConfig = Omit<TrustSmartAccountParameters, "owner" | "client" | "address" | "nonceKey" | "index">;
export interface ISmartAccount {
    getSmartAccount(params: {
        walletClient: WalletClient;
        client: Client;
    }): Promise<SmartAccount>;
}
export type SmartAccountType = (typeof SMART_ACCOUNT)[keyof typeof SMART_ACCOUNT];
export type SmartAccountConfig<TImplementation extends Implementation = Implementation.Hybrid> = BiconomySmartAccountConfig | KernelSmartAccountConfig | NexusSmartAccountConfig | SafeSmartAccountConfig | TrustSmartAccountConfig | MetamaskSmartAccountConfig<TImplementation>;
export type AccountAbstractionMultiChainConfig = {
    smartAccountType?: SmartAccountType;
    chains?: {
        chainId: string;
        bundlerConfig: BundlerConfig;
        paymasterConfig?: PaymasterConfig;
        smartAccountConfig?: SmartAccountConfig;
    }[];
};
export interface UserOperationGas {
    callGasLimit: string;
    preVerificationGas: string;
    verificationGasLimit: string;
    paymasterVerificationGasLimit?: string;
    paymasterPostOpGasLimit?: string;
}
export {};
