import _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';
import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { BaseController, createAnalyticsMiddleware, createSwappableProxy, createEventEmitterProxy } from '@toruslabs/base-controllers';
import { JRPCEngine, providerFromEngine } from '@web3auth/auth';
import { Mutex } from 'async-mutex';
import log from 'loglevel';
import { SUPPORTED_NETWORKS, MAINNET_CHAIN_ID } from '../utils/constants.js';
import { createEthereumMiddleware } from './createEthereumMiddleware.js';
import { createJsonRpcClient } from './createJsonRpcClient.js';

const _excluded = ["chainId", "rpcTarget"];
class NetworkController extends BaseController {
  constructor({
    config,
    state,
    idleTimeTracker,
    analytics
  }) {
    super({
      config,
      state
    });
    _defineProperty(this, "name", "NetworkController");
    _defineProperty(this, "providerProxy", void 0);
    _defineProperty(this, "blockTrackerProxy", void 0);
    _defineProperty(this, "mutex", new Mutex());
    _defineProperty(this, "provider", null);
    _defineProperty(this, "blockTracker", null);
    _defineProperty(this, "baseProviderHandlers", void 0);
    _defineProperty(this, "idleTimeTracker", void 0);
    _defineProperty(this, "analytics", void 0);
    this.defaultState = {
      chainId: "loading",
      properties: {
        EIPS_1559: undefined
      },
      providerConfig: SUPPORTED_NETWORKS[MAINNET_CHAIN_ID]
    };
    this.analytics = analytics;

    // when a new network is set,
    // we set to loading first and
    // then when connection succeeds,
    // we update the network
    this.initialize();
    this.idleTimeTracker = idleTimeTracker;
  }
  getNetworkIdentifier() {
    return this.state.chainId;
  }
  getNetworkRPCUrl() {
    return this.state.providerConfig.rpcTarget;
  }

  /**
   * Called by orchestrator once while initializing the class
   * @param providerHandlers - JRPC handlers for provider
   * @returns - provider - Returns the providerProxy
   */
  initializeProvider(providerHandlers) {
    this.baseProviderHandlers = providerHandlers;
    this.configureProvider();
    this.lookupNetwork(); // Not awaiting this, because we don't want to block the initialization
    return this.providerProxy;
  }
  getProvider() {
    return this.providerProxy;
  }
  getBlockTracker() {
    return this.blockTrackerProxy;
  }
  getProviderConfig() {
    return this.state.providerConfig;
  }
  setProviderConfig(config) {
    this.update({
      providerConfig: _objectSpread({}, config)
    });
    this.refreshNetwork();
  }
  async getEIP1559Compatibility() {
    const {
      EIPS_1559
    } = this.state.properties;
    // log.info('checking eip 1559 compatibility')
    if (EIPS_1559 !== undefined) {
      return EIPS_1559;
    }
    const latestBlock = await this.blockTracker.getLatestBlock();
    const supportsEIP1559 = latestBlock && latestBlock.baseFeePerGas !== undefined;
    this.update({
      properties: {
        EIPS_1559: supportsEIP1559
      }
    });
    return supportsEIP1559;
  }

  /**
   * Refreshes the current network code
   */
  async lookupNetwork() {
    const {
      chainId,
      rpcTarget
    } = this.getProviderConfig();
    if (!chainId || !rpcTarget || !this.provider) {
      this.update({
        chainId: "loading",
        properties: {}
      });
      return;
    }
    const releaseLock = await this.mutex.acquire();
    try {
      // use eth_chainId
      const [networkChainId] = await Promise.all([this.provider.request({
        method: "eth_chainId"
      }), this.getEIP1559Compatibility()]);
      log.info("network fetched chain id", networkChainId);
      // update chain ID
      this.update({
        chainId: networkChainId
      });
      this.emit("networkDidChange");
    } catch {
      this.update({
        chainId: "loading"
      });
    } finally {
      releaseLock();
    }
  }
  configureProvider() {
    const _this$getProviderConf = this.getProviderConfig(),
      {
        chainId,
        rpcTarget
      } = _this$getProviderConf,
      rest = _objectWithoutProperties(_this$getProviderConf, _excluded);
    if (!chainId || !rpcTarget) {
      throw new Error("chainId and rpcTarget must be provided in providerConfig");
    }
    this.configureStandardProvider(_objectSpread({
      chainId,
      rpcTarget
    }, rest));
  }
  setNetworkClient({
    networkMiddleware,
    blockTracker
  }) {
    const ethereumMiddleware = createEthereumMiddleware(this.baseProviderHandlers, this.getProviderConfig(), this.analytics);
    const engine = new JRPCEngine();
    engine.push(createAnalyticsMiddleware({
      providerConfig: this.getProviderConfig(),
      analytics: this.analytics
    }));
    engine.push(ethereumMiddleware);
    engine.push(networkMiddleware);
    const provider = providerFromEngine(engine);
    this.setProvider({
      provider,
      blockTracker
    });
  }
  setProvider({
    provider,
    blockTracker
  }) {
    if (this.providerProxy) {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      this.providerProxy.setTarget(provider);
    } else {
      this.providerProxy = createSwappableProxy(provider);
    }
    if (this.blockTrackerProxy) {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      this.blockTrackerProxy.setTarget(blockTracker);
    } else {
      this.blockTrackerProxy = createEventEmitterProxy(blockTracker, {
        eventFilter: "skipInternal"
      });
    }

    // set new provider and blockTracker
    this.provider = provider;
    provider.setMaxListeners(10);
    this.blockTracker = blockTracker;
  }
  configureStandardProvider(providerConfig) {
    const networkClient = createJsonRpcClient(providerConfig, this.config, this.idleTimeTracker, this.analytics);
    log.info("networkClient", networkClient);
    this.setNetworkClient(networkClient);
  }
  refreshNetwork() {
    this.update({
      chainId: "loading",
      properties: {}
    });
    this.configureProvider();
    this.lookupNetwork();
  }
}

export { NetworkController };
