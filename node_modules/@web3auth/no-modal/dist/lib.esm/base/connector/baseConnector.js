import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { SafeEventEmitter } from '@web3auth/auth';
import { CONNECTOR_NAMESPACES } from '../chain/IChainInterface.js';
import { WalletInitializationError, WalletLoginError } from '../errors/index.js';
import { WALLET_CONNECTORS } from '../wallet/index.js';
import { CONNECTED_STATUSES, CAN_AUTHORIZE_STATUSES } from './connectorStatus.js';
import { CONNECTOR_STATUS, CONNECTOR_EVENTS } from './constants.js';
import { CHAIN_NAMESPACES } from '@toruslabs/base-controllers';

class BaseConnector extends SafeEventEmitter {
  constructor(options) {
    super();
    _defineProperty(this, "connectorData", {});
    _defineProperty(this, "isInjected", void 0);
    _defineProperty(this, "icon", void 0);
    _defineProperty(this, "coreOptions", void 0);
    _defineProperty(this, "rehydrated", false);
    _defineProperty(this, "connectorNamespace", void 0);
    _defineProperty(this, "type", void 0);
    _defineProperty(this, "name", void 0);
    _defineProperty(this, "status", void 0);
    this.coreOptions = options.coreOptions;
  }
  get connected() {
    return CONNECTED_STATUSES.includes(this.status);
  }
  get canAuthorize() {
    return CAN_AUTHORIZE_STATUSES.includes(this.status);
  }
  checkConnectionRequirements() {
    // we reconnect without killing existing Wallet Connect or Metamask Connect session on calling connect again.
    if (this.name === WALLET_CONNECTORS.WALLET_CONNECT_V2 && this.status === CONNECTOR_STATUS.CONNECTING) return;
    if (this.name === WALLET_CONNECTORS.METAMASK && !this.isInjected && this.status === CONNECTOR_STATUS.CONNECTING) return;
    if (this.status === CONNECTOR_STATUS.CONNECTING) throw WalletInitializationError.notReady("Already connecting");
    if (this.connected) throw WalletLoginError.connectionError("Already connected");
    if (this.status !== CONNECTOR_STATUS.READY) throw WalletLoginError.connectionError("Wallet connector is not ready yet, Please wait for init function to resolve before calling connect/connectTo function");
  }
  checkInitializationRequirements({
    chainConfig
  }) {
    if (!this.coreOptions.clientId) throw WalletInitializationError.invalidParams("Please initialize Web3Auth with a valid clientId in constructor");
    if (!chainConfig) throw WalletInitializationError.invalidParams("chainConfig is required before initialization");
    if (!chainConfig.rpcTarget && chainConfig.chainNamespace !== CHAIN_NAMESPACES.OTHER) {
      throw WalletInitializationError.invalidParams("rpcTarget is required in chainConfig");
    }
    if (!chainConfig.chainId && chainConfig.chainNamespace !== CHAIN_NAMESPACES.OTHER) {
      throw WalletInitializationError.invalidParams("chainID is required in chainConfig");
    }
    if (this.connectorNamespace !== CONNECTOR_NAMESPACES.MULTICHAIN && this.connectorNamespace !== chainConfig.chainNamespace) throw WalletInitializationError.invalidParams("Connector doesn't support this chain namespace");
    if (this.status === CONNECTOR_STATUS.NOT_READY) return;
    if (this.connected) throw WalletInitializationError.notReady("Already connected");
    if (this.status === CONNECTOR_STATUS.READY) throw WalletInitializationError.notReady("Connector is already initialized");
  }
  checkDisconnectionRequirements() {
    if (!this.connected) throw WalletLoginError.disconnectionError("Not connected with wallet");
  }
  checkSwitchChainRequirements(params, init = false) {
    if (!init && !this.provider) throw WalletLoginError.notConnectedError("Not connected with wallet.");
    if (!this.coreOptions.chains) throw WalletInitializationError.invalidParams("chainConfigs is required");
    const doesChainExist = this.coreOptions.chains.some(x => x.chainId === params.chainId && (x.chainNamespace === this.connectorNamespace || this.connectorNamespace === CONNECTOR_NAMESPACES.MULTICHAIN));
    if (!doesChainExist) throw WalletInitializationError.invalidParams("Invalid chainId");
  }
  updateConnectorData(data) {
    this.connectorData = data;
    this.emit(CONNECTOR_EVENTS.CONNECTOR_DATA_UPDATED, {
      connectorName: this.name,
      data
    });
  }
}

export { BaseConnector };
