import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import { bs58 } from '@toruslabs/bs58';
import { getAccountsFromNamespaces, parseAccountId } from '@walletconnect/utils';
import { providerErrors, rpcErrors } from '@web3auth/auth';
import { EVM_METHOD_TYPES, SOLANA_METHOD_TYPES } from '@web3auth/ws-embed';
import { formatChainId } from './utils.js';
import { WalletLoginError } from '../../base/errors/index.js';
import { SOLANA_CAIP_CHAIN_MAP } from '../../base/constants.js';

async function getLastActiveSession(signClient) {
  if (signClient.session.length) {
    const lastKeyIndex = signClient.session.keys.length - 1;
    return signClient.session.get(signClient.session.keys[lastKeyIndex]);
  }
  return null;
}
function isMobileDevice() {
  return /Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop/i.test(window.navigator.userAgent);
}
function isSolanaChain(chainId) {
  return chainId.startsWith("solana:");
}
async function sendJrpcRequest(signClient, chainId, method, params) {
  const session = await getLastActiveSession(signClient);
  if (!session) {
    throw providerErrors.disconnected();
  }
  if (typeof window !== "undefined" && isMobileDevice()) {
    if (session.peer.metadata.redirect && session.peer.metadata.redirect.native) {
      window.open(session.peer.metadata.redirect.native, "_blank");
    }
  }
  return signClient.request({
    topic: session.topic,
    chainId,
    request: {
      method,
      params: isSolanaChain(chainId) ? _objectSpread(_objectSpread({}, params), {}, {
        pubkey: session.self.publicKey
      }) : params
    }
  });
}
async function getAccounts(signClient) {
  const session = await getLastActiveSession(signClient);
  if (!session) {
    throw providerErrors.disconnected();
  }
  const accounts = getAccountsFromNamespaces(session.namespaces);
  if (accounts && accounts.length) {
    return [...new Set(accounts.map(add => {
      return parseAccountId(add).address;
    }))];
  }
  throw WalletLoginError.connectionError("Failed to get accounts");
}
function getEthProviderHandlers({
  connector,
  chainId
}) {
  return {
    getPrivateKey: async () => {
      throw rpcErrors.methodNotSupported();
    },
    getPublicKey: async () => {
      throw rpcErrors.methodNotSupported();
    },
    getAccounts: async _ => {
      return getAccounts(connector);
    },
    processTransaction: async (txParams, _) => {
      const methodRes = await sendJrpcRequest(connector, `eip155:${chainId}`, EVM_METHOD_TYPES.ETH_TRANSACTION, [txParams]);
      return methodRes;
    },
    processSignTransaction: async (txParams, _) => {
      const methodRes = await sendJrpcRequest(connector, `eip155:${chainId}`, "eth_signTransaction", [txParams]);
      return methodRes;
    },
    processEthSignMessage: async (msgParams, _) => {
      const methodRes = await sendJrpcRequest(connector, `eip155:${chainId}`, EVM_METHOD_TYPES.ETH_SIGN, [msgParams.from, msgParams.data]);
      return methodRes;
    },
    processPersonalMessage: async (msgParams, _) => {
      const methodRes = await sendJrpcRequest(connector, `eip155:${chainId}`, EVM_METHOD_TYPES.PERSONAL_SIGN, [msgParams.data, msgParams.from]);
      return methodRes;
    },
    processTypedMessageV4: async msgParams => {
      const methodRes = await sendJrpcRequest(connector, `eip155:${chainId}`, EVM_METHOD_TYPES.ETH_SIGN_TYPED_DATA_V4, [msgParams.from, msgParams.data]);
      return methodRes;
    }
  };
}
function getSolProviderHandlers({
  connector,
  chainId
}) {
  return {
    requestAccounts: async _ => {
      return getAccounts(connector);
    },
    getPrivateKey: async () => {
      throw rpcErrors.methodNotSupported();
    },
    getSecretKey: async () => {
      throw rpcErrors.methodNotSupported();
    },
    getPublicKey: async () => {
      throw rpcErrors.methodNotSupported();
    },
    getAccounts: async _ => {
      return getAccounts(connector);
    },
    signAllTransactions: async _ => {
      throw rpcErrors.methodNotSupported();
    },
    signAndSendTransaction: async _ => {
      throw rpcErrors.methodNotSupported();
    },
    signMessage: async req => {
      const methodRes = await sendJrpcRequest(connector, `solana:${SOLANA_CAIP_CHAIN_MAP[chainId]}`, SOLANA_METHOD_TYPES.SIGN_MESSAGE, {
        message: bs58.encode(Buffer.from(req.params.data, "utf-8"))
      });
      return methodRes.signature;
    },
    signTransaction: async req => {
      const accounts = await getAccounts(connector);
      if (accounts.length === 0) {
        throw providerErrors.disconnected();
      }
      const methodRes = await sendJrpcRequest(connector, `solana:${SOLANA_CAIP_CHAIN_MAP[chainId]}`, SOLANA_METHOD_TYPES.SIGN_TRANSACTION, {
        transaction: req.params.message
      });
      return methodRes.signature;
    }
  };
}
async function switchChain({
  connector,
  chainId,
  newChainId
}) {
  await sendJrpcRequest(connector, `eip155:${chainId}`, "wallet_switchEthereumChain", [{
    chainId: newChainId
  }]);
}
async function addChain({
  connector,
  chainId,
  chainConfig
}) {
  if (!chainConfig) {
    throw providerErrors.custom({
      message: "Chain config is required",
      code: 4902
    });
  }
  const formattedChainId = formatChainId(chainConfig.chainId);
  const formattedChainConfig = _objectSpread(_objectSpread({}, chainConfig), {}, {
    chainId: formattedChainId
  });
  await sendJrpcRequest(connector, `eip155:${chainId}`, "wallet_addEthereumChain", [formattedChainConfig]);
}

export { addChain, getAccounts, getEthProviderHandlers, getSolProviderHandlers, sendJrpcRequest, switchChain };
