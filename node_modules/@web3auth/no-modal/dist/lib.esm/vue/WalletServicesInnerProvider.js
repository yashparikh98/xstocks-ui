import { defineComponent, h, shallowRef, ref, watch, provide } from 'vue';
import { useWeb3AuthInner } from './composables/useWeb3AuthInner.js';
import { WalletServicesContextKey } from './context/WalletServicesContext.js';
import { WalletServicesPluginError } from '../base/plugin/errors.js';
import { EVM_PLUGINS, PLUGIN_EVENTS } from '../base/plugin/IPlugin.js';
import { CONNECTOR_STATUS } from '../base/connector/constants.js';

const WalletServicesInnerProvider = defineComponent({
  name: "WalletServicesInnerProvider",
  setup() {
    const web3AuthContext = useWeb3AuthInner();
    if (!web3AuthContext) throw WalletServicesPluginError.fromCode(1000, "`WalletServicesProvider` must be wrapped by `Web3AuthProvider`");
    const {
      getPlugin,
      isInitialized,
      isConnected
    } = web3AuthContext;
    const walletServicesPlugin = shallowRef(null);
    const ready = ref(false);
    const connecting = ref(false);
    watch(isInitialized, newIsInitialized => {
      if (newIsInitialized) {
        const plugin = getPlugin(EVM_PLUGINS.WALLET_SERVICES);
        walletServicesPlugin.value = plugin;
      }
    });
    watch(isConnected, newIsConnected => {
      if (newIsConnected) {
        var _walletServicesPlugin;
        const plugin = getPlugin(EVM_PLUGINS.WALLET_SERVICES);
        walletServicesPlugin.value = plugin;
        // when rehydrating, the connectedListener may be registered after the connected event is emitted, we need to check the status here
        if (((_walletServicesPlugin = walletServicesPlugin.value) === null || _walletServicesPlugin === void 0 ? void 0 : _walletServicesPlugin.status) === CONNECTOR_STATUS.CONNECTED) ready.value = true;
      }
    });
    watch(walletServicesPlugin, (newWalletServicesPlugin, prevWalletServicesPlugin) => {
      const connectedListener = () => {
        ready.value = true;
      };
      const disconnectedListener = () => {
        ready.value = false;
      };
      const connectingListener = () => {
        connecting.value = true;
      };

      // unregister previous listeners
      if (prevWalletServicesPlugin && newWalletServicesPlugin !== prevWalletServicesPlugin) {
        prevWalletServicesPlugin.removeListener(PLUGIN_EVENTS.CONNECTED, connectedListener);
        prevWalletServicesPlugin.removeListener(PLUGIN_EVENTS.DISCONNECTED, disconnectedListener);
        prevWalletServicesPlugin.removeListener(PLUGIN_EVENTS.CONNECTING, connectingListener);
      }
      if (newWalletServicesPlugin && newWalletServicesPlugin !== prevWalletServicesPlugin) {
        newWalletServicesPlugin.on(PLUGIN_EVENTS.CONNECTED, connectedListener);
        newWalletServicesPlugin.on(PLUGIN_EVENTS.DISCONNECTED, disconnectedListener);
        newWalletServicesPlugin.on(PLUGIN_EVENTS.CONNECTING, connectingListener);
      }
    });
    provide(WalletServicesContextKey, {
      plugin: walletServicesPlugin,
      ready,
      connecting
    });
  },
  render() {
    var _this$$slots$default;
    return h((_this$$slots$default = this.$slots.default) !== null && _this$$slots$default !== void 0 ? _this$$slots$default : "");
  }
});

export { WalletServicesInnerProvider };
