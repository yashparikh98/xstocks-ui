'use strict';

var react = require('react');
var analytics = require('../../base/analytics.js');
require('@toruslabs/base-controllers');
require('@babel/runtime/helpers/defineProperty');
require('@web3auth/auth');
var index = require('../../base/errors/index.js');
require('../../base/wallet/index.js');
require('../../base/connector/connectorStatus.js');
var constants = require('../../base/connector/constants.js');
require('jwt-decode');
require('../../base/loglevel.js');
require('../../base/plugin/errors.js');
require('../../base/plugin/IPlugin.js');
require('@toruslabs/constants');
require('@toruslabs/http-helpers');
var noModal = require('../../noModal.js');

const Web3AuthInnerContext = react.createContext(null);
function Web3AuthInnerProvider(params) {
  const {
    children,
    config,
    initialState
  } = params;
  const {
    web3AuthOptions
  } = config;
  const web3Auth = react.useMemo(() => {
    setProvider(null);
    return new noModal.Web3AuthNoModal(web3AuthOptions, initialState);
  }, [web3AuthOptions, initialState]);
  const [chainId, setChainId] = react.useState(null);
  const [chainNamespace, setChainNamespace] = react.useState(null);
  const [isInitializing, setIsInitializing] = react.useState(false);
  const [initError, setInitError] = react.useState(null);
  const [isConnected, setIsConnected] = react.useState(false);
  const [provider, setProvider] = react.useState(null);
  const [isInitialized, setIsInitialized] = react.useState(false);
  const [status, setStatus] = react.useState(null);
  const [isMFAEnabled, setIsMFAEnabled] = react.useState(false);
  const [isAuthorized, setIsAuthorized] = react.useState(false);
  const getPlugin = react.useCallback(name => {
    if (!web3Auth) throw index.WalletInitializationError.notReady();
    return web3Auth.getPlugin(name);
  }, [web3Auth]);
  react.useEffect(() => {
    const controller = new AbortController();
    async function init() {
      try {
        var _web3Auth$currentChai;
        setInitError(null);
        setIsInitializing(true);
        web3Auth.setAnalyticsProperties({
          integration_type: analytics.ANALYTICS_INTEGRATION_TYPE.REACT_HOOKS
        });
        await web3Auth.init({
          signal: controller.signal
        });
        setChainId(web3Auth.currentChainId);
        setChainNamespace((_web3Auth$currentChai = web3Auth.currentChain) === null || _web3Auth$currentChai === void 0 ? void 0 : _web3Auth$currentChai.chainNamespace);
      } catch (error) {
        setInitError(error);
      } finally {
        setIsInitializing(false);
      }
    }
    if (web3Auth) init();
    return () => {
      controller.abort();
    };
  }, [web3Auth]);
  react.useEffect(() => {
    const handleChainChange = async chainId => {
      var _web3Auth$currentChai2;
      setChainId(chainId);
      setChainNamespace(web3Auth === null || web3Auth === void 0 || (_web3Auth$currentChai2 = web3Auth.currentChain) === null || _web3Auth$currentChai2 === void 0 ? void 0 : _web3Auth$currentChai2.chainNamespace);
    };
    if (provider) {
      provider.on("chainChanged", handleChainChange);
      return () => {
        if (provider) {
          provider.removeListener("chainChanged", handleChainChange);
        }
      };
    }
  }, [web3Auth, provider]);
  react.useEffect(() => {
    const notReadyListener = () => setStatus(constants.CONNECTOR_STATUS.NOT_READY);
    const readyListener = () => {
      setStatus(web3Auth.status);
      setIsInitialized(true);
    };
    const connectedListener = data => {
      setStatus(web3Auth.status);
      // we do this because of rehydration issues. status connected is fired first but web3auth sdk is not ready yet.
      if (web3Auth.status === constants.CONNECTOR_STATUS.CONNECTED) {
        setIsInitialized(true);
        setIsConnected(true);
        setProvider(data.provider);
      }
    };
    const disconnectedListener = () => {
      setStatus(web3Auth.status);
      setIsConnected(false);
      setIsAuthorized(false);
      setProvider(null);
    };
    const connectingListener = () => {
      setStatus(web3Auth.status);
    };
    const errorListener = () => {
      setStatus(web3Auth.status);
    };
    const rehydrationErrorListener = () => {
      setStatus(web3Auth.status);
      setIsConnected(false);
      setIsAuthorized(false);
      setProvider(null);
    };
    const authorizedListener = () => {
      setStatus(web3Auth.status);
      if (web3Auth.status === constants.CONNECTOR_STATUS.AUTHORIZED) {
        setIsConnected(true);
        setIsAuthorized(true);
      }
    };
    const mfaEnabledListener = isMFAEnabled => {
      if (typeof isMFAEnabled === "boolean") setIsMFAEnabled(isMFAEnabled);
    };
    // TODO: In strict mode, web3auth becomes null and .off throws an error sometimes.
    if (web3Auth) {
      // web3Auth is initialized here.
      setStatus(web3Auth.status);
      web3Auth.on(constants.CONNECTOR_EVENTS.NOT_READY, notReadyListener);
      web3Auth.on(constants.CONNECTOR_EVENTS.READY, readyListener);
      web3Auth.on(constants.CONNECTOR_EVENTS.CONNECTED, connectedListener);
      web3Auth.on(constants.CONNECTOR_EVENTS.AUTHORIZED, authorizedListener);
      web3Auth.on(constants.CONNECTOR_EVENTS.DISCONNECTED, disconnectedListener);
      web3Auth.on(constants.CONNECTOR_EVENTS.CONNECTING, connectingListener);
      web3Auth.on(constants.CONNECTOR_EVENTS.ERRORED, errorListener);
      web3Auth.on(constants.CONNECTOR_EVENTS.REHYDRATION_ERROR, rehydrationErrorListener);
      web3Auth.on(constants.CONNECTOR_EVENTS.MFA_ENABLED, mfaEnabledListener);
    }
    return () => {
      if (web3Auth) {
        web3Auth.removeListener(constants.CONNECTOR_EVENTS.NOT_READY, notReadyListener);
        web3Auth.removeListener(constants.CONNECTOR_EVENTS.READY, readyListener);
        web3Auth.removeListener(constants.CONNECTOR_EVENTS.CONNECTED, connectedListener);
        web3Auth.removeListener(constants.CONNECTOR_EVENTS.DISCONNECTED, disconnectedListener);
        web3Auth.removeListener(constants.CONNECTOR_EVENTS.CONNECTING, connectingListener);
        web3Auth.removeListener(constants.CONNECTOR_EVENTS.ERRORED, errorListener);
        web3Auth.removeListener(constants.CONNECTOR_EVENTS.REHYDRATION_ERROR, rehydrationErrorListener);
        web3Auth.removeListener(constants.CONNECTOR_EVENTS.MFA_ENABLED, mfaEnabledListener);
        web3Auth.removeListener(constants.CONNECTOR_EVENTS.AUTHORIZED, authorizedListener);
      }
    };
  }, [web3Auth]);
  const value = react.useMemo(() => {
    return {
      web3Auth,
      isConnected,
      isInitialized,
      provider,
      status,
      isInitializing,
      initError,
      isMFAEnabled,
      chainId,
      chainNamespace,
      getPlugin,
      setIsMFAEnabled,
      isAuthorized
    };
  }, [web3Auth, isConnected, isInitialized, provider, status, getPlugin, isInitializing, initError, isMFAEnabled, setIsMFAEnabled, chainId, chainNamespace, isAuthorized]);
  return react.createElement(Web3AuthInnerContext.Provider, {
    value
  }, children);
}

exports.Web3AuthInnerContext = Web3AuthInnerContext;
exports.Web3AuthInnerProvider = Web3AuthInnerProvider;
