'use strict';

var baseControllers = require('@toruslabs/base-controllers');
var wsEmbed = require('@web3auth/ws-embed');
require('@babel/runtime/helpers/objectSpread2');
require('@babel/runtime/helpers/defineProperty');
require('@segment/analytics-next');
require('../../base/loglevel.js');
var baseConnector = require('../../base/connector/baseConnector.js');
require('../../base/connector/connectorStatus.js');
var constants = require('../../base/connector/constants.js');
require('@web3auth/auth');
var utils = require('../../base/connector/utils.js');
var index = require('../../base/errors/index.js');
require('../../base/plugin/errors.js');
require('../../base/plugin/IPlugin.js');
require('@toruslabs/constants');
require('@toruslabs/http-helpers');
require('../../base/wallet/index.js');

class BaseEvmConnector extends baseConnector.BaseConnector {
  async init(_) {}
  async getIdentityToken() {
    if (!this.provider || !this.canAuthorize) throw index.WalletLoginError.notConnectedError();
    if (!this.coreOptions) throw index.WalletInitializationError.invalidParams("Please initialize Web3Auth with valid options");
    this.status = constants.CONNECTOR_STATUS.AUTHORIZING;
    this.emit(constants.CONNECTOR_EVENTS.AUTHORIZING, {
      connector: this.name
    });
    const accounts = await this.provider.request({
      method: wsEmbed.EVM_METHOD_TYPES.GET_ACCOUNTS
    });
    if (accounts && accounts.length > 0) {
      const existingToken = utils.getSavedToken(accounts[0], this.name);
      if (existingToken) {
        const isExpired = utils.checkIfTokenIsExpired(existingToken);
        if (!isExpired) {
          this.status = constants.CONNECTOR_STATUS.AUTHORIZED;
          this.emit(constants.CONNECTOR_EVENTS.AUTHORIZED, {
            connector: this.name,
            identityTokenInfo: {
              idToken: existingToken
            }
          });
          return {
            idToken: existingToken
          };
        }
      }
      const chainId = await this.provider.request({
        method: "eth_chainId"
      });
      const currentChainConfig = this.coreOptions.chains.find(x => x.chainId === chainId);
      if (!currentChainConfig) throw index.WalletInitializationError.invalidParams("chainConfig is required before authentication");
      const {
        chainNamespace
      } = currentChainConfig;
      const payload = {
        domain: window.location.origin,
        uri: window.location.href,
        address: accounts[0],
        chainId: parseInt(chainId, 16),
        version: "1",
        nonce: Math.random().toString(36).slice(2),
        issuedAt: new Date().toISOString()
      };
      const challenge = await baseControllers.signChallenge(payload, chainNamespace);
      const hexChallenge = `0x${Buffer.from(challenge, "utf8").toString("hex")}`;
      const signedMessage = await this.provider.request({
        method: wsEmbed.EVM_METHOD_TYPES.PERSONAL_SIGN,
        params: [hexChallenge, accounts[0]]
      });
      const idToken = await baseControllers.verifySignedChallenge(chainNamespace, signedMessage, challenge, this.name, this.coreOptions.sessionTime, this.coreOptions.clientId, this.coreOptions.web3AuthNetwork);
      utils.saveToken(accounts[0], this.name, idToken);
      this.status = constants.CONNECTOR_STATUS.AUTHORIZED;
      this.emit(constants.CONNECTOR_EVENTS.AUTHORIZED, {
        connector: this.name,
        identityTokenInfo: {
          idToken
        }
      });
      return {
        idToken
      };
    }
    throw index.WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");
  }
  async disconnectSession() {
    super.checkDisconnectionRequirements();
    const accounts = await this.provider.request({
      method: "eth_accounts"
    });
    if (accounts && accounts.length > 0) {
      utils.clearToken(accounts[0], this.name);
    }
  }
  async disconnect() {
    this.rehydrated = false;
    this.emit(constants.CONNECTOR_EVENTS.DISCONNECTED);
  }
}

exports.BaseEvmConnector = BaseEvmConnector;
