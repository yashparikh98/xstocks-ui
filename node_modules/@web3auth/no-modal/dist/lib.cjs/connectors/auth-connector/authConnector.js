'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var securePubSub = require('@toruslabs/secure-pub-sub');
var auth = require('@web3auth/auth');
var deepmerge = require('deepmerge');
require('@segment/analytics-next');
var loglevel = require('../../base/loglevel.js');
var IChainInterface = require('../../base/chain/IChainInterface.js');
var baseConnector = require('../../base/connector/baseConnector.js');
var connectorStatus = require('../../base/connector/connectorStatus.js');
var constants = require('../../base/connector/constants.js');
require('jwt-decode');
var index$1 = require('../../base/errors/index.js');
require('../../base/plugin/errors.js');
require('../../base/plugin/IPlugin.js');
var baseControllers = require('@toruslabs/base-controllers');
require('@toruslabs/constants');
require('@toruslabs/http-helpers');
var index = require('../../base/wallet/index.js');
var utils = require('../utils.js');

class AuthConnector extends baseConnector.BaseConnector {
  constructor(params) {
    super(params);
    _defineProperty(this, "name", index.WALLET_CONNECTORS.AUTH);
    _defineProperty(this, "connectorNamespace", IChainInterface.CONNECTOR_NAMESPACES.MULTICHAIN);
    _defineProperty(this, "type", constants.CONNECTOR_CATEGORY.IN_APP);
    _defineProperty(this, "authInstance", null);
    _defineProperty(this, "status", constants.CONNECTOR_STATUS.NOT_READY);
    _defineProperty(this, "privateKeyProvider", null);
    _defineProperty(this, "authOptions", void 0);
    _defineProperty(this, "loginSettings", {
      authConnection: ""
    });
    _defineProperty(this, "wsSettings", void 0);
    _defineProperty(this, "wsEmbedInstance", null);
    _defineProperty(this, "authConnectionConfig", []);
    _defineProperty(this, "wsEmbedInstancePromise", null);
    this.authOptions = params.connectorSettings;
    this.loginSettings = params.loginSettings || {
      authConnection: ""
    };
    this.wsSettings = params.walletServicesSettings || {};
    this.authConnectionConfig = params.authConnectionConfig || [];
  }
  get provider() {
    if (this.status !== constants.CONNECTOR_STATUS.NOT_READY) {
      var _this$wsEmbedInstance;
      if ((_this$wsEmbedInstance = this.wsEmbedInstance) !== null && _this$wsEmbedInstance !== void 0 && _this$wsEmbedInstance.provider) {
        return this.wsEmbedInstance.provider;
      } else if (this.privateKeyProvider) return this.privateKeyProvider;
    }
    return null;
  }
  get wsEmbed() {
    return this.wsEmbedInstance;
  }
  set provider(_) {
    throw new Error("Not implemented");
  }
  async init(options) {
    const {
      chains
    } = this.coreOptions;
    const {
      chainId
    } = options;
    const chainConfig = chains.find(x => x.chainId === chainId);
    super.checkInitializationRequirements({
      chainConfig
    });
    if (!this.coreOptions.clientId) throw index$1.WalletInitializationError.invalidParams("clientId is required before auth's initialization");
    if (!this.authOptions) throw index$1.WalletInitializationError.invalidParams("authOptions is required before auth's initialization");
    if (this.authConnectionConfig.length === 0) throw index$1.WalletInitializationError.invalidParams("authConnectionConfig is required before auth's initialization");
    const isRedirectResult = this.authOptions.uxMode === auth.UX_MODE.REDIRECT;
    this.authOptions = _objectSpread(_objectSpread({}, this.authOptions), {}, {
      replaceUrlOnRedirect: isRedirectResult,
      useCoreKitKey: this.coreOptions.useSFAKey
    });
    this.authInstance = new auth.Auth(_objectSpread(_objectSpread({}, this.authOptions), {}, {
      clientId: this.coreOptions.clientId,
      network: this.coreOptions.web3AuthNetwork,
      sdkMode: auth.SDK_MODE.IFRAME,
      authConnectionConfig: this.authConnectionConfig.filter(x => !x.isDefault),
      mfaSettings: this.coreOptions.mfaSettings
    }));
    loglevel.log.debug("initializing auth connector init", this.authOptions);
    // making it async here to initialize provider.
    const authInstancePromise = this.authInstance.init();
    // Use this for xrpl, mpc cases
    if (this.coreOptions.privateKeyProvider) {
      this.privateKeyProvider = this.coreOptions.privateKeyProvider;
    } else {
      // initialize ws embed or private key provider based on chain namespace
      switch (chainConfig.chainNamespace) {
        case baseControllers.CHAIN_NAMESPACES.EIP155:
        case baseControllers.CHAIN_NAMESPACES.SOLANA:
          {
            const {
              default: WsEmbed
            } = await import('@web3auth/ws-embed');
            this.wsEmbedInstance = new WsEmbed({
              web3AuthClientId: this.coreOptions.clientId,
              web3AuthNetwork: this.coreOptions.web3AuthNetwork,
              modalZIndex: this.wsSettings.modalZIndex
            });
            const wsSupportedChains = chains.filter(x => x.chainNamespace === baseControllers.CHAIN_NAMESPACES.EIP155 || x.chainNamespace === baseControllers.CHAIN_NAMESPACES.SOLANA);
            this.wsEmbedInstancePromise = this.wsEmbedInstance.init(_objectSpread(_objectSpread({}, this.wsSettings), {}, {
              chains: wsSupportedChains,
              chainId,
              whiteLabel: _objectSpread(_objectSpread({}, this.authOptions.whiteLabel), this.wsSettings.whiteLabel)
            })).then(() => {
              this.wsEmbedInstancePromise = null;
              return;
            });
            break;
          }
        case baseControllers.CHAIN_NAMESPACES.XRPL:
          throw index$1.WalletLoginError.connectionError("Private key provider is required for XRPL");
        default:
          {
            const {
              CommonPrivateKeyProvider
            } = await Promise.resolve().then(function () { return require('../../providers/base-provider/index.js'); });
            this.privateKeyProvider = new CommonPrivateKeyProvider({
              config: {
                chain: chainConfig,
                chains: this.coreOptions.chains
              }
            });
          }
      }
    }
    // wait for auth instance to be ready.
    loglevel.log.debug("initializing auth connector");
    await authInstancePromise;
    this.status = constants.CONNECTOR_STATUS.READY;
    this.emit(constants.CONNECTOR_EVENTS.READY, index.WALLET_CONNECTORS.AUTH);
    try {
      const {
        sessionId
      } = this.authInstance || {};
      // connect only if it is redirect result or if connect (connector is cached/already connected in same session) is true
      if (sessionId && (options.autoConnect || isRedirectResult)) {
        this.rehydrated = true;
        await this.connect({
          chainId: options.chainId,
          getIdentityToken: options.getIdentityToken
        });
      } else if (!sessionId && options.autoConnect) {
        // if here, this means that the connector is cached but the sessionId is not available.
        // this can happen if the sessionId has expired.
        // we are throwing an error to reset the cached state.
        throw index$1.WalletLoginError.connectionError("Failed to rehydrate");
      }
    } catch (error) {
      this.emit(constants.CONNECTOR_EVENTS.REHYDRATION_ERROR, error);
    }
  }
  async connect(params) {
    super.checkConnectionRequirements();
    this.status = constants.CONNECTOR_STATUS.CONNECTING;
    this.emit(constants.CONNECTOR_EVENTS.CONNECTING, _objectSpread(_objectSpread({}, params), {}, {
      connector: index.WALLET_CONNECTORS.AUTH
    }));
    try {
      await this.connectWithProvider(params);
      return this.provider;
    } catch (error) {
      var _error$message;
      loglevel.log.error("Failed to connect with auth provider", error);
      // ready again to be connected
      this.status = constants.CONNECTOR_STATUS.READY;
      this.emit(constants.CONNECTOR_EVENTS.ERRORED, error);
      if (error !== null && error !== void 0 && (_error$message = error.message) !== null && _error$message !== void 0 && _error$message.includes("user closed popup")) {
        throw index$1.WalletLoginError.popupClosed();
      } else if (error instanceof index$1.Web3AuthError) {
        throw error;
      }
      throw index$1.WalletLoginError.connectionError("Failed to login with auth", error);
    }
  }
  async enableMFA(params = {
    authConnection: ""
  }) {
    if (!this.connected) throw index$1.WalletLoginError.notConnectedError("Not connected with wallet");
    if (!this.authInstance) throw index$1.WalletInitializationError.notReady("authInstance is not ready");
    try {
      const result = await this.authInstance.enableMFA(params);
      // In redirect mode, the result is not available immediately, so we emit the event when the result is available.
      if (result) this.emit(constants.CONNECTOR_EVENTS.MFA_ENABLED, result);
    } catch (error) {
      loglevel.log.error("Failed to enable MFA with auth provider", error);
      if (error instanceof index$1.Web3AuthError) {
        throw error;
      }
      throw index$1.WalletLoginError.connectionError("Failed to enable MFA with auth", error);
    }
  }
  async manageMFA(params = {
    authConnection: ""
  }) {
    if (!this.connected) throw index$1.WalletLoginError.notConnectedError("Not connected with wallet");
    if (!this.authInstance) throw index$1.WalletInitializationError.notReady("authInstance is not ready");
    try {
      await this.authInstance.manageMFA(params);
    } catch (error) {
      loglevel.log.error("Failed to manage MFA with auth provider", error);
      if (error instanceof index$1.Web3AuthError) {
        throw error;
      }
      throw index$1.WalletLoginError.connectionError("Failed to manage MFA with auth", error);
    }
  }
  async disconnect(options = {
    cleanup: false
  }) {
    if (!this.connected) throw index$1.WalletLoginError.notConnectedError("Not connected with wallet");
    if (!this.authInstance) throw index$1.WalletInitializationError.notReady("authInstance is not ready");
    this.status = constants.CONNECTOR_STATUS.DISCONNECTING;
    await this.authInstance.logout();
    if (this.wsEmbedInstance) await this.wsEmbedInstance.logout();
    if (options.cleanup) {
      this.status = constants.CONNECTOR_STATUS.NOT_READY;
      this.authInstance = null;
      if (this.wsEmbedInstance) this.wsEmbedInstance = null;
      if (this.privateKeyProvider) this.privateKeyProvider = null;
    } else {
      // ready to be connected again
      this.status = constants.CONNECTOR_STATUS.READY;
    }
    this.rehydrated = false;
    this.emit(constants.CONNECTOR_EVENTS.DISCONNECTED);
  }
  async getIdentityToken() {
    if (!this.canAuthorize) throw index$1.WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");
    this.status = constants.CONNECTOR_STATUS.AUTHORIZING;
    this.emit(constants.CONNECTOR_EVENTS.AUTHORIZING, {
      connector: index.WALLET_CONNECTORS.AUTH
    });
    const userInfo = await this.getUserInfo();
    this.status = constants.CONNECTOR_STATUS.AUTHORIZED;
    this.emit(constants.CONNECTOR_EVENTS.AUTHORIZED, {
      connector: index.WALLET_CONNECTORS.AUTH,
      identityTokenInfo: {
        idToken: userInfo.idToken
      }
    });
    return {
      idToken: userInfo.idToken
    };
  }
  async getUserInfo() {
    if (!this.canAuthorize) throw index$1.WalletLoginError.notConnectedError("Not connected with wallet");
    if (!this.authInstance) throw index$1.WalletInitializationError.notReady("authInstance is not ready");
    const userInfo = this.authInstance.getUserInfo();
    return userInfo;
  }
  // we don't support switching between different namespaces, except for solana and evm
  async switchChain(params, init = false) {
    super.checkSwitchChainRequirements(params, init);
    // get chains and namespaces
    const {
      chainId: newChainId
    } = params;
    const {
      chainId: currentChainId
    } = this.provider;
    const {
      chainNamespace: currentNamespace
    } = this.getChain(currentChainId);
    const {
      chainNamespace: newNamespace
    } = this.getChain(newChainId);
    // skip if chainId is the same
    if (currentChainId === newChainId) return;
    if (currentNamespace === baseControllers.CHAIN_NAMESPACES.SOLANA || currentNamespace === baseControllers.CHAIN_NAMESPACES.EIP155) {
      var _this$wsEmbedInstance2;
      // can only switch to solana or evm
      if (newNamespace !== baseControllers.CHAIN_NAMESPACES.SOLANA && newNamespace !== baseControllers.CHAIN_NAMESPACES.EIP155) throw index$1.WalletLoginError.connectionError("Cannot switch to other chain namespace");
      const fullChainId = `${newNamespace}:${Number(params.chainId)}`;
      await ((_this$wsEmbedInstance2 = this.wsEmbedInstance.provider) === null || _this$wsEmbedInstance2 === void 0 ? void 0 : _this$wsEmbedInstance2.request({
        method: "wallet_switchChain",
        params: {
          chainId: fullChainId
        }
      }));
    } else {
      var _this$privateKeyProvi;
      // cannot switch to other namespaces
      if (currentNamespace !== newNamespace) throw index$1.WalletLoginError.connectionError("Cannot switch to other chain namespace");
      await ((_this$privateKeyProvi = this.privateKeyProvider) === null || _this$privateKeyProvi === void 0 ? void 0 : _this$privateKeyProvi.switchChain(params));
    }
  }
  async cleanup() {
    if (!this.authInstance) throw index$1.WalletInitializationError.notReady("authInstance is not ready");
    await this.authInstance.cleanup();
    if (this.wsEmbedInstance) {
      this.wsEmbedInstance.clearInit();
    }
  }
  getOAuthProviderConfig(params) {
    const {
      authConnection,
      authConnectionId,
      groupedAuthConnectionId
    } = params;
    const providerConfig = this.authConnectionConfig.find(x => {
      if (groupedAuthConnectionId && authConnectionId) {
        return x.authConnection === authConnection && x.groupedAuthConnectionId === groupedAuthConnectionId && x.authConnectionId === authConnectionId;
      }
      if (authConnectionId) {
        return x.authConnection === authConnection && x.authConnectionId === authConnectionId;
      }
      // return the default auth connection, if not found, return undefined
      return x.authConnection === authConnection && x.isDefault;
    });
    return providerConfig;
  }
  getChain(chainId) {
    return this.coreOptions.chains.find(x => x.chainId === chainId);
  }
  _getFinalPrivKey() {
    if (!this.authInstance) return "";
    let finalPrivKey = this.authInstance.privKey;
    // coreKitKey is available only for custom connections by default
    if (this.coreOptions.useSFAKey) {
      // this is to check if the user has already logged in but coreKitKey is not available.
      // when useSFAKey is set to true.
      // This is to ensure that when there is no user session active, we don't throw an exception.
      if (this.authInstance.privKey && !this.authInstance.coreKitKey) {
        throw index$1.WalletLoginError.sfaKeyNotFound();
      }
      finalPrivKey = this.authInstance.coreKitKey;
    }
    return finalPrivKey;
  }
  async connectWithProvider(params) {
    var _this$authInstance, _params$extraLoginOpt;
    if (!this.authInstance) throw index$1.WalletInitializationError.notReady("authInstance is not ready");
    const chainConfig = this.coreOptions.chains.find(x => x.chainId === params.chainId);
    if (!chainConfig) throw index$1.WalletLoginError.connectionError("Chain config is not available");
    const {
      chainNamespace
    } = chainConfig;
    // if not logged in then login
    const keyAvailable = chainNamespace === baseControllers.CHAIN_NAMESPACES.EIP155 || chainNamespace === baseControllers.CHAIN_NAMESPACES.SOLANA ? (_this$authInstance = this.authInstance) === null || _this$authInstance === void 0 ? void 0 : _this$authInstance.sessionId : this._getFinalPrivKey();
    if (params.idToken) params.extraLoginOptions = _objectSpread(_objectSpread({}, params.extraLoginOptions), {}, {
      id_token: params.idToken
    });
    if (!keyAvailable || (_params$extraLoginOpt = params.extraLoginOptions) !== null && _params$extraLoginOpt !== void 0 && _params$extraLoginOpt.id_token) {
      var _params$extraLoginOpt2;
      // always use "other" curve to return token with all keys encoded so wallet service can switch between evm and solana namespace
      this.loginSettings.curve = auth.SUPPORTED_KEY_CURVES.OTHER;
      const loginParams = deepmerge(this.loginSettings, params);
      if ((_params$extraLoginOpt2 = params.extraLoginOptions) !== null && _params$extraLoginOpt2 !== void 0 && _params$extraLoginOpt2.id_token) {
        await this.connectWithJwtLogin(loginParams);
      } else {
        await this.connectWithSocialLogin(loginParams);
      }
    }
    // setup WS embed if chainNamespace is EIP155 or SOLANA
    if (chainNamespace === baseControllers.CHAIN_NAMESPACES.EIP155 || chainNamespace === baseControllers.CHAIN_NAMESPACES.SOLANA) {
      // wait for ws embed instance to be ready.
      if (this.wsEmbedInstancePromise) await this.wsEmbedInstancePromise;
      const {
        sessionId,
        sessionNamespace
      } = this.authInstance || {};
      if (sessionId) {
        const isLoggedIn = await this.wsEmbedInstance.loginWithSessionId({
          sessionId,
          sessionNamespace
        });
        if (isLoggedIn) {
          var _this$wsEmbedInstance3;
          // if getIdentityToken is true, then get the identity token
          // No need to get the identity token for auth connector as it is already handled
          let identityTokenInfo;
          this.status = constants.CONNECTOR_STATUS.CONNECTED;
          this.emit(constants.CONNECTOR_EVENTS.CONNECTED, {
            connector: index.WALLET_CONNECTORS.AUTH,
            reconnected: this.rehydrated,
            provider: this.provider,
            identityTokenInfo
          });
          if (params.getIdentityToken) {
            identityTokenInfo = await this.getIdentityToken();
          }
          // handle disconnect from ws embed
          (_this$wsEmbedInstance3 = this.wsEmbedInstance) === null || _this$wsEmbedInstance3 === void 0 || _this$wsEmbedInstance3.provider.on("accountsChanged", (accounts = []) => {
            if (accounts.length === 0 && connectorStatus.CONNECTED_STATUSES.includes(this.status)) this.disconnect({
              cleanup: false
            });
          });
        }
      }
    } else {
      // setup private key provider if chainNamespace is other
      const finalPrivKey = this._getFinalPrivKey();
      if (finalPrivKey) {
        await this.privateKeyProvider.setupProvider(finalPrivKey, params.chainId);
        this.status = constants.CONNECTOR_STATUS.CONNECTED;
        this.emit(constants.CONNECTOR_EVENTS.CONNECTED, {
          connector: index.WALLET_CONNECTORS.AUTH,
          reconnected: this.rehydrated,
          provider: this.provider
        });
      }
    }
  }
  async connectWithSocialLogin(params) {
    var _params$extraLoginOpt3, _params$extraLoginOpt4;
    const providerConfig = this.getOAuthProviderConfig({
      authConnection: params.authConnection,
      authConnectionId: params.authConnectionId,
      groupedAuthConnectionId: params.groupedAuthConnectionId
    });
    if (!(providerConfig !== null && providerConfig !== void 0 && providerConfig.authConnection)) throw index$1.WalletLoginError.connectionError("Invalid auth connection.");
    const jwtParams = _objectSpread(_objectSpread(_objectSpread({}, providerConfig.jwtParameters || {}), params.extraLoginOptions || {}), {}, {
      login_hint: params.loginHint || ((_params$extraLoginOpt3 = params.extraLoginOptions) === null || _params$extraLoginOpt3 === void 0 ? void 0 : _params$extraLoginOpt3.login_hint)
    });
    const nonce = auth.randomId();
    // post a message to the auth provider to indicate that login has been initiated.
    const loginParams = baseControllers.cloneDeep(params);
    loginParams.extraLoginOptions = _objectSpread(_objectSpread({}, loginParams.extraLoginOptions || {}), {}, {
      login_hint: params.loginHint || ((_params$extraLoginOpt4 = params.extraLoginOptions) === null || _params$extraLoginOpt4 === void 0 ? void 0 : _params$extraLoginOpt4.login_hint)
    });
    delete loginParams.chainId;
    const popupParams = {
      authConnection: params.authConnection,
      authConnectionId: providerConfig.authConnectionId,
      clientId: providerConfig.clientId || jwtParams.client_id,
      groupedAuthConnectionId: providerConfig.groupedAuthConnectionId,
      redirect_uri: `${this.authInstance.options.sdkUrl}/auth`,
      jwtParams,
      customState: {
        nonce,
        appState: params.appState,
        // use the default settings from the auth instance.
        dapp_redirect_url: this.authInstance.options.redirectUrl,
        uxMode: this.authInstance.options.uxMode,
        whiteLabel: JSON.stringify(this.authInstance.options.whiteLabel),
        loginParams: JSON.stringify(loginParams),
        version: auth.version.split(".")[0],
        web3AuthNetwork: this.coreOptions.web3AuthNetwork,
        web3AuthClientId: this.coreOptions.clientId,
        originData: this.authInstance.options.originData ? JSON.stringify(this.authInstance.options.originData) : undefined
      },
      web3AuthClientId: this.coreOptions.clientId,
      web3AuthNetwork: this.coreOptions.web3AuthNetwork
    };
    const loginHandler = auth.createHandler(popupParams);
    const verifierWindow = new auth.PopupHandler({
      url: loginHandler.finalURL,
      timeout: 0
    });
    if (this.authOptions.uxMode === auth.UX_MODE.REDIRECT) return verifierWindow.redirect(this.authOptions.replaceUrlOnRedirect);
    let isClosedWindow = false;
    return new Promise((resolve, reject) => {
      verifierWindow.open().catch(error => {
        loglevel.log.error("Error during login with social", error);
        this.authInstance.postLoginCancelledMessage(nonce);
        reject(error);
      });
      // this is to close the popup when the login is finished.
      const securePubSub$1 = new securePubSub.SecurePubSub({
        sameIpCheck: true
      });
      securePubSub$1.subscribe(`web3auth-login-${nonce}`).then(data => {
        const parsedData = JSON.parse(data || "{}");
        if ((parsedData === null || parsedData === void 0 ? void 0 : parsedData.message) === "login_finished") {
          if (parsedData !== null && parsedData !== void 0 && parsedData.error) {
            this.authInstance.postLoginCancelledMessage(nonce);
            reject(parsedData.error);
          }
          isClosedWindow = true;
          securePubSub$1.cleanup();
          verifierWindow.close();
        }
        return true;
      }).catch(error => {
        // swallow the error, dont need to throw.
        loglevel.log.error("Error during login with social", error);
      });
      verifierWindow.once("close", () => {
        if (!isClosedWindow) {
          securePubSub$1.cleanup();
          this.authInstance.postLoginCancelledMessage(nonce);
          reject(index$1.WalletLoginError.popupClosed());
        }
      });
      this.authInstance.postLoginInitiatedMessage(loginParams, nonce).then(resolve).catch(error => {
        if (error instanceof index$1.Web3AuthError) {
          throw error;
        }
        reject(index$1.WalletLoginError.connectionError(error instanceof Error ? error.message : error || "Failed to login with social"));
      });
    });
  }
  connectWithJwtLogin(params) {
    var _params$extraLoginOpt5, _params$extraLoginOpt7;
    const loginConfig = this.getOAuthProviderConfig({
      authConnection: params.authConnection,
      authConnectionId: params.authConnectionId,
      groupedAuthConnectionId: params.groupedAuthConnectionId
    });
    // throw error only when we cannot find the login config and authConnectionId is not provided in the params.
    // otherwise, we will use the params to create a new auth connection config in the auth instance.
    if (!(loginConfig !== null && loginConfig !== void 0 && loginConfig.authConnection) && !params.authConnectionId) throw index$1.WalletLoginError.connectionError("Invalid auth connection.");
    if (!(loginConfig !== null && loginConfig !== void 0 && loginConfig.authConnection)) {
      this.authInstance.options.authConnectionConfig.push({
        authConnection: params.authConnection,
        authConnectionId: params.authConnectionId,
        groupedAuthConnectionId: params.groupedAuthConnectionId
      });
    }
    const loginParams = baseControllers.cloneDeep(params);
    const finalExtraLoginOptions = _objectSpread(_objectSpread({}, (loginConfig === null || loginConfig === void 0 ? void 0 : loginConfig.jwtParameters) || {}), params.extraLoginOptions || {});
    let finalUserId;
    if (params.loginHint || (_params$extraLoginOpt5 = params.extraLoginOptions) !== null && _params$extraLoginOpt5 !== void 0 && _params$extraLoginOpt5.login_hint) {
      var _params$extraLoginOpt6;
      finalUserId = params.loginHint || ((_params$extraLoginOpt6 = params.extraLoginOptions) === null || _params$extraLoginOpt6 === void 0 ? void 0 : _params$extraLoginOpt6.login_hint);
    } else if ((_params$extraLoginOpt7 = params.extraLoginOptions) !== null && _params$extraLoginOpt7 !== void 0 && _params$extraLoginOpt7.id_token) {
      const {
        payload
      } = utils.parseToken(params.extraLoginOptions.id_token);
      finalUserId = auth.getUserId(payload, loginParams.authConnection, finalExtraLoginOptions.userIdField, finalExtraLoginOptions.isUserIdCaseSensitive);
    } else {
      throw index$1.WalletLoginError.connectionError("Invalid login hint or id_token");
    }
    // Adds the login_hint to the extraLoginOptions.
    loginParams.extraLoginOptions = _objectSpread(_objectSpread({}, finalExtraLoginOptions), {}, {
      login_hint: finalUserId
    });
    delete loginParams.chainId;
    return this.authInstance.postLoginInitiatedMessage(loginParams);
  }
}
const authConnector = params => {
  return ({
    projectConfig,
    coreOptions
  }) => {
    var _coreOptions$uiConfig, _coreOptions$walletSe, _coreOptions$walletSe2, _coreOptions$walletSe3;
    // Connector settings
    const connectorSettings = {};
    const {
      whitelist,
      sessionTime
    } = projectConfig;
    if (whitelist) connectorSettings.originData = whitelist.signed_urls;
    // If sessionTime is provided in the coreOptions, it takes precedence over the sessionTime in the projectConfig.
    if (coreOptions.sessionTime) {
      connectorSettings.sessionTime = coreOptions.sessionTime;
    } else if (sessionTime) {
      connectorSettings.sessionTime = sessionTime;
    }
    if ((_coreOptions$uiConfig = coreOptions.uiConfig) !== null && _coreOptions$uiConfig !== void 0 && _coreOptions$uiConfig.uxMode) connectorSettings.uxMode = coreOptions.uiConfig.uxMode;
    const uiConfig = coreOptions.uiConfig || {};
    connectorSettings.whiteLabel = uiConfig;
    const finalConnectorSettings = deepmerge.all([{
      uxMode: auth.UX_MODE.POPUP,
      buildEnv: coreOptions.authBuildEnv || auth.BUILD_ENV.PRODUCTION
    },
    // default settings
    connectorSettings, (params === null || params === void 0 ? void 0 : params.connectorSettings) || {}]);
    // WS settings
    const whiteLabel = deepmerge.all([uiConfig, ((_coreOptions$walletSe = coreOptions.walletServicesConfig) === null || _coreOptions$walletSe === void 0 ? void 0 : _coreOptions$walletSe.whiteLabel) || {}]);
    const finalWsSettings = _objectSpread(_objectSpread({}, coreOptions.walletServicesConfig), {}, {
      whiteLabel,
      accountAbstractionConfig: coreOptions.accountAbstractionConfig,
      enableLogging: coreOptions.enableLogging
    });
    // Core options
    const isKeyExportEnabled = (_coreOptions$walletSe2 = (_coreOptions$walletSe3 = coreOptions.walletServicesConfig) === null || _coreOptions$walletSe3 === void 0 ? void 0 : _coreOptions$walletSe3.enableKeyExport) !== null && _coreOptions$walletSe2 !== void 0 ? _coreOptions$walletSe2 : true;
    if (coreOptions.privateKeyProvider) coreOptions.privateKeyProvider.setKeyExportFlag(isKeyExportEnabled);
    return new AuthConnector({
      connectorSettings: finalConnectorSettings,
      walletServicesSettings: finalWsSettings,
      loginSettings: _objectSpread(_objectSpread({}, (params === null || params === void 0 ? void 0 : params.loginSettings) || {}), {}, {
        mfaLevel: coreOptions.mfaLevel
      }),
      coreOptions,
      authConnectionConfig: projectConfig.embeddedWalletAuth
    });
  };
};

exports.authConnector = authConnector;
