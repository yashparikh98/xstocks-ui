import { SafeEventEmitter } from "@web3auth/auth";
import { ConnectorNamespaceType, CustomChainConfig } from "../chain/IChainInterface";
import { WALLET_CONNECTOR_TYPE } from "../wallet";
import type { BaseConnectorLoginParams, BaseConnectorSettings, CONNECTOR_CATEGORY_TYPE, CONNECTOR_STATUS_TYPE, ConnectorEvents, ConnectorInitOptions, IConnector, IdentityTokenInfo, IProvider, UserInfo } from "./interfaces";
export declare abstract class BaseConnector<T> extends SafeEventEmitter<ConnectorEvents> implements IConnector<T> {
    connectorData?: unknown;
    isInjected?: boolean;
    icon?: string;
    coreOptions: BaseConnectorSettings["coreOptions"];
    protected rehydrated: boolean;
    abstract connectorNamespace: ConnectorNamespaceType;
    abstract type: CONNECTOR_CATEGORY_TYPE;
    abstract name: WALLET_CONNECTOR_TYPE | string;
    abstract status: CONNECTOR_STATUS_TYPE;
    constructor(options: BaseConnectorSettings);
    get connected(): boolean;
    get canAuthorize(): boolean;
    abstract get provider(): IProvider | null;
    checkConnectionRequirements(): void;
    checkInitializationRequirements({ chainConfig }: {
        chainConfig?: CustomChainConfig;
    }): void;
    checkDisconnectionRequirements(): void;
    checkSwitchChainRequirements(params: {
        chainId: string;
    }, init?: boolean): void;
    updateConnectorData(data: unknown): void;
    abstract init(options?: ConnectorInitOptions): Promise<void>;
    abstract connect(params: T & BaseConnectorLoginParams): Promise<IProvider | null>;
    abstract disconnect(): Promise<void>;
    abstract getUserInfo(): Promise<Partial<UserInfo>>;
    abstract enableMFA(params?: T): Promise<void>;
    abstract manageMFA(params?: T): Promise<void>;
    abstract getIdentityToken(): Promise<IdentityTokenInfo>;
    abstract switchChain(params: {
        chainId: string;
    }): Promise<void>;
}
