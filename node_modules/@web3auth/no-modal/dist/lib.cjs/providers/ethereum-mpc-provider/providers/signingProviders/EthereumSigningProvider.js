'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var util = require('@ethereumjs/util');
var auth = require('@web3auth/auth');
require('@segment/analytics-next');
require('../../../../base/loglevel.js');
var baseControllers = require('@toruslabs/base-controllers');
var index = require('../../../../base/errors/index.js');
require('../../../../base/wallet/index.js');
require('../../../../base/connector/connectorStatus.js');
require('../../../../base/connector/constants.js');
require('jwt-decode');
require('../../../../base/plugin/errors.js');
require('../../../../base/plugin/IPlugin.js');
require('@toruslabs/constants');
require('@toruslabs/http-helpers');
var baseProvider = require('../../../base-provider/baseProvider.js');
require('../../../base-provider/CommonJRPCProvider.js');
require('../../../base-provider/commonPrivateKeyProvider.js');
require('../../../base-provider/utils.js');
var formatter = require('../../../ethereum-provider/providers/privateKeyProviders/TransactionFormatter/formatter.js');
require('../../../ethereum-provider/providers/privateKeyProviders/TransactionFormatter/interfaces.js');
require('../../../ethereum-provider/providers/converter.js');
var ethRpcMiddlewares = require('../../../ethereum-provider/rpc/ethRpcMiddlewares.js');
var jrpcClient = require('../../../ethereum-provider/rpc/jrpcClient.js');
var ethRpcMiddlewares$1 = require('../../rpc/ethRpcMiddlewares.js');
var signingUtils = require('./signingUtils.js');

var _EthereumSigningProvider;
class EthereumSigningProvider extends baseProvider.BaseProvider {
  constructor({
    config,
    state
  }) {
    super({
      config: {
        chain: _objectSpread(_objectSpread({}, config.chain), {}, {
          chainNamespace: baseControllers.CHAIN_NAMESPACES.EIP155 // TODO: is this needed ?
        }),
        chains: config.chains
      },
      state
    });
    _defineProperty(this, "PROVIDER_CHAIN_NAMESPACE", baseControllers.CHAIN_NAMESPACES.EIP155);
  }
  async enable() {
    if (!this.state.signMethods) throw auth.providerErrors.custom({
      message: "signMethods are not found in state, plz pass it in constructor state param",
      code: 4902
    });
    await this.setupProvider(this.state.signMethods, this.chainId);
    return this._providerEngineProxy.request({
      method: "eth_accounts"
    });
  }
  async setupProvider(params, chainId) {
    const {
      sign,
      getPublic
    } = params;
    const chain = this.getChain(chainId);
    const {
      chainNamespace
    } = chain;
    if (chainNamespace !== this.PROVIDER_CHAIN_NAMESPACE) throw index.WalletInitializationError.incompatibleChainNameSpace("Invalid chain namespace");
    const txFormatter = new formatter.TransactionFormatter({
      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)
    });
    const providerHandlers = signingUtils.getProviderHandlers({
      txFormatter,
      sign,
      getPublic,
      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)
    });
    const ethMiddleware = ethRpcMiddlewares.createEthMiddleware(providerHandlers);
    const chainSwitchMiddleware = this.getChainSwitchMiddleware();
    const engine = new auth.JRPCEngine();
    // Not a partial anymore because of checks in ctor
    const {
      networkMiddleware
    } = jrpcClient.createEthJsonRpcClient(chain);
    engine.push(ethMiddleware);
    engine.push(chainSwitchMiddleware);
    engine.push(this.getAccountMiddleware());
    engine.push(networkMiddleware);
    const provider = auth.providerFromEngine(engine);
    this.updateProviderEngineProxy(provider);
    await txFormatter.init();
    await this.lookupNetwork(params, chainId);
    this.state.signMethods = {
      sign,
      getPublic
    };
    this.emit("chainChanged", chainId);
    this.emit("connect", {
      chainId
    });
    this.update({
      chainId
    });
  }
  async updateAccount(params) {
    if (!this._providerEngineProxy) throw auth.providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const currentSignMethods = this.state.signMethods;
    if (!currentSignMethods) {
      throw auth.providerErrors.custom({
        message: "signing methods are unavailable ",
        code: 4092
      });
    }
    const currentPubKey = (await currentSignMethods.getPublic()).toString("hex");
    const updatePubKey = (await params.signMethods.getPublic()).toString("hex");
    if (currentPubKey !== updatePubKey) {
      await this.setupProvider(params.signMethods, this.chainId);
      const accounts = await this._providerEngineProxy.request({
        method: "eth_accounts"
      });
      this.emit("accountsChanged", accounts);
    }
  }
  async switchChain(params) {
    if (!this._providerEngineProxy) throw auth.providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    if (!this.state.signMethods) {
      throw auth.providerErrors.custom({
        message: "sign methods are undefined",
        code: 4902
      });
    }
    if (params.chainId === this.chainId) {
      return;
    }
    this.update({
      chainId: "loading"
    });
    await this.setupProvider(this.state.signMethods, params.chainId);
  }
  async addChain(chainConfig) {
    if (!this._providerEngineProxy) throw auth.providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    if (!this.state.signMethods) {
      throw auth.providerErrors.custom({
        message: "sign methods are undefined",
        code: 4902
      });
    }
    // find existing chain config with the same chainId
    const existingChain = this.config.chains.find(chain => chain.chainId === chainConfig.chainId);
    if (existingChain) {
      return;
    }
    // add the chain config to the config
    this.config.chains.push({
      chainId: chainConfig.chainId,
      displayName: chainConfig.chainName,
      rpcTarget: chainConfig.rpcUrls[0],
      chainNamespace: baseControllers.CHAIN_NAMESPACES.EIP155,
      blockExplorerUrl: chainConfig.blockExplorerUrls[0],
      logo: chainConfig.iconUrls[0],
      tickerName: chainConfig.nativeCurrency.name,
      ticker: chainConfig.nativeCurrency.symbol,
      decimals: chainConfig.nativeCurrency.decimals
    });
  }
  async lookupNetwork(_, chainId) {
    if (!this._providerEngineProxy) throw auth.providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    if (!chainId) throw auth.rpcErrors.invalidParams("chainId is required while lookupNetwork");
    const network = await this._providerEngineProxy.request({
      method: "net_version",
      params: []
    });
    const finalNetwork = util.isHexString(network) ? parseInt(network, 16) : parseInt(network, 10);
    if (parseInt(chainId, 16) !== finalNetwork) throw auth.providerErrors.chainDisconnected(`Invalid network, net_version is: ${network}`);
    return network;
  }
  getChainSwitchMiddleware() {
    const chainSwitchHandlers = {
      switchChain: async params => {
        const {
          chainId
        } = params;
        await this.switchChain({
          chainId
        });
      },
      addChain: async params => {
        await this.addChain(params);
      }
    };
    const chainSwitchMiddleware = ethRpcMiddlewares.createEthChainSwitchMiddleware(chainSwitchHandlers);
    return chainSwitchMiddleware;
  }
  getAccountMiddleware() {
    const accountHandlers = {
      };
    return ethRpcMiddlewares$1.createEthAccountMiddleware(accountHandlers);
  }
}
_EthereumSigningProvider = EthereumSigningProvider;
_defineProperty(EthereumSigningProvider, "getProviderInstance", async params => {
  const providerFactory = new _EthereumSigningProvider({
    config: {
      chain: params.chain,
      chains: params.chains
    }
  });
  await providerFactory.setupProvider(params.signMethods, params.chain.chainId);
  return providerFactory;
});

exports.EthereumSigningProvider = EthereumSigningProvider;
