'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var util = require('@ethereumjs/util');
var baseControllers = require('@toruslabs/base-controllers');
var auth = require('@web3auth/auth');
var ethers = require('ethers');
var viem = require('viem');
require('@babel/runtime/helpers/defineProperty');
require('@segment/analytics-next');
var loglevel = require('../../../../base/loglevel.js');
require('../../../../base/errors/index.js');
require('../../../../base/wallet/index.js');
require('../../../../base/connector/connectorStatus.js');
require('../../../../base/connector/constants.js');
require('jwt-decode');
require('../../../../base/plugin/errors.js');
require('../../../../base/plugin/IPlugin.js');
require('@toruslabs/constants');
require('@toruslabs/http-helpers');
require('bignumber.js');
require('../../../ethereum-provider/providers/converter.js');
require('bn.js');
var utils = require('../../../ethereum-provider/providers/privateKeyProviders/TransactionFormatter/utils.js');
var interfaces = require('../../../ethereum-provider/providers/privateKeyProviders/TransactionFormatter/interfaces.js');

async function signTx(txParams, sign, txFormatter) {
  const {
    Transaction
  } = await import('ethers');
  const finalTxParams = await txFormatter.formatTransaction(txParams);
  const ethTx = Transaction.from(_objectSpread(_objectSpread({}, finalTxParams), {}, {
    from: undefined // from is already calculated inside Transaction.from and is not allowed to be passed in
  }));
  const msgHash = util.stripHexPrefix(ethTx.unsignedHash);
  const vrs = await sign(Buffer.from(msgHash, "hex"));
  let {
    v
  } = vrs;
  const {
    r,
    s
  } = vrs;
  // mpc-core-kit workaround (revert back to 0/1)
  if (v > 1) {
    v = v - 27;
  }
  // addSignature will handle the v value
  const tx = ethTx;
  tx.signature = ethers.Signature.from({
    v,
    r: `0x${r.toString("hex")}`,
    s: `0x${s.toString("hex")}`
  });
  return tx.serialized;
}
async function signMessage(sign, data) {
  const message = util.stripHexPrefix(data);
  const msgSig = await sign(Buffer.from(message, "hex"));
  let modifiedV = msgSig.v;
  if (modifiedV <= 1) {
    modifiedV = modifiedV + 27;
  }
  const rawMsgSig = baseControllers.concatSig(Buffer.from(util.intToBytes(modifiedV)), msgSig.r, msgSig.s);
  return rawMsgSig;
}
async function personalSign(sign, data) {
  if (data === null || data === undefined) {
    throw new Error("Missing data parameter");
  }
  // we need to check if the data is hex or not
  // For historical reasons, you must submit the message to sign in hex-encoded UTF-8.
  // https://docs.metamask.io/wallet/how-to/sign-data/#use-personal_sign
  const message = util.isHexString(data) ? Buffer.from(util.stripHexPrefix(data), "hex") : Buffer.from(data);
  const msgHash = ethers.hashMessage(message);
  const prefix = Buffer.from(`\u0019Ethereum Signed Message:\n${message.length}`, "utf-8");
  const sig = await sign(Buffer.from(msgHash.slice(2), "hex"), Buffer.concat([prefix, message]));
  let modifiedV = sig.v;
  if (modifiedV <= 1) {
    modifiedV = modifiedV + 27;
  }
  const serialized = baseControllers.concatSig(Buffer.from(util.toBytes(modifiedV)), sig.r, sig.s);
  return serialized;
}
function validateVersion(version, allowedVersions) {
  if (!Object.keys(interfaces.SignTypedDataVersion).includes(version)) {
    throw new Error(`Invalid version: '${version}'`);
  }
}
async function signTypedData(sign, data, version) {
  validateVersion(version); // Note: this is intentional;
  if (data === null || data === undefined) {
    throw new Error("Missing data parameter");
  }
  const message = typeof data === "string" ? JSON.parse(data) : data;
  viem.validateTypedData(message);
  const {
    v,
    r,
    s
  } = await sign(Buffer.from(viem.hexToBytes(viem.hashTypedData(message))));
  let modifiedV = v;
  if (modifiedV <= 1) {
    modifiedV = modifiedV + 27;
  }
  return baseControllers.concatSig(Buffer.from(util.toBytes(modifiedV)), r, s);
}
function getProviderHandlers({
  txFormatter,
  sign,
  getPublic,
  getProviderEngineProxy
}) {
  return {
    getAccounts: async _ => {
      const pubKey = await getPublic();
      return [`0x${Buffer.from(util.publicToAddress(pubKey)).toString("hex")}`];
    },
    getPrivateKey: async _ => {
      throw auth.providerErrors.custom({
        message: "MPC Provider cannot return private key",
        code: 4902
      });
    },
    getPublicKey: async _ => {
      const pubKey = await getPublic();
      return `0x${pubKey.toString("hex")}`;
    },
    processTransaction: async (txParams, _) => {
      const providerEngineProxy = getProviderEngineProxy();
      if (!providerEngineProxy) throw auth.providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      const serializedTxn = await signTx(txParams, sign, txFormatter);
      const txHash = await providerEngineProxy.request({
        method: "eth_sendRawTransaction",
        params: [serializedTxn]
      });
      return txHash;
    },
    processSignTransaction: async (txParams, _) => {
      const providerEngineProxy = getProviderEngineProxy();
      if (!providerEngineProxy) throw auth.providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      const serializedTxn = await signTx(txParams, sign, txFormatter);
      return serializedTxn;
    },
    processEthSignMessage: async (msgParams, _) => {
      const rawMessageSig = signMessage(sign, msgParams.data);
      return rawMessageSig;
    },
    processPersonalMessage: async (msgParams, _) => {
      const sig = personalSign(sign, msgParams.data);
      return sig;
    },
    processTypedMessageV4: async (msgParams, _) => {
      loglevel.log.debug("processTypedMessageV4", msgParams);
      const providerEngineProxy = getProviderEngineProxy();
      if (!providerEngineProxy) throw auth.providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      const chainId = await providerEngineProxy.request({
        method: "eth_chainId"
      });
      await utils.validateTypedSignMessageDataV4(msgParams, chainId);
      const data = typeof msgParams.data === "string" ? JSON.parse(msgParams.data) : msgParams.data;
      const sig = signTypedData(sign, data, interfaces.SignTypedDataVersion.V4);
      return sig;
    }
  };
}

exports.getProviderHandlers = getProviderHandlers;
