/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  BaseProvider: () => (/* reexport */ BaseProvider),
  CommonJRPCProvider: () => (/* reexport */ CommonJRPCProvider),
  CommonPrivateKeyProvider: () => (/* reexport */ CommonPrivateKeyProvider),
  createRandomId: () => (/* reexport */ createRandomId),
  getED25519Key: () => (/* reexport */ auth_namespaceObject.getED25519Key)
});

;// external "@babel/runtime/helpers/objectSpread2"
const objectSpread2_namespaceObject = require("@babel/runtime/helpers/objectSpread2");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2_namespaceObject);
;// external "@babel/runtime/helpers/defineProperty"
const defineProperty_namespaceObject = require("@babel/runtime/helpers/defineProperty");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_namespaceObject);
;// external "@toruslabs/base-controllers"
const base_controllers_namespaceObject = require("@toruslabs/base-controllers");
;// external "@web3auth/auth"
const auth_namespaceObject = require("@web3auth/auth");
;// external "@web3auth/base"
const base_namespaceObject = require("@web3auth/base");
;// ./src/baseProvider.ts





class BaseProvider extends base_controllers_namespaceObject.BaseController {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    // should be Assigned in setupProvider
    defineProperty_default()(this, "_providerEngineProxy", null);
    // set to true when the keyExportEnabled flag is set by code.
    // This is to prevent the flag from being overridden by the dashboard config.
    defineProperty_default()(this, "keyExportFlagSetByCode", false);
    if (!config.chainConfig) throw base_namespaceObject.WalletInitializationError.invalidProviderConfigError("Please provide chainConfig");
    if (!config.chainConfig.chainId) throw base_namespaceObject.WalletInitializationError.invalidProviderConfigError("Please provide chainId inside chainConfig");
    if (!config.chainConfig.rpcTarget) throw base_namespaceObject.WalletInitializationError.invalidProviderConfigError("Please provide rpcTarget inside chainConfig");
    if (typeof config.keyExportEnabled === "boolean") this.keyExportFlagSetByCode = true;
    this.defaultState = {
      chainId: "loading"
    };
    this.defaultConfig = {
      chainConfig: config.chainConfig,
      networks: {
        [config.chainConfig.chainId]: config.chainConfig
      },
      keyExportEnabled: typeof config.keyExportEnabled === "boolean" ? config.keyExportEnabled : true
    };
    super.initialize();
  }
  get currentChainConfig() {
    return this.config.chainConfig;
  }
  get provider() {
    return this._providerEngineProxy;
  }
  get chainId() {
    return this.state.chainId;
  }
  set provider(_) {
    throw new Error("Method not implemented.");
  }
  async request(args) {
    var _this$provider;
    if (!args || typeof args !== "object" || Array.isArray(args)) {
      throw auth_namespaceObject.rpcErrors.invalidRequest({
        message: base_namespaceObject.WalletProviderError.invalidRequestArgs().message,
        data: objectSpread2_default()(objectSpread2_default()({}, args || {}), {}, {
          cause: base_namespaceObject.WalletProviderError.invalidRequestArgs().message
        })
      });
    }
    const {
      method,
      params
    } = args;
    if (typeof method !== "string" || method.length === 0) {
      throw auth_namespaceObject.rpcErrors.invalidRequest({
        message: base_namespaceObject.WalletProviderError.invalidRequestMethod().message,
        data: objectSpread2_default()(objectSpread2_default()({}, args || {}), {}, {
          cause: base_namespaceObject.WalletProviderError.invalidRequestMethod().message
        })
      });
    }
    if (params !== undefined && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
      throw auth_namespaceObject.rpcErrors.invalidRequest({
        message: base_namespaceObject.WalletProviderError.invalidRequestParams().message,
        data: objectSpread2_default()(objectSpread2_default()({}, args || {}), {}, {
          cause: base_namespaceObject.WalletProviderError.invalidRequestParams().message
        })
      });
    }
    return (_this$provider = this.provider) === null || _this$provider === void 0 ? void 0 : _this$provider.request(args);
  }
  sendAsync(req, callback) {
    if (callback) return this.send(req, callback);
    return this.request(req);
  }
  send(req, callback) {
    this.request(req).then(res => callback(null, {
      result: res
    })).catch(err => callback(err, null));
  }
  addChain(chainConfig) {
    if (!chainConfig.chainId) throw auth_namespaceObject.rpcErrors.invalidParams("chainId is required");
    if (!chainConfig.rpcTarget) throw auth_namespaceObject.rpcErrors.invalidParams("chainId is required");
    this.configure({
      networks: objectSpread2_default()(objectSpread2_default()({}, this.config.networks), {}, {
        [chainConfig.chainId]: chainConfig
      })
    });
  }
  getChainConfig(chainId) {
    var _this$config$networks;
    const chainConfig = (_this$config$networks = this.config.networks) === null || _this$config$networks === void 0 ? void 0 : _this$config$networks[chainId];
    if (!chainConfig) throw auth_namespaceObject.rpcErrors.invalidRequest(`Chain ${chainId} is not supported, please add chainConfig for it`);
    return chainConfig;
  }
  updateProviderEngineProxy(provider) {
    if (this._providerEngineProxy) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      this._providerEngineProxy.setTarget(provider);
    } else {
      this._providerEngineProxy = (0,base_controllers_namespaceObject.createEventEmitterProxy)(provider);
    }
  }
  setKeyExportFlag(flag) {
    if (!this.keyExportFlagSetByCode) {
      this.configure({
        keyExportEnabled: flag
      });
    }
  }
  getProviderEngineProxy() {
    return this._providerEngineProxy;
  }
}
;// ./src/jrpcClient.ts


function createChainIdMiddleware(chainId) {
  return (req, res, next, end) => {
    if (req.method === "chainId") {
      res.result = chainId;
      return end();
    }
    return next();
  };
}
function createProviderConfigMiddleware(providerConfig) {
  return (req, res, next, end) => {
    if (req.method === "provider_config") {
      res.result = providerConfig;
      return end();
    }
    return next();
  };
}
function createJsonRpcClient(providerConfig) {
  const {
    chainId,
    rpcTarget
  } = providerConfig;
  const fetchMiddleware = (0,base_controllers_namespaceObject.createFetchMiddleware)({
    rpcTarget
  });
  const networkMiddleware = (0,auth_namespaceObject.mergeMiddleware)([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);
  return {
    networkMiddleware,
    fetchMiddleware
  };
}
;// ./src/CommonJRPCProvider.ts

var _CommonJRPCProvider;




class CommonJRPCProvider extends BaseProvider {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
  }
  async setupProvider() {
    const {
      networkMiddleware
    } = createJsonRpcClient(this.config.chainConfig);
    const engine = new auth_namespaceObject.JRPCEngine();
    engine.push(networkMiddleware);
    const provider = (0,auth_namespaceObject.providerFromEngine)(engine);
    this.updateProviderEngineProxy(provider);
    const newChainId = this.config.chainConfig.chainId;
    if (this.state.chainId !== newChainId) {
      this.emit("chainChanged", newChainId);
      this.emit("connect", {
        chainId: newChainId
      });
    }
    this.update({
      chainId: this.config.chainConfig.chainId
    });
  }
  async switchChain(params) {
    if (!this._providerEngineProxy) throw auth_namespaceObject.providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const chainConfig = this.getChainConfig(params.chainId);
    this.update({
      chainId: "loading"
    });
    this.configure({
      chainConfig
    });
    await this.setupProvider();
  }
  updateProviderEngineProxy(provider) {
    if (this._providerEngineProxy) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      this._providerEngineProxy.setTarget(provider);
    } else {
      this._providerEngineProxy = (0,base_controllers_namespaceObject.createEventEmitterProxy)(provider);
    }
  }
  getProviderEngineProxy() {
    return this._providerEngineProxy;
  }
  lookupNetwork() {
    throw new Error("Method not implemented.");
  }
}
_CommonJRPCProvider = CommonJRPCProvider;
defineProperty_default()(CommonJRPCProvider, "getProviderInstance", async params => {
  const providerFactory = new _CommonJRPCProvider({
    config: {
      chainConfig: params.chainConfig
    }
  });
  await providerFactory.setupProvider();
  return providerFactory;
});
;// ./src/commonPrivateKeyProvider.ts

var _CommonPrivateKeyProvider;



class CommonPrivateKeyProvider extends BaseProvider {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    // should be Assigned in setupProvider
    defineProperty_default()(this, "_providerEngineProxy", null);
  }
  get provider() {
    return this._providerEngineProxy;
  }
  set provider(_) {
    throw new Error("Method not implemented.");
  }
  addChain(_) {
    throw new Error("Method not implemented.");
  }
  async setupProvider(privKey) {
    const privKeyMiddleware = this.getPrivKeyMiddleware(privKey);
    const engine = new auth_namespaceObject.JRPCEngine();
    engine.push(privKeyMiddleware);
    const provider = (0,auth_namespaceObject.providerFromEngine)(engine);
    this.updateProviderEngineProxy(provider);
  }
  updateProviderEngineProxy(provider) {
    if (this._providerEngineProxy) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      this._providerEngineProxy.setTarget(provider);
    } else {
      this._providerEngineProxy = (0,base_controllers_namespaceObject.createEventEmitterProxy)(provider);
    }
  }
  async switchChain(_) {
    return Promise.resolve();
  }
  getProviderEngineProxy() {
    return this._providerEngineProxy;
  }
  async lookupNetwork() {
    return Promise.resolve("");
  }
  getPrivKeyMiddleware(privKey) {
    const middleware = {
      getPrivatekey: async () => {
        if (!this.config.keyExportEnabled) throw new Error("Exporting private key is disabled. Please enable it in the provider config");
        return privKey;
      }
    };
    return this.createPrivKeyMiddleware(middleware);
  }
  createPrivKeyMiddleware({
    getPrivatekey
  }) {
    async function getPrivatekeyHandler(_, res) {
      try {
        res.result = await getPrivatekey();
      } catch (error) {
        res.error = error instanceof Error ? error.message : error;
      }
    }
    return (0,auth_namespaceObject.createScaffoldMiddleware)({
      private_key: (0,auth_namespaceObject.createAsyncMiddleware)(getPrivatekeyHandler)
    });
  }
}
_CommonPrivateKeyProvider = CommonPrivateKeyProvider;
defineProperty_default()(CommonPrivateKeyProvider, "getProviderInstance", async params => {
  const providerFactory = new _CommonPrivateKeyProvider({
    config: {
      chainConfig: params.chainConfig
    }
  });
  await providerFactory.setupProvider(params.privKey);
  return providerFactory;
});
;// external "json-rpc-random-id"
const external_json_rpc_random_id_namespaceObject = require("json-rpc-random-id");
var external_json_rpc_random_id_default = /*#__PURE__*/__webpack_require__.n(external_json_rpc_random_id_namespaceObject);
;// ./src/utils.ts

const createRandomId = external_json_rpc_random_id_default()();

;// ./src/index.ts





module.exports = __webpack_exports__;
/******/ })()
;