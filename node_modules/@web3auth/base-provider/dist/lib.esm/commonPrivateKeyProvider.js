import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { createEventEmitterProxy } from '@toruslabs/base-controllers';
import { JRPCEngine, providerFromEngine, createScaffoldMiddleware, createAsyncMiddleware } from '@web3auth/auth';
import { BaseProvider } from './baseProvider.js';

var _CommonPrivateKeyProvider;
class CommonPrivateKeyProvider extends BaseProvider {
  constructor({
    config,
    state
  }) {
    super({
      config,
      state
    });
    // should be Assigned in setupProvider
    _defineProperty(this, "_providerEngineProxy", null);
  }
  get provider() {
    return this._providerEngineProxy;
  }
  set provider(_) {
    throw new Error("Method not implemented.");
  }
  addChain(_) {
    throw new Error("Method not implemented.");
  }
  async setupProvider(privKey) {
    const privKeyMiddleware = this.getPrivKeyMiddleware(privKey);
    const engine = new JRPCEngine();
    engine.push(privKeyMiddleware);
    const provider = providerFromEngine(engine);
    this.updateProviderEngineProxy(provider);
  }
  updateProviderEngineProxy(provider) {
    if (this._providerEngineProxy) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      this._providerEngineProxy.setTarget(provider);
    } else {
      this._providerEngineProxy = createEventEmitterProxy(provider);
    }
  }
  async switchChain(_) {
    return Promise.resolve();
  }
  getProviderEngineProxy() {
    return this._providerEngineProxy;
  }
  async lookupNetwork() {
    return Promise.resolve("");
  }
  getPrivKeyMiddleware(privKey) {
    const middleware = {
      getPrivatekey: async () => {
        if (!this.config.keyExportEnabled) throw new Error("Exporting private key is disabled. Please enable it in the provider config");
        return privKey;
      }
    };
    return this.createPrivKeyMiddleware(middleware);
  }
  createPrivKeyMiddleware({
    getPrivatekey
  }) {
    async function getPrivatekeyHandler(_, res) {
      try {
        res.result = await getPrivatekey();
      } catch (error) {
        res.error = error instanceof Error ? error.message : error;
      }
    }
    return createScaffoldMiddleware({
      private_key: createAsyncMiddleware(getPrivatekeyHandler)
    });
  }
}
_CommonPrivateKeyProvider = CommonPrivateKeyProvider;
_defineProperty(CommonPrivateKeyProvider, "getProviderInstance", async params => {
  const providerFactory = new _CommonPrivateKeyProvider({
    config: {
      chainConfig: params.chainConfig
    }
  });
  await providerFactory.setupProvider(params.privKey);
  return providerFactory;
});

export { CommonPrivateKeyProvider };
