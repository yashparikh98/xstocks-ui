import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { CustomError } from 'ts-custom-error';

// @flow

function serializeError(args) {
  // Find first Error or create an "unknown" Error to keep stack trace.
  const index = args.findIndex(arg => arg instanceof Error);
  const msgIndex = args.findIndex(arg => typeof arg === "string");
  const apiErrorIdx = args.findIndex(arg => arg && typeof arg === "object" && "status" in arg && "type" in arg);
  let err;
  if (apiErrorIdx !== -1) {
    const apiError = args[apiErrorIdx];
    err = new Error(`${apiError.status} ${apiError.type.toString()} ${apiError.statusText}`);
  } else if (index !== -1) {
    err = args.splice(index, 1)[0];
  } else if (msgIndex !== -1) {
    err = new Error(args.splice(msgIndex, 1)[0]);
  } else {
    err = new Error("Unknown error");
  }
  return [err, args];
}
class Web3AuthError extends CustomError {
  constructor(code, message, cause) {
    // takes care of stack and proto
    super(message);
    _defineProperty(this, "code", void 0);
    _defineProperty(this, "message", void 0);
    _defineProperty(this, "cause", void 0);
    this.code = code;
    this.message = message || "";
    this.cause = cause;
    // Set name explicitly as minification can mangle class names
    Object.defineProperty(this, "name", {
      value: "Web3AuthError"
    });
  }
  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message,
      cause: serializeError([this.cause])
    };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
}
class WalletInitializationError extends Web3AuthError {
  constructor(code, message, cause) {
    // takes care of stack and proto
    super(code, message, cause);

    // Set name explicitly as minification can mangle class names
    Object.defineProperty(this, "name", {
      value: "WalletInitializationError"
    });
  }
  static fromCode(code, extraMessage = "", cause) {
    return new WalletInitializationError(code, `${WalletInitializationError.messages[code]}, ${extraMessage}`, cause);
  }

  // Custom methods
  static notFound(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5001, extraMessage, cause);
  }
  static notInstalled(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5002, extraMessage, cause);
  }
  static notReady(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5003, extraMessage, cause);
  }
  static windowBlocked(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5004, extraMessage, cause);
  }
  static windowClosed(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5005, extraMessage, cause);
  }
  static incompatibleChainNameSpace(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5006, extraMessage, cause);
  }
  static duplicateAdapterError(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5007, extraMessage, cause);
  }
  static invalidProviderConfigError(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5008, extraMessage, cause);
  }
  static providerNotReadyError(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5009, extraMessage, cause);
  }
  static rpcConnectionError(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5010, extraMessage, cause);
  }
  static invalidParams(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5011, extraMessage, cause);
  }
  static invalidNetwork(extraMessage = "", cause) {
    return WalletInitializationError.fromCode(5013, extraMessage, cause);
  }
}

/**
 * wallet login errors
 */
_defineProperty(WalletInitializationError, "messages", {
  5000: "Custom",
  5001: "Wallet is not found",
  5002: "Wallet is not installed",
  5003: "Wallet is not ready yet",
  5004: "Wallet window is blocked",
  5005: "Wallet window has been closed by the user",
  5006: "Incompatible chain namespace provided",
  5007: "Adapter has already been included",
  5008: "Invalid provider Config",
  5009: "Provider is not ready yet",
  5010: "Failed to connect with rpc url",
  5011: "Invalid params passed in",
  5013: "Invalid network provided"
});
class WalletLoginError extends Web3AuthError {
  constructor(code, message, cause) {
    // takes care of stack and proto
    super(code, message, cause);

    // Set name explicitly as minification can mangle class names
    Object.defineProperty(this, "name", {
      value: "WalletLoginError"
    });
  }
  static fromCode(code, extraMessage = "", cause) {
    return new WalletLoginError(code, `${WalletLoginError.messages[code]}. ${extraMessage}`, cause);
  }
  static connectionError(extraMessage = "", cause) {
    return WalletLoginError.fromCode(5111, extraMessage, cause);
  }
  static disconnectionError(extraMessage = "", cause) {
    return WalletLoginError.fromCode(5112, extraMessage, cause);
  }
  static notConnectedError(extraMessage = "", cause) {
    return WalletLoginError.fromCode(5113, extraMessage, cause);
  }
  static popupClosed(extraMessage = "", cause) {
    return WalletLoginError.fromCode(5114, extraMessage, cause);
  }
  static mfaEnabled(extraMessage = "", cause) {
    return WalletLoginError.fromCode(5115, extraMessage, cause);
  }
  static chainConfigNotAdded(extraMessage = "", cause) {
    return WalletLoginError.fromCode(5116, extraMessage, cause);
  }
  static unsupportedOperation(extraMessage = "", cause) {
    return WalletLoginError.fromCode(5117, extraMessage, cause);
  }
  static coreKitKeyNotFound(extraMessage = "", cause) {
    return WalletLoginError.fromCode(5118, extraMessage, cause);
  }
  static userNotLoggedIn(extraMessage = "", cause) {
    return WalletLoginError.fromCode(5119, extraMessage, cause);
  }
}
_defineProperty(WalletLoginError, "messages", {
  5000: "Custom",
  5111: "Failed to connect with wallet",
  5112: "Failed to disconnect from wallet",
  5113: "Wallet is not connected",
  5114: "Wallet popup has been closed by the user",
  5115: "User has already enabled mfa, please use the @web3auth/web3auth-web sdk for login with mfa",
  5116: "Chain config has not been added. Please add the chain config before calling switchChain",
  5117: "Unsupported operation",
  5118: "useCoreKitKey flag is enabled but coreKitKey is not available",
  5119: "User not logged in."
});
class WalletOperationsError extends Web3AuthError {
  constructor(code, message, cause) {
    // takes care of stack and proto
    super(code, message, cause);

    // Set name explicitly as minification can mangle class names
    Object.defineProperty(this, "name", {
      value: "WalletOperationsError"
    });
  }
  static fromCode(code, extraMessage = "", cause) {
    return new WalletOperationsError(code, `${WalletOperationsError.messages[code]}, ${extraMessage}`, cause);
  }

  // Custom methods
  static chainIDNotAllowed(extraMessage = "", cause) {
    return WalletOperationsError.fromCode(5201, extraMessage, cause);
  }
  static operationNotAllowed(extraMessage = "", cause) {
    return WalletOperationsError.fromCode(5202, extraMessage, cause);
  }
  static chainNamespaceNotAllowed(extraMessage = "", cause) {
    return WalletOperationsError.fromCode(5203, extraMessage, cause);
  }
}
_defineProperty(WalletOperationsError, "messages", {
  5000: "Custom",
  5201: "Provided chainId is not allowed",
  5202: "This operation is not allowed"
});
class WalletProviderError extends Web3AuthError {
  constructor(code, message, cause) {
    // takes care of stack and proto
    super(code, message, cause);

    // Set name explicitly as minification can mangle class names
    Object.defineProperty(this, "name", {
      value: "WalletProviderError"
    });
  }
  static fromCode(code, extraMessage = "", cause) {
    return new WalletOperationsError(code, `${WalletProviderError.messages[code]}, ${extraMessage}`, cause);
  }

  // Custom methods
  static invalidRequestArgs(extraMessage = "", cause) {
    return WalletOperationsError.fromCode(5301, extraMessage, cause);
  }
  static invalidRequestMethod(extraMessage = "", cause) {
    return WalletOperationsError.fromCode(5302, extraMessage, cause);
  }
  static invalidRequestParams(extraMessage = "", cause) {
    return WalletOperationsError.fromCode(5303, extraMessage, cause);
  }
}
_defineProperty(WalletProviderError, "messages", {
  5000: "Custom",
  5301: "Expected a single, non-array, object argument.",
  5302: "'args.method' must be a non-empty string.",
  5303: "'args.params' must be an object or array if provided."
});

export { WalletInitializationError, WalletLoginError, WalletOperationsError, WalletProviderError, Web3AuthError, serializeError };
