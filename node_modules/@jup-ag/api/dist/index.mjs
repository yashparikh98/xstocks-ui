var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// generated/runtime.ts
var BASE_PATH = "https://api.jup.ag/swap/v1".replace(/\/+$/, "");
var Configuration = class {
  constructor(configuration = {}) {
    this.configuration = configuration;
  }
  set config(configuration) {
    this.configuration = configuration;
  }
  get basePath() {
    return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
  }
  get fetchApi() {
    return this.configuration.fetchApi;
  }
  get middleware() {
    return this.configuration.middleware || [];
  }
  get queryParamsStringify() {
    return this.configuration.queryParamsStringify || querystring;
  }
  get username() {
    return this.configuration.username;
  }
  get password() {
    return this.configuration.password;
  }
  get apiKey() {
    const apiKey = this.configuration.apiKey;
    if (apiKey) {
      return typeof apiKey === "function" ? apiKey : () => apiKey;
    }
    return void 0;
  }
  get accessToken() {
    const accessToken = this.configuration.accessToken;
    if (accessToken) {
      return typeof accessToken === "function" ? accessToken : () => __async(this, null, function* () {
        return accessToken;
      });
    }
    return void 0;
  }
  get headers() {
    return this.configuration.headers;
  }
  get credentials() {
    return this.configuration.credentials;
  }
};
var DefaultConfig = new Configuration();
var _BaseAPI = class _BaseAPI {
  constructor(configuration = DefaultConfig) {
    this.configuration = configuration;
    this.fetchApi = (url, init) => __async(this, null, function* () {
      let fetchParams = { url, init };
      for (const middleware of this.middleware) {
        if (middleware.pre) {
          fetchParams = (yield middleware.pre(__spreadValues({
            fetch: this.fetchApi
          }, fetchParams))) || fetchParams;
        }
      }
      let response = void 0;
      try {
        response = yield (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);
      } catch (e) {
        for (const middleware of this.middleware) {
          if (middleware.onError) {
            response = (yield middleware.onError({
              fetch: this.fetchApi,
              url: fetchParams.url,
              init: fetchParams.init,
              error: e,
              response: response ? response.clone() : void 0
            })) || response;
          }
        }
        if (response === void 0) {
          if (e instanceof Error) {
            throw new FetchError(e, "The request failed and the interceptors did not return an alternative response");
          } else {
            throw e;
          }
        }
      }
      for (const middleware of this.middleware) {
        if (middleware.post) {
          response = (yield middleware.post({
            fetch: this.fetchApi,
            url: fetchParams.url,
            init: fetchParams.init,
            response: response.clone()
          })) || response;
        }
      }
      return response;
    });
    this.middleware = configuration.middleware;
  }
  withMiddleware(...middlewares) {
    const next = this.clone();
    next.middleware = next.middleware.concat(...middlewares);
    return next;
  }
  withPreMiddleware(...preMiddlewares) {
    const middlewares = preMiddlewares.map((pre) => ({ pre }));
    return this.withMiddleware(...middlewares);
  }
  withPostMiddleware(...postMiddlewares) {
    const middlewares = postMiddlewares.map((post) => ({ post }));
    return this.withMiddleware(...middlewares);
  }
  /**
   * Check if the given MIME is a JSON MIME.
   * JSON MIME examples:
   *   application/json
   *   application/json; charset=UTF8
   *   APPLICATION/JSON
   *   application/vnd.company+json
   * @param mime - MIME (Multipurpose Internet Mail Extensions)
   * @return True if the given MIME is JSON, false otherwise.
   */
  isJsonMime(mime) {
    if (!mime) {
      return false;
    }
    return _BaseAPI.jsonRegex.test(mime);
  }
  request(context, initOverrides) {
    return __async(this, null, function* () {
      const { url, init } = yield this.createFetchParams(context, initOverrides);
      const response = yield this.fetchApi(url, init);
      if (response && (response.status >= 200 && response.status < 300)) {
        return response;
      }
      throw new ResponseError(response, "Response returned an error code");
    });
  }
  createFetchParams(context, initOverrides) {
    return __async(this, null, function* () {
      let url = this.configuration.basePath + context.path;
      if (context.query !== void 0 && Object.keys(context.query).length !== 0) {
        url += "?" + this.configuration.queryParamsStringify(context.query);
      }
      const headers = Object.assign({}, this.configuration.headers, context.headers);
      Object.keys(headers).forEach((key) => headers[key] === void 0 ? delete headers[key] : {});
      const initOverrideFn = typeof initOverrides === "function" ? initOverrides : () => __async(this, null, function* () {
        return initOverrides;
      });
      const initParams = {
        method: context.method,
        headers,
        body: context.body,
        credentials: this.configuration.credentials
      };
      const overriddenInit = __spreadValues(__spreadValues({}, initParams), yield initOverrideFn({
        init: initParams,
        context
      }));
      let body;
      if (isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body)) {
        body = overriddenInit.body;
      } else if (this.isJsonMime(headers["Content-Type"])) {
        body = JSON.stringify(overriddenInit.body);
      } else {
        body = overriddenInit.body;
      }
      const init = __spreadProps(__spreadValues({}, overriddenInit), {
        body
      });
      return { url, init };
    });
  }
  /**
   * Create a shallow clone of `this` by constructing a new instance
   * and then shallow cloning data members.
   */
  clone() {
    const constructor = this.constructor;
    const next = new constructor(this.configuration);
    next.middleware = this.middleware.slice();
    return next;
  }
};
_BaseAPI.jsonRegex = new RegExp("^(:?application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(:?;.*)?$", "i");
var BaseAPI = _BaseAPI;
function isBlob(value) {
  return typeof Blob !== "undefined" && value instanceof Blob;
}
function isFormData(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}
var ResponseError = class extends Error {
  constructor(response, msg) {
    super(msg);
    this.response = response;
    this.name = "ResponseError";
  }
};
var FetchError = class extends Error {
  constructor(cause, msg) {
    super(msg);
    this.cause = cause;
    this.name = "FetchError";
  }
};
var RequiredError = class extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }
};
var COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "	",
  pipes: "|"
};
function exists(json, key) {
  const value = json[key];
  return value !== null && value !== void 0;
}
function querystring(params, prefix = "") {
  return Object.keys(params).map((key) => querystringSingleKey(key, params[key], prefix)).filter((part) => part.length > 0).join("&");
}
function querystringSingleKey(key, value, keyPrefix = "") {
  const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);
  if (value instanceof Array) {
    const multiValue = value.map((singleValue) => encodeURIComponent(String(singleValue))).join(`&${encodeURIComponent(fullKey)}=`);
    return `${encodeURIComponent(fullKey)}=${multiValue}`;
  }
  if (value instanceof Set) {
    const valueAsArray = Array.from(value);
    return querystringSingleKey(key, valueAsArray, keyPrefix);
  }
  if (value instanceof Date) {
    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;
  }
  if (value instanceof Object) {
    return querystring(value, fullKey);
  }
  return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;
}
function mapValues(data, fn) {
  return Object.keys(data).reduce(
    (acc, key) => __spreadProps(__spreadValues({}, acc), { [key]: fn(data[key]) }),
    {}
  );
}
function canConsumeForm(consumes) {
  for (const consume of consumes) {
    if ("multipart/form-data" === consume.contentType) {
      return true;
    }
  }
  return false;
}
var JSONApiResponse = class {
  constructor(raw, transformer = (jsonValue) => jsonValue) {
    this.raw = raw;
    this.transformer = transformer;
  }
  value() {
    return __async(this, null, function* () {
      return this.transformer(yield this.raw.json());
    });
  }
};
var VoidApiResponse = class {
  constructor(raw) {
    this.raw = raw;
  }
  value() {
    return __async(this, null, function* () {
      return void 0;
    });
  }
};
var BlobApiResponse = class {
  constructor(raw) {
    this.raw = raw;
  }
  value() {
    return __async(this, null, function* () {
      return yield this.raw.blob();
    });
  }
};
var TextApiResponse = class {
  constructor(raw) {
    this.raw = raw;
  }
  value() {
    return __async(this, null, function* () {
      return yield this.raw.text();
    });
  }
};

// generated/models/AccountMeta.ts
function instanceOfAccountMeta(value) {
  let isInstance = true;
  isInstance = isInstance && "pubkey" in value;
  isInstance = isInstance && "isSigner" in value;
  isInstance = isInstance && "isWritable" in value;
  return isInstance;
}
function AccountMetaFromJSON(json) {
  return AccountMetaFromJSONTyped(json, false);
}
function AccountMetaFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "pubkey": json["pubkey"],
    "isSigner": json["isSigner"],
    "isWritable": json["isWritable"]
  };
}
function AccountMetaToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "pubkey": value.pubkey,
    "isSigner": value.isSigner,
    "isWritable": value.isWritable
  };
}

// generated/models/IndexedRouteMapResponse.ts
function instanceOfIndexedRouteMapResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "mintKeys" in value;
  isInstance = isInstance && "indexedRouteMap" in value;
  return isInstance;
}
function IndexedRouteMapResponseFromJSON(json) {
  return IndexedRouteMapResponseFromJSONTyped(json, false);
}
function IndexedRouteMapResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "mintKeys": json["mintKeys"],
    "indexedRouteMap": json["indexedRouteMap"]
  };
}
function IndexedRouteMapResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "mintKeys": value.mintKeys,
    "indexedRouteMap": value.indexedRouteMap
  };
}

// generated/models/Instruction.ts
function instanceOfInstruction(value) {
  let isInstance = true;
  isInstance = isInstance && "programId" in value;
  isInstance = isInstance && "accounts" in value;
  isInstance = isInstance && "data" in value;
  return isInstance;
}
function InstructionFromJSON(json) {
  return InstructionFromJSONTyped(json, false);
}
function InstructionFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "programId": json["programId"],
    "accounts": json["accounts"].map(AccountMetaFromJSON),
    "data": json["data"]
  };
}
function InstructionToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "programId": value.programId,
    "accounts": value.accounts.map(AccountMetaToJSON),
    "data": value.data
  };
}

// generated/models/JitoTipLamports.ts
function instanceOfJitoTipLamports(value) {
  let isInstance = true;
  isInstance = isInstance && "jitoTipLamports" in value;
  return isInstance;
}
function JitoTipLamportsFromJSON(json) {
  return JitoTipLamportsFromJSONTyped(json, false);
}
function JitoTipLamportsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "jitoTipLamports": json["jitoTipLamports"]
  };
}
function JitoTipLamportsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "jitoTipLamports": value.jitoTipLamports
  };
}

// generated/models/JitoTipLamportsWithPayerJitoTipLamportsWithPayer.ts
function instanceOfJitoTipLamportsWithPayerJitoTipLamportsWithPayer(value) {
  let isInstance = true;
  isInstance = isInstance && "lamports" in value;
  isInstance = isInstance && "payer" in value;
  return isInstance;
}
function JitoTipLamportsWithPayerJitoTipLamportsWithPayerFromJSON(json) {
  return JitoTipLamportsWithPayerJitoTipLamportsWithPayerFromJSONTyped(json, false);
}
function JitoTipLamportsWithPayerJitoTipLamportsWithPayerFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "lamports": json["lamports"],
    "payer": json["payer"]
  };
}
function JitoTipLamportsWithPayerJitoTipLamportsWithPayerToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "lamports": value.lamports,
    "payer": value.payer
  };
}

// generated/models/JitoTipLamportsWithPayer.ts
function instanceOfJitoTipLamportsWithPayer(value) {
  let isInstance = true;
  isInstance = isInstance && "jitoTipLamportsWithPayer" in value;
  return isInstance;
}
function JitoTipLamportsWithPayerFromJSON(json) {
  return JitoTipLamportsWithPayerFromJSONTyped(json, false);
}
function JitoTipLamportsWithPayerFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "jitoTipLamportsWithPayer": JitoTipLamportsWithPayerJitoTipLamportsWithPayerFromJSON(json["jitoTipLamportsWithPayer"])
  };
}
function JitoTipLamportsWithPayerToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "jitoTipLamportsWithPayer": JitoTipLamportsWithPayerJitoTipLamportsWithPayerToJSON(value.jitoTipLamportsWithPayer)
  };
}

// generated/models/PlatformFee.ts
function instanceOfPlatformFee(value) {
  let isInstance = true;
  return isInstance;
}
function PlatformFeeFromJSON(json) {
  return PlatformFeeFromJSONTyped(json, false);
}
function PlatformFeeFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "amount": !exists(json, "amount") ? void 0 : json["amount"],
    "feeBps": !exists(json, "feeBps") ? void 0 : json["feeBps"]
  };
}
function PlatformFeeToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "amount": value.amount,
    "feeBps": value.feeBps
  };
}

// generated/models/PriorityLevelWithMaxLamportsPriorityLevelWithMaxLamports.ts
var PriorityLevelWithMaxLamportsPriorityLevelWithMaxLamportsPriorityLevelEnum = {
  Medium: "medium",
  High: "high",
  VeryHigh: "veryHigh"
};
function instanceOfPriorityLevelWithMaxLamportsPriorityLevelWithMaxLamports(value) {
  let isInstance = true;
  isInstance = isInstance && "priorityLevel" in value;
  isInstance = isInstance && "maxLamports" in value;
  return isInstance;
}
function PriorityLevelWithMaxLamportsPriorityLevelWithMaxLamportsFromJSON(json) {
  return PriorityLevelWithMaxLamportsPriorityLevelWithMaxLamportsFromJSONTyped(json, false);
}
function PriorityLevelWithMaxLamportsPriorityLevelWithMaxLamportsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "priorityLevel": json["priorityLevel"],
    "maxLamports": json["maxLamports"],
    "global": !exists(json, "global") ? void 0 : json["global"]
  };
}
function PriorityLevelWithMaxLamportsPriorityLevelWithMaxLamportsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "priorityLevel": value.priorityLevel,
    "maxLamports": value.maxLamports,
    "global": value.global
  };
}

// generated/models/PriorityLevelWithMaxLamports.ts
function instanceOfPriorityLevelWithMaxLamports(value) {
  let isInstance = true;
  isInstance = isInstance && "priorityLevelWithMaxLamports" in value;
  return isInstance;
}
function PriorityLevelWithMaxLamportsFromJSON(json) {
  return PriorityLevelWithMaxLamportsFromJSONTyped(json, false);
}
function PriorityLevelWithMaxLamportsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "priorityLevelWithMaxLamports": PriorityLevelWithMaxLamportsPriorityLevelWithMaxLamportsFromJSON(json["priorityLevelWithMaxLamports"])
  };
}
function PriorityLevelWithMaxLamportsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "priorityLevelWithMaxLamports": PriorityLevelWithMaxLamportsPriorityLevelWithMaxLamportsToJSON(value.priorityLevelWithMaxLamports)
  };
}

// generated/models/SwapInfo.ts
function instanceOfSwapInfo(value) {
  let isInstance = true;
  isInstance = isInstance && "ammKey" in value;
  isInstance = isInstance && "inputMint" in value;
  isInstance = isInstance && "outputMint" in value;
  isInstance = isInstance && "inAmount" in value;
  isInstance = isInstance && "outAmount" in value;
  return isInstance;
}
function SwapInfoFromJSON(json) {
  return SwapInfoFromJSONTyped(json, false);
}
function SwapInfoFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "ammKey": json["ammKey"],
    "label": !exists(json, "label") ? void 0 : json["label"],
    "inputMint": json["inputMint"],
    "outputMint": json["outputMint"],
    "inAmount": json["inAmount"],
    "outAmount": json["outAmount"]
  };
}
function SwapInfoToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "ammKey": value.ammKey,
    "label": value.label,
    "inputMint": value.inputMint,
    "outputMint": value.outputMint,
    "inAmount": value.inAmount,
    "outAmount": value.outAmount
  };
}

// generated/models/RoutePlanStep.ts
function instanceOfRoutePlanStep(value) {
  let isInstance = true;
  isInstance = isInstance && "swapInfo" in value;
  return isInstance;
}
function RoutePlanStepFromJSON(json) {
  return RoutePlanStepFromJSONTyped(json, false);
}
function RoutePlanStepFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "swapInfo": SwapInfoFromJSON(json["swapInfo"]),
    "percent": !exists(json, "percent") ? void 0 : json["percent"],
    "bps": !exists(json, "bps") ? void 0 : json["bps"]
  };
}
function RoutePlanStepToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "swapInfo": SwapInfoToJSON(value.swapInfo),
    "percent": value.percent,
    "bps": value.bps
  };
}

// generated/models/SwapMode.ts
var SwapMode = {
  ExactIn: "ExactIn",
  ExactOut: "ExactOut"
};
function SwapModeFromJSON(json) {
  return SwapModeFromJSONTyped(json, false);
}
function SwapModeFromJSONTyped(json, ignoreDiscriminator) {
  return json;
}
function SwapModeToJSON(value) {
  return value;
}

// generated/models/QuoteResponse.ts
var QuoteResponseInstructionVersionEnum = {
  V1: "V1",
  V2: "V2"
};
function instanceOfQuoteResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "inputMint" in value;
  isInstance = isInstance && "inAmount" in value;
  isInstance = isInstance && "outputMint" in value;
  isInstance = isInstance && "outAmount" in value;
  isInstance = isInstance && "otherAmountThreshold" in value;
  isInstance = isInstance && "swapMode" in value;
  isInstance = isInstance && "slippageBps" in value;
  isInstance = isInstance && "priceImpactPct" in value;
  isInstance = isInstance && "routePlan" in value;
  return isInstance;
}
function QuoteResponseFromJSON(json) {
  return QuoteResponseFromJSONTyped(json, false);
}
function QuoteResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "inputMint": json["inputMint"],
    "inAmount": json["inAmount"],
    "outputMint": json["outputMint"],
    "outAmount": json["outAmount"],
    "otherAmountThreshold": json["otherAmountThreshold"],
    "instructionVersion": !exists(json, "instructionVersion") ? void 0 : json["instructionVersion"],
    "swapMode": SwapModeFromJSON(json["swapMode"]),
    "slippageBps": json["slippageBps"],
    "platformFee": !exists(json, "platformFee") ? void 0 : PlatformFeeFromJSON(json["platformFee"]),
    "priceImpactPct": json["priceImpactPct"],
    "routePlan": json["routePlan"].map(RoutePlanStepFromJSON),
    "contextSlot": !exists(json, "contextSlot") ? void 0 : json["contextSlot"],
    "timeTaken": !exists(json, "timeTaken") ? void 0 : json["timeTaken"]
  };
}
function QuoteResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "inputMint": value.inputMint,
    "inAmount": value.inAmount,
    "outputMint": value.outputMint,
    "outAmount": value.outAmount,
    "otherAmountThreshold": value.otherAmountThreshold,
    "instructionVersion": value.instructionVersion,
    "swapMode": SwapModeToJSON(value.swapMode),
    "slippageBps": value.slippageBps,
    "platformFee": PlatformFeeToJSON(value.platformFee),
    "priceImpactPct": value.priceImpactPct,
    "routePlan": value.routePlan.map(RoutePlanStepToJSON),
    "contextSlot": value.contextSlot,
    "timeTaken": value.timeTaken
  };
}

// generated/models/SwapInstructionsResponse.ts
function instanceOfSwapInstructionsResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "otherInstructions" in value;
  isInstance = isInstance && "computeBudgetInstructions" in value;
  isInstance = isInstance && "setupInstructions" in value;
  isInstance = isInstance && "swapInstruction" in value;
  isInstance = isInstance && "addressLookupTableAddresses" in value;
  return isInstance;
}
function SwapInstructionsResponseFromJSON(json) {
  return SwapInstructionsResponseFromJSONTyped(json, false);
}
function SwapInstructionsResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "otherInstructions": json["otherInstructions"].map(InstructionFromJSON),
    "computeBudgetInstructions": json["computeBudgetInstructions"].map(InstructionFromJSON),
    "setupInstructions": json["setupInstructions"].map(InstructionFromJSON),
    "swapInstruction": InstructionFromJSON(json["swapInstruction"]),
    "cleanupInstruction": !exists(json, "cleanupInstruction") ? void 0 : InstructionFromJSON(json["cleanupInstruction"]),
    "addressLookupTableAddresses": json["addressLookupTableAddresses"]
  };
}
function SwapInstructionsResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "otherInstructions": value.otherInstructions.map(InstructionToJSON),
    "computeBudgetInstructions": value.computeBudgetInstructions.map(InstructionToJSON),
    "setupInstructions": value.setupInstructions.map(InstructionToJSON),
    "swapInstruction": InstructionToJSON(value.swapInstruction),
    "cleanupInstruction": InstructionToJSON(value.cleanupInstruction),
    "addressLookupTableAddresses": value.addressLookupTableAddresses
  };
}

// generated/models/SwapRequestPrioritizationFeeLamports.ts
function SwapRequestPrioritizationFeeLamportsFromJSON(json) {
  return SwapRequestPrioritizationFeeLamportsFromJSONTyped(json, false);
}
function SwapRequestPrioritizationFeeLamportsFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return __spreadValues(__spreadValues(__spreadValues({}, JitoTipLamportsFromJSONTyped(json, true)), JitoTipLamportsWithPayerFromJSONTyped(json, true)), PriorityLevelWithMaxLamportsFromJSONTyped(json, true));
}
function SwapRequestPrioritizationFeeLamportsToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  if (instanceOfJitoTipLamports(value)) {
    return JitoTipLamportsToJSON(value);
  }
  if (instanceOfJitoTipLamportsWithPayer(value)) {
    return JitoTipLamportsWithPayerToJSON(value);
  }
  if (instanceOfPriorityLevelWithMaxLamports(value)) {
    return PriorityLevelWithMaxLamportsToJSON(value);
  }
  return {};
}

// generated/models/SwapRequest.ts
function instanceOfSwapRequest(value) {
  let isInstance = true;
  isInstance = isInstance && "userPublicKey" in value;
  isInstance = isInstance && "quoteResponse" in value;
  return isInstance;
}
function SwapRequestFromJSON(json) {
  return SwapRequestFromJSONTyped(json, false);
}
function SwapRequestFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "userPublicKey": json["userPublicKey"],
    "payer": !exists(json, "payer") ? void 0 : json["payer"],
    "wrapAndUnwrapSol": !exists(json, "wrapAndUnwrapSol") ? void 0 : json["wrapAndUnwrapSol"],
    "useSharedAccounts": !exists(json, "useSharedAccounts") ? void 0 : json["useSharedAccounts"],
    "feeAccount": !exists(json, "feeAccount") ? void 0 : json["feeAccount"],
    "trackingAccount": !exists(json, "trackingAccount") ? void 0 : json["trackingAccount"],
    "prioritizationFeeLamports": !exists(json, "prioritizationFeeLamports") ? void 0 : SwapRequestPrioritizationFeeLamportsFromJSON(json["prioritizationFeeLamports"]),
    "asLegacyTransaction": !exists(json, "asLegacyTransaction") ? void 0 : json["asLegacyTransaction"],
    "destinationTokenAccount": !exists(json, "destinationTokenAccount") ? void 0 : json["destinationTokenAccount"],
    "nativeDestinationAccount": !exists(json, "nativeDestinationAccount") ? void 0 : json["nativeDestinationAccount"],
    "dynamicComputeUnitLimit": !exists(json, "dynamicComputeUnitLimit") ? void 0 : json["dynamicComputeUnitLimit"],
    "skipUserAccountsRpcCalls": !exists(json, "skipUserAccountsRpcCalls") ? void 0 : json["skipUserAccountsRpcCalls"],
    "dynamicSlippage": !exists(json, "dynamicSlippage") ? void 0 : json["dynamicSlippage"],
    "computeUnitPriceMicroLamports": !exists(json, "computeUnitPriceMicroLamports") ? void 0 : json["computeUnitPriceMicroLamports"],
    "blockhashSlotsToExpiry": !exists(json, "blockhashSlotsToExpiry") ? void 0 : json["blockhashSlotsToExpiry"],
    "quoteResponse": QuoteResponseFromJSON(json["quoteResponse"])
  };
}
function SwapRequestToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "userPublicKey": value.userPublicKey,
    "payer": value.payer,
    "wrapAndUnwrapSol": value.wrapAndUnwrapSol,
    "useSharedAccounts": value.useSharedAccounts,
    "feeAccount": value.feeAccount,
    "trackingAccount": value.trackingAccount,
    "prioritizationFeeLamports": SwapRequestPrioritizationFeeLamportsToJSON(value.prioritizationFeeLamports),
    "asLegacyTransaction": value.asLegacyTransaction,
    "destinationTokenAccount": value.destinationTokenAccount,
    "nativeDestinationAccount": value.nativeDestinationAccount,
    "dynamicComputeUnitLimit": value.dynamicComputeUnitLimit,
    "skipUserAccountsRpcCalls": value.skipUserAccountsRpcCalls,
    "dynamicSlippage": value.dynamicSlippage,
    "computeUnitPriceMicroLamports": value.computeUnitPriceMicroLamports,
    "blockhashSlotsToExpiry": value.blockhashSlotsToExpiry,
    "quoteResponse": QuoteResponseToJSON(value.quoteResponse)
  };
}

// generated/models/SwapResponse.ts
function instanceOfSwapResponse(value) {
  let isInstance = true;
  isInstance = isInstance && "swapTransaction" in value;
  isInstance = isInstance && "lastValidBlockHeight" in value;
  return isInstance;
}
function SwapResponseFromJSON(json) {
  return SwapResponseFromJSONTyped(json, false);
}
function SwapResponseFromJSONTyped(json, ignoreDiscriminator) {
  if (json === void 0 || json === null) {
    return json;
  }
  return {
    "swapTransaction": json["swapTransaction"],
    "lastValidBlockHeight": json["lastValidBlockHeight"],
    "prioritizationFeeLamports": !exists(json, "prioritizationFeeLamports") ? void 0 : json["prioritizationFeeLamports"]
  };
}
function SwapResponseToJSON(value) {
  if (value === void 0) {
    return void 0;
  }
  if (value === null) {
    return null;
  }
  return {
    "swapTransaction": value.swapTransaction,
    "lastValidBlockHeight": value.lastValidBlockHeight,
    "prioritizationFeeLamports": value.prioritizationFeeLamports
  };
}

// generated/apis/SwapApi.ts
var SwapApi = class extends BaseAPI {
  /**
   * Returns a hash, which key is the program id and value is the label. This is used to help map error from transaction by identifying the fault program id. This can be used in conjunction with the `excludeDexes` or `dexes` parameter. 
   * program-id-to-label
   */
  programIdToLabelGetRaw(initOverrides) {
    return __async(this, null, function* () {
      const queryParameters = {};
      const headerParameters = {};
      const response = yield this.request({
        path: `/program-id-to-label`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response);
    });
  }
  /**
   * Returns a hash, which key is the program id and value is the label. This is used to help map error from transaction by identifying the fault program id. This can be used in conjunction with the `excludeDexes` or `dexes` parameter. 
   * program-id-to-label
   */
  programIdToLabelGet(initOverrides) {
    return __async(this, null, function* () {
      const response = yield this.programIdToLabelGetRaw(initOverrides);
      return yield response.value();
    });
  }
  /**
   * Request for a quote to be used in `POST /swap` 
   * quote
   */
  quoteGetRaw(requestParameters, initOverrides) {
    return __async(this, null, function* () {
      if (requestParameters.inputMint === null || requestParameters.inputMint === void 0) {
        throw new RequiredError("inputMint", "Required parameter requestParameters.inputMint was null or undefined when calling quoteGet.");
      }
      if (requestParameters.outputMint === null || requestParameters.outputMint === void 0) {
        throw new RequiredError("outputMint", "Required parameter requestParameters.outputMint was null or undefined when calling quoteGet.");
      }
      if (requestParameters.amount === null || requestParameters.amount === void 0) {
        throw new RequiredError("amount", "Required parameter requestParameters.amount was null or undefined when calling quoteGet.");
      }
      const queryParameters = {};
      if (requestParameters.inputMint !== void 0) {
        queryParameters["inputMint"] = requestParameters.inputMint;
      }
      if (requestParameters.outputMint !== void 0) {
        queryParameters["outputMint"] = requestParameters.outputMint;
      }
      if (requestParameters.amount !== void 0) {
        queryParameters["amount"] = requestParameters.amount;
      }
      if (requestParameters.slippageBps !== void 0) {
        queryParameters["slippageBps"] = requestParameters.slippageBps;
      }
      if (requestParameters.swapMode !== void 0) {
        queryParameters["swapMode"] = requestParameters.swapMode;
      }
      if (requestParameters.dexes) {
        queryParameters["dexes"] = requestParameters.dexes;
      }
      if (requestParameters.excludeDexes) {
        queryParameters["excludeDexes"] = requestParameters.excludeDexes;
      }
      if (requestParameters.restrictIntermediateTokens !== void 0) {
        queryParameters["restrictIntermediateTokens"] = requestParameters.restrictIntermediateTokens;
      }
      if (requestParameters.onlyDirectRoutes !== void 0) {
        queryParameters["onlyDirectRoutes"] = requestParameters.onlyDirectRoutes;
      }
      if (requestParameters.asLegacyTransaction !== void 0) {
        queryParameters["asLegacyTransaction"] = requestParameters.asLegacyTransaction;
      }
      if (requestParameters.platformFeeBps !== void 0) {
        queryParameters["platformFeeBps"] = requestParameters.platformFeeBps;
      }
      if (requestParameters.maxAccounts !== void 0) {
        queryParameters["maxAccounts"] = requestParameters.maxAccounts;
      }
      if (requestParameters.instructionVersion !== void 0) {
        queryParameters["instructionVersion"] = requestParameters.instructionVersion;
      }
      if (requestParameters.dynamicSlippage !== void 0) {
        queryParameters["dynamicSlippage"] = requestParameters.dynamicSlippage;
      }
      const headerParameters = {};
      const response = yield this.request({
        path: `/quote`,
        method: "GET",
        headers: headerParameters,
        query: queryParameters
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => QuoteResponseFromJSON(jsonValue));
    });
  }
  /**
   * Request for a quote to be used in `POST /swap` 
   * quote
   */
  quoteGet(requestParameters, initOverrides) {
    return __async(this, null, function* () {
      const response = yield this.quoteGetRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Request for swap instructions that you can use from the quote you get from `/quote` 
   * swap-instructions
   */
  swapInstructionsPostRaw(requestParameters, initOverrides) {
    return __async(this, null, function* () {
      if (requestParameters.swapRequest === null || requestParameters.swapRequest === void 0) {
        throw new RequiredError("swapRequest", "Required parameter requestParameters.swapRequest was null or undefined when calling swapInstructionsPost.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/swap-instructions`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SwapRequestToJSON(requestParameters.swapRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SwapInstructionsResponseFromJSON(jsonValue));
    });
  }
  /**
   * Request for swap instructions that you can use from the quote you get from `/quote` 
   * swap-instructions
   */
  swapInstructionsPost(requestParameters, initOverrides) {
    return __async(this, null, function* () {
      const response = yield this.swapInstructionsPostRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
  /**
   * Request for a base64-encoded unsigned swap transaction based on the `/quote` response 
   * swap
   */
  swapPostRaw(requestParameters, initOverrides) {
    return __async(this, null, function* () {
      if (requestParameters.swapRequest === null || requestParameters.swapRequest === void 0) {
        throw new RequiredError("swapRequest", "Required parameter requestParameters.swapRequest was null or undefined when calling swapPost.");
      }
      const queryParameters = {};
      const headerParameters = {};
      headerParameters["Content-Type"] = "application/json";
      const response = yield this.request({
        path: `/swap`,
        method: "POST",
        headers: headerParameters,
        query: queryParameters,
        body: SwapRequestToJSON(requestParameters.swapRequest)
      }, initOverrides);
      return new JSONApiResponse(response, (jsonValue) => SwapResponseFromJSON(jsonValue));
    });
  }
  /**
   * Request for a base64-encoded unsigned swap transaction based on the `/quote` response 
   * swap
   */
  swapPost(requestParameters, initOverrides) {
    return __async(this, null, function* () {
      const response = yield this.swapPostRaw(requestParameters, initOverrides);
      return yield response.value();
    });
  }
};
var QuoteGetSwapModeEnum = {
  ExactIn: "ExactIn",
  ExactOut: "ExactOut"
};
var QuoteGetInstructionVersionEnum = {
  V1: "V1",
  V2: "V2"
};

// src/index.ts
var PUBLIC_SERVER_URL = "https://lite-api.jup.ag/swap/v1";
var API_KEY_SERVER_URL = "https://api.jup.ag/swap/v1";
var createJupiterApiClient = (config) => {
  const hasApiKey = (config == null ? void 0 : config.apiKey) !== void 0;
  const configWithServer = __spreadProps(__spreadValues({}, config), {
    basePath: hasApiKey ? API_KEY_SERVER_URL : PUBLIC_SERVER_URL,
    headers: hasApiKey ? { "x-api-key": config == null ? void 0 : config.apiKey } : void 0
  });
  return new SwapApi(new Configuration(configWithServer));
};
export {
  AccountMetaFromJSON,
  AccountMetaFromJSONTyped,
  AccountMetaToJSON,
  BASE_PATH,
  BaseAPI,
  BlobApiResponse,
  COLLECTION_FORMATS,
  Configuration,
  DefaultConfig,
  FetchError,
  IndexedRouteMapResponseFromJSON,
  IndexedRouteMapResponseFromJSONTyped,
  IndexedRouteMapResponseToJSON,
  InstructionFromJSON,
  InstructionFromJSONTyped,
  InstructionToJSON,
  JSONApiResponse,
  JitoTipLamportsFromJSON,
  JitoTipLamportsFromJSONTyped,
  JitoTipLamportsToJSON,
  JitoTipLamportsWithPayerFromJSON,
  JitoTipLamportsWithPayerFromJSONTyped,
  JitoTipLamportsWithPayerJitoTipLamportsWithPayerFromJSON,
  JitoTipLamportsWithPayerJitoTipLamportsWithPayerFromJSONTyped,
  JitoTipLamportsWithPayerJitoTipLamportsWithPayerToJSON,
  JitoTipLamportsWithPayerToJSON,
  PlatformFeeFromJSON,
  PlatformFeeFromJSONTyped,
  PlatformFeeToJSON,
  PriorityLevelWithMaxLamportsFromJSON,
  PriorityLevelWithMaxLamportsFromJSONTyped,
  PriorityLevelWithMaxLamportsPriorityLevelWithMaxLamportsFromJSON,
  PriorityLevelWithMaxLamportsPriorityLevelWithMaxLamportsFromJSONTyped,
  PriorityLevelWithMaxLamportsPriorityLevelWithMaxLamportsPriorityLevelEnum,
  PriorityLevelWithMaxLamportsPriorityLevelWithMaxLamportsToJSON,
  PriorityLevelWithMaxLamportsToJSON,
  QuoteGetInstructionVersionEnum,
  QuoteGetSwapModeEnum,
  QuoteResponseFromJSON,
  QuoteResponseFromJSONTyped,
  QuoteResponseInstructionVersionEnum,
  QuoteResponseToJSON,
  RequiredError,
  ResponseError,
  RoutePlanStepFromJSON,
  RoutePlanStepFromJSONTyped,
  RoutePlanStepToJSON,
  SwapApi,
  SwapInfoFromJSON,
  SwapInfoFromJSONTyped,
  SwapInfoToJSON,
  SwapInstructionsResponseFromJSON,
  SwapInstructionsResponseFromJSONTyped,
  SwapInstructionsResponseToJSON,
  SwapMode,
  SwapModeFromJSON,
  SwapModeFromJSONTyped,
  SwapModeToJSON,
  SwapRequestFromJSON,
  SwapRequestFromJSONTyped,
  SwapRequestPrioritizationFeeLamportsFromJSON,
  SwapRequestPrioritizationFeeLamportsFromJSONTyped,
  SwapRequestPrioritizationFeeLamportsToJSON,
  SwapRequestToJSON,
  SwapResponseFromJSON,
  SwapResponseFromJSONTyped,
  SwapResponseToJSON,
  TextApiResponse,
  VoidApiResponse,
  canConsumeForm,
  createJupiterApiClient,
  exists,
  instanceOfAccountMeta,
  instanceOfIndexedRouteMapResponse,
  instanceOfInstruction,
  instanceOfJitoTipLamports,
  instanceOfJitoTipLamportsWithPayer,
  instanceOfJitoTipLamportsWithPayerJitoTipLamportsWithPayer,
  instanceOfPlatformFee,
  instanceOfPriorityLevelWithMaxLamports,
  instanceOfPriorityLevelWithMaxLamportsPriorityLevelWithMaxLamports,
  instanceOfQuoteResponse,
  instanceOfRoutePlanStep,
  instanceOfSwapInfo,
  instanceOfSwapInstructionsResponse,
  instanceOfSwapRequest,
  instanceOfSwapResponse,
  mapValues,
  querystring
};
