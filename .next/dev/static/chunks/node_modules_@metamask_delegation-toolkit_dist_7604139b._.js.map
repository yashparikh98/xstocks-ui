{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/executions.ts"],"sourcesContent":["import {\n  type Address,\n  type Hex,\n  encodeAbiParameters,\n  encodePacked,\n} from 'viem';\n\nexport type ExecutionStruct = {\n  target: Address;\n  value: bigint;\n  callData: Hex;\n};\n\nexport type CreateExecutionArgs = {\n  target: Address;\n  value?: bigint;\n  callData?: Hex;\n};\n\n/**\n * Creates an execution data structure.\n * @param args - The arguments for creating an execution.\n * @param args.target - The address to invoke some calldata on.\n * @param args.value - ETH to send to the address.\n * @param args.callData - The calldata to invoke on the address.\n * @returns The created execution data structure.\n */\nexport const createExecution = ({\n  target,\n  value = 0n,\n  callData = '0x',\n}: CreateExecutionArgs): ExecutionStruct => ({\n  target,\n  value,\n  callData,\n});\n\n// Encoded modes\n// https://github.com/erc7579/erc7579-implementation/blob/main/src/lib/ModeLib.sol\nexport enum ExecutionMode {\n  SingleDefault = '0x0000000000000000000000000000000000000000000000000000000000000000',\n  SingleTry = '0x0001000000000000000000000000000000000000000000000000000000000000',\n  BatchDefault = '0x0100000000000000000000000000000000000000000000000000000000000000',\n  BatchTry = '0x0101000000000000000000000000000000000000000000000000000000000000',\n}\n\n/**\n * The ABI type components of an Execution.\n */\nexport const EXECUTION_ABI_TYPE_COMPONENTS = [\n  { type: 'address', name: 'target' },\n  { type: 'uint256', name: 'value' },\n  { type: 'bytes', name: 'callData' },\n];\n\n/**\n * Encodes a single Execution. Used for executing a single Execution in a DeleGator SCA.\n * @param execution - The execution to encode.\n * @returns The encoded execution.\n */\nexport const encodeSingleExecution = (execution: ExecutionStruct): Hex => {\n  return encodePacked(\n    ['address', 'uint256', 'bytes'],\n    [execution.target, execution.value, execution.callData],\n  );\n};\n\n/**\n * Encodes a batch of Executions. Used for executing a batch of Executions in a DeleGator SCA.\n * @param executions - The executions to encode.\n * @returns The encoded executions.\n */\nexport const encodeBatchExecution = (executions: ExecutionStruct[]): Hex => {\n  return encodeAbiParameters(\n    [\n      {\n        components: EXECUTION_ABI_TYPE_COMPONENTS,\n        name: 'executions',\n        type: 'tuple[]',\n      },\n    ],\n    [executions],\n  );\n};\n\n/**\n * Encodes the calldata for interacting with the advanced `execute` DeleGator method.\n * @param executions - The execution(s) to encode.\n * @returns The encoded execution(s).\n */\nexport const encodeExecutionCalldata = (executions: ExecutionStruct[]): Hex => {\n  if (executions.length === 0) {\n    throw new Error(\n      'Error while getting the execution calldatas, executions is empty',\n    );\n  }\n  if (executions.length === 1) {\n    const execution = executions[0];\n    if (!execution) {\n      throw new Error('Execution not found');\n    }\n    return encodeSingleExecution(execution);\n  }\n\n  return encodeBatchExecution(executions);\n};\n\n/**\n * Encodes the calldata for interacting with `redeemDelegations`.\n * @param executionsBatch - The executions to encode.\n * @returns The encoded executions.\n */\nexport const encodeExecutionCalldatas = (\n  executionsBatch: ExecutionStruct[][],\n): Hex[] => {\n  if (executionsBatch.length === 0) {\n    throw new Error(\n      'Error while getting the execution calldatas, executionsBatch is empty',\n    );\n  }\n  return executionsBatch.map(encodeExecutionCalldata);\n};\n"],"names":["ExecutionMode"],"mappings":";;;;;;;;;;;;;;;;AAAA;;AA2BO,IAAM,kBAAkB,CAAC,EAC9B,MAAA,EACA,QAAQ,EAAA,EACR,WAAW,IAAA,EACb,GAAA,CAA6C;QAC3C;QACA;QACA;IACF,CAAA;AAIO,IAAK,gBAAL,aAAA,GAAA,CAAA,CAAKA,mBAAL;IACLA,cAAAA,CAAA,gBAAA,GAAgB;IAChBA,cAAAA,CAAA,YAAA,GAAY;IACZA,cAAAA,CAAA,eAAA,GAAe;IACfA,cAAAA,CAAA,WAAA,GAAW;IAJD,OAAAA;AAAA,CAAA,EAAA,iBAAA,CAAA;AAUL,IAAM,gCAAgC;IAC3C;QAAE,MAAM;QAAW,MAAM;IAAS;IAClC;QAAE,MAAM;QAAW,MAAM;IAAQ;IACjC;QAAE,MAAM;QAAS,MAAM;IAAW;CACpC;AAOO,IAAM,wBAAwB,CAAC,cAAoC;IACxE,WAAO,+KAAA,EACL;QAAC;QAAW;QAAW,OAAO;KAAA,EAC9B;QAAC,UAAU,MAAA;QAAQ,UAAU,KAAA;QAAO,UAAU,QAAQ;KAAA;AAE1D;AAOO,IAAM,uBAAuB,CAAC,eAAuC;IAC1E,WAAO,6LAAA,EACL;QACE;YACE,YAAY;YACZ,MAAM;YACN,MAAM;QACR;KACF,EACA;QAAC,UAAU;KAAA;AAEf;AAOO,IAAM,0BAA0B,CAAC,eAAuC;IAC7E,IAAI,WAAW,MAAA,KAAW,GAAG;QAC3B,MAAM,IAAI,MACR;IAEJ;IACA,IAAI,WAAW,MAAA,KAAW,GAAG;QAC3B,MAAM,YAAY,UAAA,CAAW,CAAC,CAAA;QAC9B,IAAI,CAAC,WAAW;YACd,MAAM,IAAI,MAAM,qBAAqB;QACvC;QACA,OAAO,sBAAsB,SAAS;IACxC;IAEA,OAAO,qBAAqB,UAAU;AACxC;AAOO,IAAM,2BAA2B,CACtC,oBACU;IACV,IAAI,gBAAgB,MAAA,KAAW,GAAG;QAChC,MAAM,IAAI,MACR;IAEJ;IACA,OAAO,gBAAgB,GAAA,CAAI,uBAAuB;AACpD"}},
    {"offset": {"line": 95, "column": 0}, "map": {"version":3,"sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/caveatBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/types.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/allowedCalldataBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/allowedMethodsBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/allowedTargetsBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/argsEqualityCheckBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/blockNumberBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/deployedBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/erc1155BalanceChangeBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/erc20BalanceChangeBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/erc20PeriodTransferBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/erc20StreamingBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/erc20TransferAmountBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/erc721BalanceChangeBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/erc721TransferBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/exactCalldataBatchBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/exactCalldataBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/exactExecutionBatchBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/exactExecutionBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/idBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/limitedCallsBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/multiTokenPeriodBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/nativeBalanceChangeBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/nativeTokenPaymentBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/nativeTokenPeriodTransferBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/nativeTokenStreamingBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/nativeTokenTransferAmountBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/nonceBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/ownershipTransferBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/redeemerBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/specificActionERC20TransferBatchBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/timestampBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/valueLteBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/coreCaveatBuilder.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/scope/erc20PeriodicScope.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/scope/erc20StreamingScope.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/scope/erc20TransferScope.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/utils.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/scope/erc721Scope.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/scope/functionCallScope.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/scope/nativeTokenPeriodicScope.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/scope/nativeTokenStreamingScope.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/scope/nativeTokenTransferScope.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/scope/ownershipScope.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/scope/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveatBuilder/resolveCaveats.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/caveats.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/delegation.ts"],"sourcesContent":["import type { Caveat, DeleGatorEnvironment } from '../types';\n\ntype CaveatWithOptionalArgs = Omit<Caveat, 'args'> & {\n  args?: Caveat['args'];\n};\n\nconst INSECURE_UNRESTRICTED_DELEGATION_ERROR_MESSAGE =\n  'No caveats found. If you definitely want to create an empty caveat collection, set `allowInsecureUnrestrictedDelegation` to `true`.';\n\ntype CaveatBuilderMap = {\n  [key: string]: (\n    environment: DeleGatorEnvironment,\n    ...args: [...any]\n  ) => Caveat;\n};\n\nexport type CaveatBuilderConfig = {\n  allowInsecureUnrestrictedDelegation?: boolean;\n};\n\n/**\n * A builder class for creating and managing caveats.\n * @template TCaveatBuilderMap - The type map of available caveat builder functions.\n */\nexport class CaveatBuilder<\n  TCaveatBuilderMap extends CaveatBuilderMap = Record<string, never>,\n> {\n  #results: Caveat[] = [];\n\n  #hasBeenBuilt = false;\n\n  #environment: DeleGatorEnvironment;\n\n  #config: CaveatBuilderConfig;\n\n  #enforcerBuilders: TCaveatBuilderMap;\n\n  constructor(\n    environment: DeleGatorEnvironment,\n    config: CaveatBuilderConfig = {},\n    enforcerBuilders: TCaveatBuilderMap = {} as TCaveatBuilderMap,\n    builtCaveats: Caveat[] = [],\n  ) {\n    this.#environment = environment;\n    this.#config = config;\n    this.#enforcerBuilders = enforcerBuilders;\n    this.#results = builtCaveats;\n  }\n\n  /**\n   * Extends the CaveatBuilder with a new enforcer function.\n   * @template TEnforcerName - The name of the enforcer.\n   * @template TFunction - The type of the enforcer function.\n   * @param name - The name of the enforcer.\n   * @param fn - The enforcer function.\n   * @returns The extended CaveatBuilder instance.\n   */\n  extend<\n    TEnforcerName extends string,\n    TFunction extends (\n      environment: DeleGatorEnvironment,\n      config: any,\n    ) => Caveat,\n  >(\n    name: TEnforcerName,\n    fn: TFunction,\n  ): CaveatBuilder<TCaveatBuilderMap & Record<TEnforcerName, TFunction>> {\n    return new CaveatBuilder<\n      TCaveatBuilderMap & Record<TEnforcerName, TFunction>\n    >(\n      this.#environment,\n      this.#config,\n      { ...this.#enforcerBuilders, [name]: fn },\n      this.#results,\n    );\n  }\n\n  /**\n   * Adds a caveat directly using a Caveat object.\n   * @param caveat - The caveat to add.\n   * @returns The CaveatBuilder instance for chaining.\n   */\n  addCaveat(caveat: CaveatWithOptionalArgs): CaveatBuilder<TCaveatBuilderMap>;\n\n  /**\n   * Adds a caveat using a named enforcer function.\n   * @param name - The name of the enforcer function to use.\n   * @param config - The configuration to pass to the enforcer function.\n   * @returns The CaveatBuilder instance for chaining.\n   */\n  addCaveat<TEnforcerName extends keyof TCaveatBuilderMap>(\n    name: TEnforcerName,\n    config: Parameters<TCaveatBuilderMap[TEnforcerName]>[1],\n  ): CaveatBuilder<TCaveatBuilderMap>;\n\n  addCaveat<TEnforcerName extends keyof TCaveatBuilderMap>(\n    nameOrCaveat: TEnforcerName | CaveatWithOptionalArgs,\n    config?: Parameters<TCaveatBuilderMap[TEnforcerName]>[1],\n  ): CaveatBuilder<TCaveatBuilderMap> {\n    if (typeof nameOrCaveat === 'object') {\n      const caveat = {\n        args: '0x' as const,\n        ...nameOrCaveat,\n      };\n\n      this.#results = [...this.#results, caveat];\n\n      return this;\n    }\n    const name = nameOrCaveat;\n\n    const func = this.#enforcerBuilders[name];\n    if (typeof func === 'function') {\n      const result = func(this.#environment, config);\n\n      this.#results = [...this.#results, result];\n\n      return this;\n    }\n    throw new Error(`Function \"${String(name)}\" does not exist.`);\n  }\n\n  /**\n   * Returns the caveats that have been built using this CaveatBuilder.\n   * @returns The array of built caveats.\n   * @throws Error if the builder has already been built or if no caveats are found and empty caveats are not allowed.\n   */\n  build(): Caveat[] {\n    if (this.#hasBeenBuilt) {\n      throw new Error('This CaveatBuilder has already been built.');\n    }\n\n    if (\n      this.#results.length === 0 &&\n      !this.#config.allowInsecureUnrestrictedDelegation\n    ) {\n      throw new Error(INSECURE_UNRESTRICTED_DELEGATION_ERROR_MESSAGE);\n    }\n\n    this.#hasBeenBuilt = true;\n\n    return this.#results;\n  }\n}\n","import type { DeleGatorEnvironment } from 'src/types';\n\nexport enum BalanceChangeType {\n  Increase = 0x0,\n  Decrease = 0x1,\n}\n\nexport type UnitOfAuthorityBaseConfig = { environment: DeleGatorEnvironment };\n","import { type Hex, concat, isHex, toHex } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\n\nexport const allowedCalldata = 'allowedCalldata';\n\nexport type AllowedCalldataBuilderConfig = {\n  /**\n   * The index in the calldata byte array (including the 4-byte method selector)\n   * where the expected calldata starts.\n   */\n  startIndex: number;\n  /**\n   * The expected calldata as a hex string that must match at the specified index.\n   */\n  value: Hex;\n};\n\n/**\n * Builds a caveat struct for AllowedCalldataEnforcer that restricts calldata to a specific value at a given index.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object containing startIndex and value.\n * @returns The Caveat.\n * @throws Error if the value is not a valid hex string, if startIndex is negative, or if startIndex is not a whole number.\n */\nexport const allowedCalldataBuilder = (\n  environment: DeleGatorEnvironment,\n  config: AllowedCalldataBuilderConfig,\n): Caveat => {\n  const { startIndex, value } = config;\n\n  if (!isHex(value)) {\n    throw new Error('Invalid value: must be a valid hex string');\n  }\n\n  if (startIndex < 0) {\n    throw new Error('Invalid startIndex: must be zero or positive');\n  }\n\n  if (!Number.isInteger(startIndex)) {\n    throw new Error('Invalid startIndex: must be a whole number');\n  }\n\n  const startIndexHex = toHex(startIndex, { size: 32 });\n\n  const terms = concat([startIndexHex, value]);\n\n  const {\n    caveatEnforcers: { AllowedCalldataEnforcer },\n  } = environment;\n\n  if (!AllowedCalldataEnforcer) {\n    throw new Error('AllowedCalldataEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: AllowedCalldataEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { isHex, concat, toFunctionSelector } from 'viem';\nimport type { AbiFunction, Hex } from 'viem';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const allowedMethods = 'allowedMethods';\n\nexport type MethodSelector = Hex | string | AbiFunction;\n\n// length of function selector in chars, _including_ 0x prefix\nconst FUNCTION_SELECTOR_STRING_LENGTH = 10;\n\nexport type AllowedMethodsBuilderConfig = {\n  /**\n   * An array of method selectors that the delegate is allowed to call.\n   * Can be 4-byte hex strings, ABI function signatures, or ABIFunction objects.\n   */\n  selectors: MethodSelector[];\n};\n\n/**\n * Builds a caveat struct for the AllowedMethodsEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object containing the allowed function selectors.\n * @returns The Caveat.\n * @throws Error if no selectors are provided or if any selector is invalid.\n */\nexport const allowedMethodsBuilder = (\n  environment: DeleGatorEnvironment,\n  config: AllowedMethodsBuilderConfig,\n): Caveat => {\n  const { selectors } = config;\n\n  if (selectors.length === 0) {\n    throw new Error('Invalid selectors: must provide at least one selector');\n  }\n\n  const parsedSelectors = selectors.map(parseSelector);\n\n  const terms = concat(parsedSelectors);\n\n  const {\n    caveatEnforcers: { AllowedMethodsEnforcer },\n  } = environment;\n\n  if (!AllowedMethodsEnforcer) {\n    throw new Error('AllowedMethodsEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: AllowedMethodsEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n\n/**\n * Parses a method selector into a hex string.\n * @param selector - The method selector to parse.\n * @returns The parsed selector as a hex string.\n */\nfunction parseSelector(selector: MethodSelector) {\n  if (isHex(selector)) {\n    if (selector.length === FUNCTION_SELECTOR_STRING_LENGTH) {\n      return selector;\n    }\n    throw new Error(\n      'Invalid selector: must be a 4 byte hex string, abi function signature, or AbiFunction',\n    );\n  }\n\n  try {\n    return toFunctionSelector(selector);\n  } catch (rootError: any) {\n    throw new Error(\n      'Invalid selector: must be a 4 byte hex string, abi function signature, or AbiFunction',\n      { cause: rootError },\n    );\n  }\n}\n","import { concat, isAddress, type Address } from 'viem';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const allowedTargets = 'allowedTargets';\n\nexport type AllowedTargetsBuilderConfig = {\n  /**\n   * An array of addresses that the delegate is allowed to call.\n   * Each address must be a valid hex string.\n   */\n  targets: Address[];\n};\n\n/**\n * Builds a caveat struct for AllowedTargetsEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object containing the targets.\n * @returns The Caveat.\n * @throws Error if no targets are provided or if any of the addresses are invalid.\n */\nexport const allowedTargetsBuilder = (\n  environment: DeleGatorEnvironment,\n  config: AllowedTargetsBuilderConfig,\n): Caveat => {\n  const { targets } = config;\n\n  if (targets.length === 0) {\n    throw new Error(\n      'Invalid targets: must provide at least one target address',\n    );\n  }\n\n  // we check that the address is valid, but doesn't need to be checksummed\n  const invalidAddresses = targets.filter(\n    (target) => !isAddress(target, { strict: false }),\n  );\n\n  if (invalidAddresses.length > 0) {\n    throw new Error('Invalid targets: must be valid addresses');\n  }\n\n  const terms = concat(targets);\n\n  const {\n    caveatEnforcers: { AllowedTargetsEnforcer },\n  } = environment;\n\n  if (!AllowedTargetsEnforcer) {\n    throw new Error('AllowedTargetsEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: AllowedTargetsEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { type Hex, isHex } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\n\nexport const argsEqualityCheck = 'argsEqualityCheck';\n\nexport type ArgsEqualityCheckBuilderConfig = {\n  /**\n   * The expected args as a hex string that must match exactly when redeeming the delegation.\n   */\n  args: Hex;\n};\n\n/**\n * Builds a caveat struct for the ArgsEqualityCheckEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object for the builder.\n * @returns The Caveat.\n * @throws Error if the config is invalid.\n */\nexport const argsEqualityCheckBuilder = (\n  environment: DeleGatorEnvironment,\n  config: ArgsEqualityCheckBuilderConfig,\n): Caveat => {\n  const { args } = config;\n  if (!isHex(args)) {\n    throw new Error('Invalid config: args must be a valid hex string');\n  }\n\n  const {\n    caveatEnforcers: { ArgsEqualityCheckEnforcer },\n  } = environment;\n\n  if (!ArgsEqualityCheckEnforcer) {\n    throw new Error('ArgsEqualityCheckEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ArgsEqualityCheckEnforcer,\n    terms: args,\n    args: '0x',\n  };\n};\n","import { concat, toHex } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\n\nexport const blockNumber = 'blockNumber';\n\nexport type BlockNumberBuilderConfig = {\n  /**\n   * The block number after which the delegation is valid.\n   * Set to 0n to disable this threshold.\n   */\n  afterThreshold: bigint;\n  /**\n   * The block number before which the delegation is valid.\n   * Set to 0n to disable this threshold.\n   */\n  beforeThreshold: bigint;\n};\n\n/**\n * Builds a caveat struct for the BlockNumberEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object for the BlockNumberEnforcer.\n * @returns The Caveat.\n * @throws Error if both thresholds are zero, if blockAfterThreshold is greater than or equal to blockBeforeThreshold, or if BlockNumberEnforcer is not available in the environment.\n */\nexport const blockNumberBuilder = (\n  environment: DeleGatorEnvironment,\n  config: BlockNumberBuilderConfig,\n): Caveat => {\n  const { afterThreshold, beforeThreshold } = config;\n\n  if (afterThreshold === 0n && beforeThreshold === 0n) {\n    throw new Error(\n      'Invalid thresholds: At least one of afterThreshold or beforeThreshold must be specified',\n    );\n  }\n\n  if (beforeThreshold !== 0n && afterThreshold >= beforeThreshold) {\n    throw new Error(\n      'Invalid thresholds: afterThreshold must be less than beforeThreshold if both are specified',\n    );\n  }\n\n  const terms = concat([\n    toHex(afterThreshold, {\n      size: 16,\n    }),\n    toHex(beforeThreshold, {\n      size: 16,\n    }),\n  ]);\n\n  const {\n    caveatEnforcers: { BlockNumberEnforcer },\n  } = environment;\n\n  if (!BlockNumberEnforcer) {\n    throw new Error('BlockNumberEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: BlockNumberEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { concat, isAddress, isHex, pad, type Address, type Hex } from 'viem';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const deployed = 'deployed';\n\nexport type DeployedBuilderConfig = {\n  /**\n   * The contract address as a hex string.\n   */\n  contractAddress: Address;\n  /**\n   * The salt to use with the deployment, as a hex string.\n   */\n  salt: Hex;\n  /**\n   * The bytecode of the contract as a hex string.\n   */\n  bytecode: Hex;\n};\n\n/**\n * Builds a caveat struct for a DeployedEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration for the deployed builder.\n * @returns The Caveat.\n * @throws Error if the contract address, factory address, or bytecode is invalid.\n */\nexport const deployedBuilder = (\n  environment: DeleGatorEnvironment,\n  config: DeployedBuilderConfig,\n): Caveat => {\n  const { contractAddress, salt, bytecode } = config;\n\n  // we check that the addresses are valid, but don't need to be checksummed\n  if (!isAddress(contractAddress, { strict: false })) {\n    throw new Error(\n      `Invalid contractAddress: must be a valid Ethereum address`,\n    );\n  }\n\n  if (!isHex(salt)) {\n    throw new Error('Invalid salt: must be a valid hexadecimal string');\n  }\n\n  if (!isHex(bytecode)) {\n    throw new Error('Invalid bytecode: must be a valid hexadecimal string');\n  }\n\n  const terms = concat([contractAddress, pad(salt, { size: 32 }), bytecode]);\n\n  const {\n    caveatEnforcers: { DeployedEnforcer },\n  } = environment;\n\n  if (!DeployedEnforcer) {\n    throw new Error('DeployedEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: DeployedEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { type Address, isAddress, encodePacked } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\nimport { BalanceChangeType } from './types';\n\nexport const erc1155BalanceChange = 'erc1155BalanceChange';\n\nexport type Erc1155BalanceChangeBuilderConfig = {\n  /**\n   * The ERC-1155 contract address as a hex string.\n   */\n  tokenAddress: Address;\n  /**\n   * The recipient's address as a hex string.\n   */\n  recipient: Address;\n  /**\n   * The ID of the ERC-1155 token as a bigint.\n   */\n  tokenId: bigint;\n  /**\n   * The amount by which the balance must have changed as a bigint.\n   */\n  balance: bigint;\n  /**\n   * The balance change type for the ERC-1155 token.\n   * Specifies whether the balance should have increased or decreased.\n   * Valid parameters are BalanceChangeType.Increase and BalanceChangeType.Decrease.\n   */\n  changeType: BalanceChangeType;\n};\n\n/**\n * Builds a caveat struct for the ERC1155BalanceChangeEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object for the ERC1155 balance change.\n * @returns The Caveat.\n * @throws Error if the token address is invalid, the recipient address is invalid, or the amount is not a positive number.\n */\nexport const erc1155BalanceChangeBuilder = (\n  environment: DeleGatorEnvironment,\n  config: Erc1155BalanceChangeBuilderConfig,\n): Caveat => {\n  const { tokenAddress, recipient, tokenId, balance, changeType } = config;\n\n  if (!isAddress(tokenAddress, { strict: false })) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  if (!isAddress(recipient, { strict: false })) {\n    throw new Error('Invalid recipient: must be a valid address');\n  }\n\n  if (balance <= 0n) {\n    throw new Error('Invalid balance: must be a positive number');\n  }\n\n  if (tokenId < 0n) {\n    throw new Error('Invalid tokenId: must be a non-negative number');\n  }\n\n  if (\n    changeType !== BalanceChangeType.Increase &&\n    changeType !== BalanceChangeType.Decrease\n  ) {\n    throw new Error('Invalid changeType: must be either Increase or Decrease');\n  }\n\n  const terms = encodePacked(\n    ['uint8', 'address', 'address', 'uint256', 'uint256'],\n    [changeType, tokenAddress, recipient, tokenId, balance],\n  );\n\n  const {\n    caveatEnforcers: { ERC1155BalanceChangeEnforcer },\n  } = environment;\n\n  if (!ERC1155BalanceChangeEnforcer) {\n    throw new Error('ERC1155BalanceChangeEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ERC1155BalanceChangeEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { type Address, isAddress, encodePacked } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\nimport { BalanceChangeType } from './types';\n\nexport const erc20BalanceChange = 'erc20BalanceChange';\n\nexport type Erc20BalanceChangeBuilderConfig = {\n  /**\n   * The ERC-20 contract address as a hex string.\n   */\n  tokenAddress: Address;\n  /**\n   * The recipient's address as a hex string.\n   */\n  recipient: Address;\n  /**\n   * The amount by which the balance must have changed as a bigint.\n   */\n  balance: bigint;\n  /**\n   * The balance change type for the ERC-20 token.\n   * Specifies whether the balance should have increased or decreased.\n   * Valid parameters are BalanceChangeType.Increase and BalanceChangeType.Decrease.\n   */\n  changeType: BalanceChangeType;\n};\n\n/**\n * Builds a caveat struct for the ERC20BalanceChangeEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object for the ERC20 balance change.\n * @returns The Caveat.\n * @throws Error if the token address is invalid, the amount is not a positive number, or the change type is invalid.\n */\nexport const erc20BalanceChangeBuilder = (\n  environment: DeleGatorEnvironment,\n  config: Erc20BalanceChangeBuilderConfig,\n): Caveat => {\n  const { tokenAddress, recipient, balance, changeType } = config;\n\n  if (!isAddress(tokenAddress, { strict: false })) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  if (balance <= 0n) {\n    throw new Error('Invalid balance: must be a positive number');\n  }\n\n  if (\n    changeType !== BalanceChangeType.Increase &&\n    changeType !== BalanceChangeType.Decrease\n  ) {\n    throw new Error('Invalid changeType: must be either Increase or Decrease');\n  }\n\n  const terms = encodePacked(\n    ['uint8', 'address', 'address', 'uint256'],\n    [changeType, tokenAddress, recipient, balance],\n  );\n\n  const {\n    caveatEnforcers: { ERC20BalanceChangeEnforcer },\n  } = environment;\n\n  if (!ERC20BalanceChangeEnforcer) {\n    throw new Error('ERC20BalanceChangeEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ERC20BalanceChangeEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { createERC20TokenPeriodTransferTerms } from '@metamask/delegation-core';\nimport type { Address } from 'viem';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const erc20PeriodTransfer = 'erc20PeriodTransfer';\n\nexport type Erc20PeriodTransferBuilderConfig = {\n  /**\n   * The ERC-20 contract address as a hex string.\n   */\n  tokenAddress: Address;\n  /**\n   * The maximum amount of tokens that can be transferred per period.\n   */\n  periodAmount: bigint;\n  /**\n   * The duration of each period in seconds.\n   */\n  periodDuration: number;\n  /**\n   * The timestamp when the first period begins in seconds.\n   */\n  startDate: number;\n};\n\n/**\n * Builds a caveat struct for ERC20PeriodTransferEnforcer.\n * This enforcer validates that ERC20 token transfers do not exceed a specified amount\n * within a given time period. The transferable amount resets at the beginning of each period,\n * and any unused tokens are forfeited once the period ends.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration for the ERC20 period transfer builder.\n * @returns The Caveat.\n * @throws Error if the token address is invalid or if any of the numeric parameters are invalid.\n */\nexport const erc20PeriodTransferBuilder = (\n  environment: DeleGatorEnvironment,\n  config: Erc20PeriodTransferBuilderConfig,\n): Caveat => {\n  const { tokenAddress, periodAmount, periodDuration, startDate } = config;\n\n  const terms = createERC20TokenPeriodTransferTerms({\n    tokenAddress,\n    periodAmount,\n    periodDuration,\n    startDate,\n  });\n\n  const {\n    caveatEnforcers: { ERC20PeriodTransferEnforcer },\n  } = environment;\n\n  if (!ERC20PeriodTransferEnforcer) {\n    throw new Error('ERC20PeriodTransferEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ERC20PeriodTransferEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { createERC20StreamingTerms } from '@metamask/delegation-core';\nimport { type Address } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\n\nexport const erc20Streaming = 'erc20Streaming';\n\nexport type Erc20StreamingBuilderConfig = {\n  /**\n   * The ERC-20 contract address as a hex string.\n   */\n  tokenAddress: Address;\n  /**\n   * The initial amount available at start time as a bigint.\n   */\n  initialAmount: bigint;\n  /**\n   * Maximum total amount that can be unlocked as a bigint.\n   */\n  maxAmount: bigint;\n  /**\n   * Rate at which tokens accrue per second as a bigint.\n   */\n  amountPerSecond: bigint;\n  /**\n   * The start timestamp in seconds.\n   */\n  startTime: number;\n};\n\n/**\n * Builds a caveat for ERC20 token streaming with configurable parameters.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration for the ERC20 streaming builder.\n * @returns The Caveat.\n * @throws Error if the token address is invalid.\n * @throws Error if the initial amount is a negative number.\n * @throws Error if the max amount is not greater than 0.\n * @throws Error if the max amount is less than the initial amount.\n * @throws Error if the amount per second is not a positive number.\n * @throws Error if the start time is not a positive number.\n */\nexport const erc20StreamingBuilder = (\n  environment: DeleGatorEnvironment,\n  config: Erc20StreamingBuilderConfig,\n): Caveat => {\n  const { tokenAddress, initialAmount, maxAmount, amountPerSecond, startTime } =\n    config;\n\n  const terms = createERC20StreamingTerms({\n    tokenAddress,\n    initialAmount,\n    maxAmount,\n    amountPerSecond,\n    startTime,\n  });\n\n  const {\n    caveatEnforcers: { ERC20StreamingEnforcer },\n  } = environment;\n\n  if (!ERC20StreamingEnforcer) {\n    throw new Error('ERC20StreamingEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ERC20StreamingEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import type { Address } from 'viem';\nimport { concat, isAddress, toHex } from 'viem';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const erc20TransferAmount = 'erc20TransferAmount';\n\nexport type Erc20TransferAmountBuilderConfig = {\n  /**\n   * The ERC-20 contract address as a hex string.\n   */\n  tokenAddress: Address;\n  /**\n   * The maximum amount of tokens that can be transferred as a bigint.\n   */\n  maxAmount: bigint;\n};\n\n/**\n * Builds a caveat struct for ERC20TransferAmountEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration for the ERC20 transfer amount builder.\n * @returns The Caveat.\n * @throws Error if the token address is invalid or if the max amount is not a positive number.\n */\nexport const erc20TransferAmountBuilder = (\n  environment: DeleGatorEnvironment,\n  config: Erc20TransferAmountBuilderConfig,\n): Caveat => {\n  const { tokenAddress, maxAmount } = config;\n\n  if (!isAddress(tokenAddress, { strict: false })) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  if (maxAmount <= 0n) {\n    throw new Error('Invalid maxAmount: must be a positive number');\n  }\n\n  const terms = concat([tokenAddress, toHex(maxAmount, { size: 32 })]);\n\n  const {\n    caveatEnforcers: { ERC20TransferAmountEnforcer },\n  } = environment;\n\n  if (!ERC20TransferAmountEnforcer) {\n    throw new Error('ERC20TransferAmountEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ERC20TransferAmountEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { type Address, isAddress, encodePacked } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\nimport { BalanceChangeType } from './types';\n\nexport const erc721BalanceChange = 'erc721BalanceChange';\n\nexport type Erc721BalanceChangeBuilderConfig = {\n  /**\n   * The ERC-721 contract address as a hex string.\n   */\n  tokenAddress: Address;\n  /**\n   * The recipient's address as a hex string.\n   */\n  recipient: Address;\n  /**\n   * The amount by which the balance must have changed as a bigint.\n   */\n  amount: bigint;\n  /**\n   * The balance change type for the ERC-721 token.\n   * Specifies whether the balance should have increased or decreased.\n   * Valid parameters are BalanceChangeType.Increase and BalanceChangeType.Decrease.\n   */\n  changeType: BalanceChangeType;\n};\n\n/**\n * Builds a caveat struct for the ERC721BalanceChangeEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object for the ERC721 balance change.\n * @returns The Caveat.\n * @throws Error if the token address is invalid, the recipient address is invalid, or the amount is not a positive number.\n */\nexport const erc721BalanceChangeBuilder = (\n  environment: DeleGatorEnvironment,\n  config: Erc721BalanceChangeBuilderConfig,\n): Caveat => {\n  const { tokenAddress, recipient, amount, changeType } = config;\n\n  if (!isAddress(tokenAddress, { strict: false })) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  if (!isAddress(recipient, { strict: false })) {\n    throw new Error('Invalid recipient: must be a valid address');\n  }\n\n  if (amount <= 0n) {\n    throw new Error('Invalid balance: must be a positive number');\n  }\n\n  if (\n    changeType !== BalanceChangeType.Increase &&\n    changeType !== BalanceChangeType.Decrease\n  ) {\n    throw new Error('Invalid changeType: must be either Increase or Decrease');\n  }\n\n  const terms = encodePacked(\n    ['uint8', 'address', 'address', 'uint256'],\n    [changeType, tokenAddress, recipient, amount],\n  );\n\n  const {\n    caveatEnforcers: { ERC721BalanceChangeEnforcer },\n  } = environment;\n\n  if (!ERC721BalanceChangeEnforcer) {\n    throw new Error('ERC721BalanceChangeEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ERC721BalanceChangeEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { type Address, isAddress, toHex, concat } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\n\nexport const erc721Transfer = 'erc721Transfer';\n\nexport type Erc721TransferBuilderConfig = {\n  /**\n   * The ERC-721 contract address as a hex string.\n   */\n  tokenAddress: Address;\n  /**\n   * The token ID as a bigint.\n   */\n  tokenId: bigint;\n};\n\n/**\n * Builds a caveat struct for the ERC721TransferEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object for the ERC721 transfer builder.\n * @returns The Caveat representing the caveat for ERC721 transfer.\n * @throws Error if the permitted contract address is invalid.\n */\nexport const erc721TransferBuilder = (\n  environment: DeleGatorEnvironment,\n  config: Erc721TransferBuilderConfig,\n): Caveat => {\n  const { tokenAddress, tokenId } = config;\n\n  if (!isAddress(tokenAddress, { strict: false })) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  if (tokenId < 0n) {\n    throw new Error('Invalid tokenId: must be a non-negative number');\n  }\n\n  const terms = concat([tokenAddress, toHex(tokenId, { size: 32 })]);\n\n  const {\n    caveatEnforcers: { ERC721TransferEnforcer },\n  } = environment;\n\n  if (!ERC721TransferEnforcer) {\n    throw new Error('ERC721TransferEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ERC721TransferEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { encodeAbiParameters, isAddress } from 'viem';\n\nimport type { ExecutionStruct } from '../executions';\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const exactCalldataBatch = 'exactCalldataBatch';\n\nexport type ExactCalldataBatchBuilderConfig = {\n  /**\n   * An array of executions that must be matched exactly in the batch.\n   * Each execution specifies a target address, value, and calldata.\n   */\n  executions: ExecutionStruct[];\n};\n\n/**\n * Builds a caveat struct for ExactCalldataBatchEnforcer.\n * This enforcer ensures that the provided batch execution calldata matches exactly\n * the expected calldata for each execution.\n *\n * @param environment - The DeleGator environment.\n * @param config - Configuration object containing executions.\n * @returns The Caveat.\n * @throws Error if any of the executions have invalid parameters.\n */\nexport const exactCalldataBatchBuilder = (\n  environment: DeleGatorEnvironment,\n  config: ExactCalldataBatchBuilderConfig,\n): Caveat => {\n  const { executions } = config;\n\n  if (executions.length === 0) {\n    throw new Error('Invalid executions: array cannot be empty');\n  }\n\n  // Validate each execution\n  for (const execution of executions) {\n    if (!isAddress(execution.target, { strict: false })) {\n      throw new Error('Invalid target: must be a valid address');\n    }\n\n    if (execution.value < 0n) {\n      throw new Error('Invalid value: must be a non-negative number');\n    }\n\n    if (!execution.callData.startsWith('0x')) {\n      throw new Error(\n        'Invalid calldata: must be a hex string starting with 0x',\n      );\n    }\n  }\n\n  // Encode the executions using the approach implemented in ExecutionLib.sol encodeBatch()\n  const terms = encodeAbiParameters(\n    [\n      {\n        type: 'tuple[]',\n        components: [\n          { type: 'address', name: 'target' },\n          { type: 'uint256', name: 'value' },\n          { type: 'bytes', name: 'callData' },\n        ],\n      },\n    ],\n    [executions],\n  );\n\n  const {\n    caveatEnforcers: { ExactCalldataBatchEnforcer },\n  } = environment;\n\n  if (!ExactCalldataBatchEnforcer) {\n    throw new Error('ExactCalldataBatchEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ExactCalldataBatchEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { createExactCalldataTerms } from '@metamask/delegation-core';\nimport type { Hex } from 'viem';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const exactCalldata = 'exactCalldata';\n\nexport type ExactCalldataBuilderConfig = {\n  /**\n   * The exact calldata that must be matched as a hex string.\n   */\n  calldata: Hex;\n};\n\n/**\n * Builds a caveat struct for ExactCalldataEnforcer.\n * This enforcer ensures that the provided execution calldata matches exactly\n * the expected calldata.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration for the ExactCalldataBuilder.\n * @returns The Caveat.\n * @throws Error if any of the parameters are invalid.\n */\nexport const exactCalldataBuilder = (\n  environment: DeleGatorEnvironment,\n  config: ExactCalldataBuilderConfig,\n): Caveat => {\n  const { calldata } = config;\n\n  const terms = createExactCalldataTerms({ calldata });\n\n  const {\n    caveatEnforcers: { ExactCalldataEnforcer },\n  } = environment;\n\n  if (!ExactCalldataEnforcer) {\n    throw new Error('ExactCalldataEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ExactCalldataEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { encodeAbiParameters, isAddress } from 'viem';\n\nimport type { ExecutionStruct } from '../executions';\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const exactExecutionBatch = 'exactExecutionBatch';\n\nexport type ExactExecutionBatchBuilderConfig = {\n  /**\n   * An array of executions that must be matched exactly in the batch.\n   * Each execution specifies a target address, value, and calldata.\n   */\n  executions: ExecutionStruct[];\n};\n\n/**\n * Builds a caveat struct for ExactExecutionBatchEnforcer.\n * This enforcer ensures that each execution in the batch matches exactly\n * with the expected execution (target, value, and calldata).\n *\n * @param environment - The DeleGator environment.\n * @param config - Configuration object containing executions.\n * @returns The Caveat.\n * @throws Error if any of the execution parameters are invalid.\n */\nexport const exactExecutionBatchBuilder = (\n  environment: DeleGatorEnvironment,\n  config: ExactExecutionBatchBuilderConfig,\n): Caveat => {\n  const { executions } = config;\n\n  if (executions.length === 0) {\n    throw new Error('Invalid executions: array cannot be empty');\n  }\n\n  // Validate each execution\n  for (const execution of executions) {\n    if (!isAddress(execution.target, { strict: false })) {\n      throw new Error('Invalid target: must be a valid address');\n    }\n\n    if (execution.value < 0n) {\n      throw new Error('Invalid value: must be a non-negative number');\n    }\n\n    if (!execution.callData.startsWith('0x')) {\n      throw new Error(\n        'Invalid calldata: must be a hex string starting with 0x',\n      );\n    }\n  }\n\n  // Encode the executions using the approach implemented in ExecutionLib.sol encodeBatch()\n  const terms = encodeAbiParameters(\n    [\n      {\n        type: 'tuple[]',\n        components: [\n          { type: 'address', name: 'target' },\n          { type: 'uint256', name: 'value' },\n          { type: 'bytes', name: 'callData' },\n        ],\n      },\n    ],\n    [executions],\n  );\n\n  const {\n    caveatEnforcers: { ExactExecutionBatchEnforcer },\n  } = environment;\n\n  if (!ExactExecutionBatchEnforcer) {\n    throw new Error('ExactExecutionBatchEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ExactExecutionBatchEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { isAddress, concat, toHex } from 'viem';\n\nimport type { ExecutionStruct } from '../executions';\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const exactExecution = 'exactExecution';\n\nexport type ExactExecutionBuilderConfig = {\n  /**\n   * The execution that must be matched exactly.\n   * Specifies the target address, value, and calldata.\n   */\n  execution: ExecutionStruct;\n};\n\n/**\n * Builds a caveat struct for ExactExecutionEnforcer.\n * This enforcer ensures that the provided execution matches exactly\n * with the expected execution (target, value, and calldata).\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object containing the execution.\n * @returns The Caveat.\n * @throws Error if any of the execution parameters are invalid.\n */\nexport const exactExecutionBuilder = (\n  environment: DeleGatorEnvironment,\n  config: ExactExecutionBuilderConfig,\n): Caveat => {\n  const { execution } = config;\n\n  if (!isAddress(execution.target, { strict: false })) {\n    throw new Error('Invalid target: must be a valid address');\n  }\n\n  if (execution.value < 0n) {\n    throw new Error('Invalid value: must be a non-negative number');\n  }\n\n  if (!execution.callData.startsWith('0x')) {\n    throw new Error('Invalid calldata: must be a hex string starting with 0x');\n  }\n\n  const terms = concat([\n    execution.target,\n    toHex(execution.value, { size: 32 }),\n    execution.callData,\n  ]);\n\n  const {\n    caveatEnforcers: { ExactExecutionEnforcer },\n  } = environment;\n\n  if (!ExactExecutionEnforcer) {\n    throw new Error('ExactExecutionEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ExactExecutionEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { maxUint256, toHex } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\n\nexport type IdBuilderConfig = {\n  /**\n   * An id for the delegation. Only one delegation may be redeemed with any given id.\n   */\n  id: bigint | number;\n};\n\nexport const id = 'id';\n\n/**\n * Builds a caveat struct for the IdEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object containing the id to use in the caveat.\n * @returns The Caveat.\n * @throws Error if the provided id is not a number, not an integer, or is not 32 bytes or fewer in length.\n */\nexport const idBuilder = (\n  environment: DeleGatorEnvironment,\n  config: IdBuilderConfig,\n): Caveat => {\n  const { id: idValue } = config;\n\n  let idBigInt: bigint;\n\n  if (typeof idValue === 'number') {\n    if (!Number.isInteger(idValue)) {\n      throw new Error('Invalid id: must be an integer');\n    }\n\n    idBigInt = BigInt(idValue);\n  } else if (typeof idValue === 'bigint') {\n    idBigInt = idValue;\n  } else {\n    throw new Error('Invalid id: must be a bigint or number');\n  }\n\n  if (idBigInt < 0n) {\n    throw new Error('Invalid id: must be a non-negative number');\n  }\n\n  if (idBigInt > maxUint256) {\n    throw new Error('Invalid id: must be less than 2^256');\n  }\n\n  const terms = toHex(idBigInt, { size: 32 });\n\n  const {\n    caveatEnforcers: { IdEnforcer },\n  } = environment;\n\n  if (!IdEnforcer) {\n    throw new Error('IdEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: IdEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { type Hex, toHex, pad } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\n\nexport const limitedCalls = 'limitedCalls';\n\nexport type LimitedCallsBuilderConfig = {\n  /**\n   * The maximum number of times this delegation may be redeemed.\n   */\n  limit: number;\n};\n\n/**\n * Builds a caveat struct for the LimitedCallsEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object containing the limit.\n * @returns The Caveat.\n * @throws Error if the limit is not a positive integer.\n */\nexport const limitedCallsBuilder = (\n  environment: DeleGatorEnvironment,\n  config: LimitedCallsBuilderConfig,\n): Caveat => {\n  const { limit } = config;\n\n  if (!Number.isInteger(limit)) {\n    throw new Error('Invalid limit: must be an integer');\n  }\n\n  if (limit <= 0) {\n    throw new Error('Invalid limit: must be a positive integer');\n  }\n\n  const terms: Hex = pad(toHex(limit), { size: 32 });\n\n  const {\n    caveatEnforcers: { LimitedCallsEnforcer },\n  } = environment;\n\n  if (!LimitedCallsEnforcer) {\n    throw new Error('LimitedCallsEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: LimitedCallsEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import type { Hex } from 'viem';\nimport { concat, isAddress, pad, toHex } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\n\nexport type TokenPeriodConfig = {\n  /**\n   * The token contract address as a hex string.\n   */\n  token: Hex;\n  /**\n   * The maximum amount of tokens that can be transferred per period.\n   */\n  periodAmount: bigint;\n  /**\n   * The duration of each period in seconds.\n   */\n  periodDuration: number;\n  /**\n   * The timestamp when the first period begins in seconds.\n   */\n  startDate: number;\n};\n\nexport type MultiTokenPeriodBuilderConfig = TokenPeriodConfig[];\n\nexport const multiTokenPeriod = 'multiTokenPeriod';\n\n/**\n * Creates a caveat for the MultiTokenPeriodEnforcer.\n * This enforcer allows setting periodic transfer limits for multiple tokens.\n * Each token can have its own period amount, duration, and start date.\n *\n * @param environment - The DeleGator environment.\n * @param configs - The configurations for the MultiTokenPeriodBuilder.\n * @returns The caveat object for the MultiTokenPeriodEnforcer.\n */\nexport const multiTokenPeriodBuilder = (\n  environment: DeleGatorEnvironment,\n  configs: MultiTokenPeriodBuilderConfig,\n): Caveat => {\n  if (!configs || configs.length === 0) {\n    throw new Error('MultiTokenPeriodBuilder: configs array cannot be empty');\n  }\n\n  configs.forEach((config) => {\n    if (!isAddress(config.token)) {\n      throw new Error(`Invalid token address: ${String(config.token)}`);\n    }\n\n    if (config.periodAmount <= 0) {\n      throw new Error('Invalid period amount: must be greater than 0');\n    }\n\n    if (config.periodDuration <= 0) {\n      throw new Error('Invalid period duration: must be greater than 0');\n    }\n  });\n\n  // Each config requires 116 bytes:\n  // - 20 bytes for token address\n  // - 32 bytes for periodAmount\n  // - 32 bytes for periodDuration\n  // - 32 bytes for startDate\n  const termsArray = configs.reduce<Hex[]>(\n    (acc, { token, periodAmount, periodDuration, startDate }) => [\n      ...acc,\n      pad(token, { size: 20 }),\n      toHex(periodAmount, { size: 32 }),\n      toHex(periodDuration, { size: 32 }),\n      toHex(startDate, { size: 32 }),\n    ],\n    [],\n  );\n\n  const terms = concat(termsArray);\n\n  const {\n    caveatEnforcers: { MultiTokenPeriodEnforcer },\n  } = environment;\n\n  if (!MultiTokenPeriodEnforcer) {\n    throw new Error('MultiTokenPeriodEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: MultiTokenPeriodEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { type Address, isAddress, encodePacked } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\nimport { BalanceChangeType } from './types';\n\nexport const nativeBalanceChange = 'nativeBalanceChange';\n\nexport type NativeBalanceChangeBuilderConfig = {\n  /**\n   * The recipient's address as a hex string.\n   */\n  recipient: Address;\n  /**\n   * The amount by which the balance must have changed as a bigint.\n   */\n  balance: bigint;\n  /**\n   * The balance change type for the native currency.\n   * Specifies whether the balance should have increased or decreased.\n   * Valid parameters are BalanceChangeType.Increase and BalanceChangeType.Decrease.\n   */\n  changeType: BalanceChangeType;\n};\n\n/**\n * Builds a caveat struct for the NativeBalanceChangeEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object for the NativeBalanceChangeEnforcer.\n * @returns The Caveat.\n * @throws Error if the recipient address is invalid or the amount is not a positive number.\n */\nexport const nativeBalanceChangeBuilder = (\n  environment: DeleGatorEnvironment,\n  config: NativeBalanceChangeBuilderConfig,\n): Caveat => {\n  const { recipient, balance, changeType } = config;\n\n  if (!isAddress(recipient)) {\n    throw new Error('Invalid recipient: must be a valid Address');\n  }\n\n  if (balance <= 0n) {\n    throw new Error('Invalid balance: must be a positive number');\n  }\n\n  if (\n    changeType !== BalanceChangeType.Increase &&\n    changeType !== BalanceChangeType.Decrease\n  ) {\n    throw new Error('Invalid changeType: must be either Increase or Decrease');\n  }\n\n  const terms = encodePacked(\n    ['uint8', 'address', 'uint256'],\n    [changeType, recipient, balance],\n  );\n\n  const {\n    caveatEnforcers: { NativeBalanceChangeEnforcer },\n  } = environment;\n\n  if (!NativeBalanceChangeEnforcer) {\n    throw new Error('NativeBalanceChangeEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: NativeBalanceChangeEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { type Address, encodePacked, isAddress } from 'viem';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const nativeTokenPayment = 'nativeTokenPayment';\n\nexport type NativeTokenPaymentBuilderConfig = {\n  /**\n   * The recipient's address as a hex string.\n   */\n  recipient: Address;\n  /**\n   * The amount that must be paid as a bigint.\n   */\n  amount: bigint;\n};\n\n/**\n * Builds a caveat struct for the NativeTokenPaymentEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object for the NativeTokenPaymentEnforcer.\n * @returns The Caveat.\n * @throws Error if the amount is invalid or the recipient address is invalid.\n */\nexport const nativeTokenPaymentBuilder = (\n  environment: DeleGatorEnvironment,\n  config: NativeTokenPaymentBuilderConfig,\n): Caveat => {\n  const { recipient, amount } = config;\n\n  if (amount <= 0n) {\n    throw new Error('Invalid amount: must be positive');\n  }\n\n  if (!isAddress(recipient)) {\n    throw new Error('Invalid recipient: must be a valid address');\n  }\n\n  const terms = encodePacked(['address', 'uint256'], [recipient, amount]);\n\n  const {\n    caveatEnforcers: { NativeTokenPaymentEnforcer },\n  } = environment;\n\n  if (!NativeTokenPaymentEnforcer) {\n    throw new Error('NativeTokenPaymentEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: NativeTokenPaymentEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { createNativeTokenPeriodTransferTerms } from '@metamask/delegation-core';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const nativeTokenPeriodTransfer = 'nativeTokenPeriodTransfer';\n\nexport type NativeTokenPeriodTransferBuilderConfig = {\n  /**\n   * The maximum amount of tokens that can be transferred per period.\n   */\n  periodAmount: bigint;\n  /**\n   * The duration of each period in seconds.\n   */\n  periodDuration: number;\n  /**\n   * The timestamp when the first period begins in seconds.\n   */\n  startDate: number;\n};\n\n/**\n * Builds a caveat struct for NativeTokenPeriodTransferEnforcer.\n * This enforcer validates that native token (ETH) transfers do not exceed a specified amount\n * within a given time period. The transferable amount resets at the beginning of each period,\n * and any unused ETH is forfeited once the period ends.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object containing periodAmount, periodDuration, and startDate.\n * @returns The Caveat.\n * @throws Error if any of the parameters are invalid.\n */\nexport const nativeTokenPeriodTransferBuilder = (\n  environment: DeleGatorEnvironment,\n  config: NativeTokenPeriodTransferBuilderConfig,\n): Caveat => {\n  const { periodAmount, periodDuration, startDate } = config;\n\n  const terms = createNativeTokenPeriodTransferTerms({\n    periodAmount,\n    periodDuration,\n    startDate,\n  });\n\n  const {\n    caveatEnforcers: { NativeTokenPeriodTransferEnforcer },\n  } = environment;\n\n  if (!NativeTokenPeriodTransferEnforcer) {\n    throw new Error(\n      'NativeTokenPeriodTransferEnforcer not found in environment',\n    );\n  }\n\n  return {\n    enforcer: NativeTokenPeriodTransferEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { createNativeTokenStreamingTerms } from '@metamask/delegation-core';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\n\nexport const nativeTokenStreaming = 'nativeTokenStreaming';\n\nexport type NativeTokenStreamingBuilderConfig = {\n  /**\n   * The initial amount available at start time as a bigint.\n   */\n  initialAmount: bigint;\n  /**\n   * Maximum total amount that can be unlocked as a bigint.\n   */\n  maxAmount: bigint;\n  /**\n   * Rate at which tokens accrue per second as a bigint.\n   */\n  amountPerSecond: bigint;\n  /**\n   * Start timestamp as a number in seconds.\n   */\n  startTime: number;\n};\n\n/**\n * Builds a caveat struct for the NativeTokenStreamingEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object for the NativeTokenStreamingEnforcer.\n * @returns The Caveat.\n * @throws Error if any of the parameters are invalid.\n */\nexport const nativeTokenStreamingBuilder = (\n  environment: DeleGatorEnvironment,\n  config: NativeTokenStreamingBuilderConfig,\n): Caveat => {\n  const { initialAmount, maxAmount, amountPerSecond, startTime } = config;\n\n  const terms = createNativeTokenStreamingTerms({\n    initialAmount,\n    maxAmount,\n    amountPerSecond,\n    startTime,\n  });\n\n  const {\n    caveatEnforcers: { NativeTokenStreamingEnforcer },\n  } = environment;\n\n  if (!NativeTokenStreamingEnforcer) {\n    throw new Error('NativeTokenStreamingEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: NativeTokenStreamingEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { encodePacked } from 'viem';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const nativeTokenTransferAmount = 'nativeTokenTransferAmount';\n\nexport type NativeTokenTransferAmountBuilderConfig = {\n  /**\n   * The maximum amount of native tokens that can be transferred.\n   */\n  maxAmount: bigint;\n};\n\n/**\n * Builds a caveat struct for the NativeTokenTransferAmountEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object containing the maxAmount.\n * @returns The Caveat.\n * @throws Error if the maxAmount is negative.\n */\nexport const nativeTokenTransferAmountBuilder = (\n  environment: DeleGatorEnvironment,\n  config: NativeTokenTransferAmountBuilderConfig,\n): Caveat => {\n  const { maxAmount } = config;\n\n  if (maxAmount < 0n) {\n    throw new Error('Invalid maxAmount: must be zero or positive');\n  }\n\n  const terms = encodePacked(['uint256'], [maxAmount]);\n\n  const {\n    caveatEnforcers: { NativeTokenTransferAmountEnforcer },\n  } = environment;\n\n  if (!NativeTokenTransferAmountEnforcer) {\n    throw new Error(\n      'NativeTokenTransferAmountEnforcer not found in environment',\n    );\n  }\n\n  return {\n    enforcer: NativeTokenTransferAmountEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { createNonceTerms } from '@metamask/delegation-core';\nimport { type Hex } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\n\nexport const nonce = 'nonce';\n\nexport type NonceBuilderConfig = {\n  /**\n   * A nonce as a hex string to allow bulk revocation of delegations.\n   */\n  nonce: Hex;\n};\n\n/**\n * Builds a caveat struct for the NonceEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object containing the nonce value.\n * @returns The Caveat.\n * @throws Error if the nonce is invalid.\n */\nexport const nonceBuilder = (\n  environment: DeleGatorEnvironment,\n  config: NonceBuilderConfig,\n): Caveat => {\n  const { nonce: nonceValue } = config;\n\n  const terms = createNonceTerms({ nonce: nonceValue });\n\n  const {\n    caveatEnforcers: { NonceEnforcer },\n  } = environment;\n\n  if (!NonceEnforcer) {\n    throw new Error('NonceEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: NonceEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { type Address, isAddress } from 'viem';\n\nimport type { DeleGatorEnvironment, Caveat } from '../types';\n\nexport const ownershipTransfer = 'ownershipTransfer';\n\nexport type OwnershipTransferBuilderConfig = {\n  /**\n   * The target contract address as a hex string for which ownership transfers are allowed.\n   */\n  contractAddress: Address;\n};\n\n/**\n * Builds a caveat struct for the OwnershipTransferEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object for the ownership transfer builder.\n * @returns The Caveat representing the caveat for ownership transfer.\n * @throws Error if the target contract address is invalid.\n */\nexport const ownershipTransferBuilder = (\n  environment: DeleGatorEnvironment,\n  config: OwnershipTransferBuilderConfig,\n): Caveat => {\n  const { contractAddress } = config;\n\n  if (!isAddress(contractAddress, { strict: false })) {\n    throw new Error('Invalid contractAddress: must be a valid address');\n  }\n\n  const terms = contractAddress;\n\n  const {\n    caveatEnforcers: { OwnershipTransferEnforcer },\n  } = environment;\n\n  if (!OwnershipTransferEnforcer) {\n    throw new Error('OwnershipTransferEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: OwnershipTransferEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { type Address, concat, isAddress } from 'viem';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const redeemer = 'redeemer';\n\nexport type RedeemerBuilderConfig = {\n  /**\n   * An array of addresses that are allowed to redeem the delegation.\n   * Each address must be a valid hex string.\n   */\n  redeemers: Address[];\n};\n\n/**\n * Builds a caveat struct for the RedeemerEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object containing redeemers.\n * @returns The Caveat.\n * @throws Error if the redeemer address is invalid or the array is empty.\n */\nexport const redeemerBuilder = (\n  environment: DeleGatorEnvironment,\n  config: RedeemerBuilderConfig,\n): Caveat => {\n  const { redeemers } = config;\n\n  if (redeemers.length === 0) {\n    throw new Error(\n      'Invalid redeemers: must specify at least one redeemer address',\n    );\n  }\n\n  for (const redeemerAddress of redeemers) {\n    if (!isAddress(redeemerAddress)) {\n      throw new Error('Invalid redeemers: must be a valid address');\n    }\n  }\n\n  const terms = concat(redeemers);\n\n  const {\n    caveatEnforcers: { RedeemerEnforcer },\n  } = environment;\n\n  if (!RedeemerEnforcer) {\n    throw new Error('RedeemerEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: RedeemerEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { concat, isAddress, toHex, type Address, type Hex } from 'viem';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const specificActionERC20TransferBatch =\n  'specificActionERC20TransferBatch';\n\nexport type SpecificActionErc20TransferBatchBuilderConfig = {\n  /**\n   * The address of the ERC-20 token contract.\n   */\n  tokenAddress: Address;\n  /**\n   * The address that will receive the tokens.\n   */\n  recipient: Address;\n  /**\n   * The amount of tokens to transfer.\n   */\n  amount: bigint;\n  /**\n   * The target address for the first transaction.\n   */\n  target: Address;\n  /**\n   * The calldata for the first transaction.\n   */\n  calldata: Hex;\n};\n\n/**\n * Builds a caveat struct for SpecificActionERC20TransferBatchEnforcer.\n * Enforces a batch of exactly 2 transactions: a specific action followed by an ERC20 transfer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration for the specific action ERC20 transfer batch builder.\n * @returns The Caveat.\n * @throws Error if any of the addresses are invalid or if the amount is not a positive number.\n */\nexport const specificActionERC20TransferBatchBuilder = (\n  environment: DeleGatorEnvironment,\n  config: SpecificActionErc20TransferBatchBuilderConfig,\n): Caveat => {\n  const { tokenAddress, recipient, amount, target, calldata } = config;\n\n  if (!isAddress(tokenAddress, { strict: false })) {\n    throw new Error('Invalid tokenAddress: must be a valid address');\n  }\n\n  if (!isAddress(recipient, { strict: false })) {\n    throw new Error('Invalid recipient: must be a valid address');\n  }\n\n  if (!isAddress(target, { strict: false })) {\n    throw new Error('Invalid target: must be a valid address');\n  }\n\n  if (amount <= 0n) {\n    throw new Error('Invalid amount: must be a positive number');\n  }\n\n  const terms = concat([\n    tokenAddress,\n    recipient,\n    toHex(amount, { size: 32 }),\n    target,\n    calldata,\n  ]);\n\n  const {\n    caveatEnforcers: { SpecificActionERC20TransferBatchEnforcer },\n  } = environment;\n\n  if (!SpecificActionERC20TransferBatchEnforcer) {\n    throw new Error(\n      'SpecificActionERC20TransferBatchEnforcer not found in environment',\n    );\n  }\n\n  return {\n    enforcer: SpecificActionERC20TransferBatchEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { createTimestampTerms } from '@metamask/delegation-core';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const timestamp = 'timestamp';\n\nexport type TimestampBuilderConfig = {\n  /**\n   * The timestamp after which the delegation is valid in seconds.\n   * Set to 0 to disable this threshold.\n   */\n  afterThreshold: number;\n  /**\n   * The timestamp before which the delegation is valid.\n   * Set to 0 to disable this threshold.\n   */\n  beforeThreshold: number;\n};\n\n/**\n * Builds a caveat struct for the TimestampEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object for the TimestampEnforcer.\n * @returns The Caveat.\n * @throws Error if any of the parameters are invalid.\n */\nexport const timestampBuilder = (\n  environment: DeleGatorEnvironment,\n  config: TimestampBuilderConfig,\n): Caveat => {\n  const { afterThreshold, beforeThreshold } = config;\n\n  const terms = createTimestampTerms({\n    timestampAfterThreshold: afterThreshold,\n    timestampBeforeThreshold: beforeThreshold,\n  });\n\n  const {\n    caveatEnforcers: { TimestampEnforcer },\n  } = environment;\n\n  if (!TimestampEnforcer) {\n    throw new Error('TimestampEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: TimestampEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import { createValueLteTerms } from '@metamask/delegation-core';\n\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport const valueLte = 'valueLte';\n\nexport type ValueLteBuilderConfig = {\n  /**\n   * The maximum value that may be specified when redeeming this delegation.\n   */\n  maxValue: bigint;\n};\n\n/**\n * Builds a caveat struct for ValueLteEnforcer.\n *\n * @param environment - The DeleGator environment.\n * @param config - The configuration object containing the maximum value allowed for the transaction.\n * @returns The Caveat.\n * @throws Error if any of the parameters are invalid.\n */\nexport const valueLteBuilder = (\n  environment: DeleGatorEnvironment,\n  config: ValueLteBuilderConfig,\n): Caveat => {\n  const { maxValue } = config;\n\n  const terms = createValueLteTerms({ maxValue });\n\n  const {\n    caveatEnforcers: { ValueLteEnforcer },\n  } = environment;\n\n  if (!ValueLteEnforcer) {\n    throw new Error('ValueLteEnforcer not found in environment');\n  }\n\n  return {\n    enforcer: ValueLteEnforcer,\n    terms,\n    args: '0x',\n  };\n};\n","import type { DeleGatorEnvironment } from '../types';\nimport {\n  allowedCalldata,\n  allowedCalldataBuilder,\n} from './allowedCalldataBuilder';\nimport { allowedMethods, allowedMethodsBuilder } from './allowedMethodsBuilder';\nimport { allowedTargets, allowedTargetsBuilder } from './allowedTargetsBuilder';\nimport {\n  argsEqualityCheck,\n  argsEqualityCheckBuilder,\n} from './argsEqualityCheckBuilder';\nimport { blockNumber, blockNumberBuilder } from './blockNumberBuilder';\nimport type { CaveatBuilderConfig } from './caveatBuilder';\nimport { CaveatBuilder } from './caveatBuilder';\nimport { deployed, deployedBuilder } from './deployedBuilder';\nimport {\n  erc1155BalanceChange,\n  erc1155BalanceChangeBuilder,\n} from './erc1155BalanceChangeBuilder';\nimport {\n  erc20BalanceChange,\n  erc20BalanceChangeBuilder,\n} from './erc20BalanceChangeBuilder';\nimport {\n  erc20PeriodTransfer,\n  erc20PeriodTransferBuilder,\n} from './erc20PeriodTransferBuilder';\nimport { erc20Streaming, erc20StreamingBuilder } from './erc20StreamingBuilder';\nimport {\n  erc20TransferAmount,\n  erc20TransferAmountBuilder,\n} from './erc20TransferAmountBuilder';\nimport {\n  erc721BalanceChange,\n  erc721BalanceChangeBuilder,\n} from './erc721BalanceChangeBuilder';\nimport { erc721Transfer, erc721TransferBuilder } from './erc721TransferBuilder';\nimport {\n  exactCalldataBatch,\n  exactCalldataBatchBuilder,\n} from './exactCalldataBatchBuilder';\nimport { exactCalldata, exactCalldataBuilder } from './exactCalldataBuilder';\nimport {\n  exactExecutionBatch,\n  exactExecutionBatchBuilder,\n} from './exactExecutionBatchBuilder';\nimport { exactExecution, exactExecutionBuilder } from './exactExecutionBuilder';\nimport { id, idBuilder } from './idBuilder';\nimport { limitedCalls, limitedCallsBuilder } from './limitedCallsBuilder';\nimport {\n  multiTokenPeriod,\n  multiTokenPeriodBuilder,\n} from './multiTokenPeriodBuilder';\nimport {\n  nativeBalanceChange,\n  nativeBalanceChangeBuilder,\n} from './nativeBalanceChangeBuilder';\nimport {\n  nativeTokenPayment,\n  nativeTokenPaymentBuilder,\n} from './nativeTokenPaymentBuilder';\nimport {\n  nativeTokenPeriodTransfer,\n  nativeTokenPeriodTransferBuilder,\n} from './nativeTokenPeriodTransferBuilder';\nimport {\n  nativeTokenStreaming,\n  nativeTokenStreamingBuilder,\n} from './nativeTokenStreamingBuilder';\nimport {\n  nativeTokenTransferAmount,\n  nativeTokenTransferAmountBuilder,\n} from './nativeTokenTransferAmountBuilder';\nimport { nonce, nonceBuilder } from './nonceBuilder';\nimport {\n  ownershipTransfer,\n  ownershipTransferBuilder,\n} from './ownershipTransferBuilder';\nimport { redeemer, redeemerBuilder } from './redeemerBuilder';\nimport {\n  specificActionERC20TransferBatch,\n  specificActionERC20TransferBatchBuilder,\n} from './specificActionERC20TransferBatchBuilder';\nimport { timestamp, timestampBuilder } from './timestampBuilder';\nimport { valueLte, valueLteBuilder } from './valueLteBuilder';\n\n// While we could derive CoreCaveatMap from the createCaveatBuilder function,\n// doing so would significantly complicate type resolution. By explicitly\n// declaring the return type of createCaveatBuilder, we ensure the caveat\n// map remains synchronized with the actual implementation.\ntype CoreCaveatMap = {\n  allowedMethods: typeof allowedMethodsBuilder;\n  allowedTargets: typeof allowedTargetsBuilder;\n  deployed: typeof deployedBuilder;\n  allowedCalldata: typeof allowedCalldataBuilder;\n  erc20BalanceChange: typeof erc20BalanceChangeBuilder;\n  erc721BalanceChange: typeof erc721BalanceChangeBuilder;\n  erc1155BalanceChange: typeof erc1155BalanceChangeBuilder;\n  valueLte: typeof valueLteBuilder;\n  limitedCalls: typeof limitedCallsBuilder;\n  id: typeof idBuilder;\n  nonce: typeof nonceBuilder;\n  timestamp: typeof timestampBuilder;\n  blockNumber: typeof blockNumberBuilder;\n  erc20TransferAmount: typeof erc20TransferAmountBuilder;\n  erc20Streaming: typeof erc20StreamingBuilder;\n  nativeTokenStreaming: typeof nativeTokenStreamingBuilder;\n  erc721Transfer: typeof erc721TransferBuilder;\n  nativeTokenTransferAmount: typeof nativeTokenTransferAmountBuilder;\n  nativeBalanceChange: typeof nativeBalanceChangeBuilder;\n  redeemer: typeof redeemerBuilder;\n  nativeTokenPayment: typeof nativeTokenPaymentBuilder;\n  argsEqualityCheck: typeof argsEqualityCheckBuilder;\n  specificActionERC20TransferBatch: typeof specificActionERC20TransferBatchBuilder;\n  erc20PeriodTransfer: typeof erc20PeriodTransferBuilder;\n  nativeTokenPeriodTransfer: typeof nativeTokenPeriodTransferBuilder;\n  exactCalldataBatch: typeof exactCalldataBatchBuilder;\n  exactCalldata: typeof exactCalldataBuilder;\n  exactExecution: typeof exactExecutionBuilder;\n  exactExecutionBatch: typeof exactExecutionBatchBuilder;\n  multiTokenPeriod: typeof multiTokenPeriodBuilder;\n  ownershipTransfer: typeof ownershipTransferBuilder;\n};\n\n/**\n * A caveat builder type that includes all core caveat types pre-configured.\n * This type represents a fully configured caveat builder with all the standard\n * caveat builders available for use.\n */\nexport type CoreCaveatBuilder = CaveatBuilder<CoreCaveatMap>;\n\ntype ExtractCaveatMapType<TCaveatBuilder extends CaveatBuilder<any>> =\n  TCaveatBuilder extends CaveatBuilder<infer TCaveatMap> ? TCaveatMap : never;\ntype ExtractedCoreMap = ExtractCaveatMapType<CoreCaveatBuilder>;\n\nexport type CaveatConfigurations = {\n  [TType in keyof ExtractedCoreMap]: {\n    type: TType;\n  } & Parameters<ExtractedCoreMap[TType]>[1];\n}[keyof ExtractedCoreMap];\n\nexport type CaveatConfiguration<\n  TCaveatBuilder extends CaveatBuilder<any>,\n  CaveatMap = ExtractCaveatMapType<TCaveatBuilder>,\n> =\n  CaveatMap extends Record<string, (...args: any[]) => any>\n    ? {\n        [TType in keyof CaveatMap]: {\n          type: TType;\n        } & Parameters<CaveatMap[TType]>[1];\n      }[keyof CaveatMap]\n    : never;\n\nexport type CoreCaveatConfiguration = CaveatConfiguration<CoreCaveatBuilder>;\n\n/**\n * Creates a caveat builder with all core caveat types pre-configured.\n *\n * @param environment - The DeleGator environment configuration.\n * @param config - Optional configuration for the caveat builder.\n * @returns A fully configured CoreCaveatBuilder instance with all core caveat types.\n */\nexport const createCaveatBuilder = (\n  environment: DeleGatorEnvironment,\n  config?: CaveatBuilderConfig,\n): CoreCaveatBuilder => {\n  const caveatBuilder = new CaveatBuilder(environment, config)\n    .extend(allowedMethods, allowedMethodsBuilder)\n    .extend(allowedTargets, allowedTargetsBuilder)\n    .extend(deployed, deployedBuilder)\n    .extend(allowedCalldata, allowedCalldataBuilder)\n    .extend(erc20BalanceChange, erc20BalanceChangeBuilder)\n    .extend(erc721BalanceChange, erc721BalanceChangeBuilder)\n    .extend(erc1155BalanceChange, erc1155BalanceChangeBuilder)\n    .extend(valueLte, valueLteBuilder)\n    .extend(limitedCalls, limitedCallsBuilder)\n    .extend(id, idBuilder)\n    .extend(nonce, nonceBuilder)\n    .extend(timestamp, timestampBuilder)\n    .extend(blockNumber, blockNumberBuilder)\n    .extend(erc20TransferAmount, erc20TransferAmountBuilder)\n    .extend(erc20Streaming, erc20StreamingBuilder)\n    .extend(nativeTokenStreaming, nativeTokenStreamingBuilder)\n    .extend(erc721Transfer, erc721TransferBuilder)\n    .extend(nativeTokenTransferAmount, nativeTokenTransferAmountBuilder)\n    .extend(nativeBalanceChange, nativeBalanceChangeBuilder)\n    .extend(redeemer, redeemerBuilder)\n    .extend(nativeTokenPayment, nativeTokenPaymentBuilder)\n    .extend(argsEqualityCheck, argsEqualityCheckBuilder)\n    .extend(\n      specificActionERC20TransferBatch,\n      specificActionERC20TransferBatchBuilder,\n    )\n    .extend(erc20PeriodTransfer, erc20PeriodTransferBuilder)\n    .extend(nativeTokenPeriodTransfer, nativeTokenPeriodTransferBuilder)\n    .extend(exactCalldataBatch, exactCalldataBatchBuilder)\n    .extend(exactCalldata, exactCalldataBuilder)\n    .extend(exactExecution, exactExecutionBuilder)\n    .extend(exactExecutionBatch, exactExecutionBatchBuilder)\n    .extend(multiTokenPeriod, multiTokenPeriodBuilder)\n    .extend(ownershipTransfer, ownershipTransferBuilder);\n\n  return caveatBuilder;\n};\n","import type { DeleGatorEnvironment } from '../../types';\nimport { createCaveatBuilder } from '../coreCaveatBuilder';\nimport type { CoreCaveatBuilder } from '../coreCaveatBuilder';\nimport type {\n  erc20PeriodTransfer,\n  Erc20PeriodTransferBuilderConfig,\n} from '../erc20PeriodTransferBuilder';\n\nexport type Erc20PeriodicScopeConfig = {\n  type: typeof erc20PeriodTransfer;\n} & Erc20PeriodTransferBuilderConfig;\n\n/**\n * Creates a caveat builder configured for ERC20 token periodic transfers with recurring limits.\n *\n * @param environment - The DeleGator environment.\n * @param config - Configuration object containing ERC20 periodic transfer parameters.\n * @returns A configured caveat builder with ERC20 period transfer and value limit caveats.\n * @throws Error if any of the ERC20 periodic transfer parameters are invalid.\n * @throws Error if the environment is not properly configured.\n */\nexport function createErc20PeriodicCaveatBuilder(\n  environment: DeleGatorEnvironment,\n  config: Erc20PeriodicScopeConfig,\n): CoreCaveatBuilder {\n  return createCaveatBuilder(environment)\n    .addCaveat('valueLte', {\n      maxValue: 0n,\n    })\n    .addCaveat('erc20PeriodTransfer', {\n      tokenAddress: config.tokenAddress,\n      periodAmount: config.periodAmount,\n      periodDuration: config.periodDuration,\n      startDate: config.startDate,\n    });\n}\n","import type { DeleGatorEnvironment } from '../../types';\nimport { createCaveatBuilder } from '../coreCaveatBuilder';\nimport type { CoreCaveatBuilder } from '../coreCaveatBuilder';\nimport type {\n  erc20Streaming,\n  Erc20StreamingBuilderConfig,\n} from '../erc20StreamingBuilder';\n\nexport type Erc20StreamingScopeConfig = {\n  type: typeof erc20Streaming;\n} & Erc20StreamingBuilderConfig;\n\n/**\n * Creates a caveat builder configured for ERC20 token streaming with time-based limits.\n *\n * @param environment - The DeleGator environment.\n * @param config - Configuration object containing ERC20 streaming parameters.\n * @returns A configured caveat builder with ERC20 streaming and value limit caveats.\n * @throws Error if any of the ERC20 streaming parameters are invalid.\n * @throws Error if the environment is not properly configured.\n */\nexport function createErc20StreamingCaveatBuilder(\n  environment: DeleGatorEnvironment,\n  config: Erc20StreamingScopeConfig,\n): CoreCaveatBuilder {\n  return createCaveatBuilder(environment)\n    .addCaveat('valueLte', {\n      maxValue: 0n,\n    })\n    .addCaveat('erc20Streaming', {\n      tokenAddress: config.tokenAddress,\n      initialAmount: config.initialAmount,\n      maxAmount: config.maxAmount,\n      amountPerSecond: config.amountPerSecond,\n      startTime: config.startTime,\n    });\n}\n","import type { DeleGatorEnvironment } from '../../types';\nimport { createCaveatBuilder } from '../coreCaveatBuilder';\nimport type { CoreCaveatBuilder } from '../coreCaveatBuilder';\nimport type {\n  erc20TransferAmount,\n  Erc20TransferAmountBuilderConfig,\n} from '../erc20TransferAmountBuilder';\n\nexport type Erc20TransferScopeConfig = {\n  type: typeof erc20TransferAmount;\n} & Erc20TransferAmountBuilderConfig;\n\n/**\n * Creates a caveat builder configured for ERC20 token transfers with amount limits.\n *\n * @param environment - The DeleGator environment.\n * @param config - Configuration object containing ERC20 transfer parameters.\n * @returns A configured caveat builder with ERC20 transfer amount and value limit caveats.\n * @throws Error if any of the ERC20 transfer parameters are invalid.\n * @throws Error if the environment is not properly configured.\n */\nexport function createErc20TransferCaveatBuilder(\n  environment: DeleGatorEnvironment,\n  config: Erc20TransferScopeConfig,\n): CoreCaveatBuilder {\n  return createCaveatBuilder(environment)\n    .addCaveat('valueLte', {\n      maxValue: 0n,\n    })\n    .addCaveat('erc20TransferAmount', {\n      tokenAddress: config.tokenAddress,\n      maxAmount: config.maxAmount,\n    });\n}\n","import { type Hex, isHex, toHex } from 'viem';\n\n/**\n * Checks if two hexadecimal strings are equal, ignoring case sensitivity.\n * @param a - The first hexadecimal string.\n * @param b - The second hexadecimal string.\n * @returns True if the hexadecimal strings are equal, false otherwise.\n */\nexport function isEqualHex(a: Hex, b: Hex): boolean {\n  return isHex(a) && a.toLowerCase() === b.toLowerCase();\n}\n\n/**\n * Recursively converts all members of an object to hexadecimal format.\n * Handles various data types including functions, null, strings, booleans,\n * bigints, arrays, and objects.\n *\n * @param obj - The object to convert to hexadecimal format.\n * @returns The object with all values converted to hexadecimal format.\n */\nexport function deepHexlify(obj: any): any {\n  if (typeof obj === 'function') {\n    return undefined;\n  }\n\n  if (\n    obj === null ||\n    obj === undefined ||\n    typeof obj === 'string' ||\n    typeof obj === 'boolean'\n  ) {\n    return obj;\n  }\n\n  if (typeof obj === 'bigint') {\n    return toHex(obj);\n  }\n\n  if (obj._isBigNumber !== null || typeof obj !== 'object') {\n    return toHex(obj).replace(/^0x0/u, '0x');\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map((member) => deepHexlify(member));\n  }\n\n  return Object.keys(obj).reduce(\n    (set, key) =>\n      Object.assign(Object.assign({}, set), {\n        [key]: deepHexlify(obj[key]),\n      }),\n    {},\n  );\n}\n\n/**\n * Utility function to check if an object has all specified properties defined and not undefined.\n *\n * @template TObject - The type of the object to check.\n * @template TKey - The keys of the properties to check for.\n * @param object - The object to check for the required properties.\n * @param properties - An array of property names to verify on the object.\n * @returns True if all specified properties exist on the object and are not undefined, otherwise false.\n */\nexport const hasProperties = <\n  TObject extends Record<string, any>,\n  TKey extends keyof TObject,\n>(\n  object: TObject,\n  properties: readonly TKey[],\n): object is TObject & Record<TKey, NonNullable<TObject[TKey]>> => {\n  return properties.every(\n    (prop) => prop in object && object[prop] !== undefined,\n  );\n};\n","import type { DeleGatorEnvironment } from '../../types';\nimport { hasProperties } from '../../utils';\nimport { createCaveatBuilder } from '../coreCaveatBuilder';\nimport type { CoreCaveatBuilder } from '../coreCaveatBuilder';\nimport type {\n  erc721Transfer,\n  Erc721TransferBuilderConfig,\n} from '../erc721TransferBuilder';\n\nexport type Erc721ScopeBaseConfig = {\n  type: typeof erc721Transfer;\n};\n\nexport type Erc721ScopeConfig = Erc721ScopeBaseConfig &\n  Erc721TransferBuilderConfig;\n\nconst isErc721TransferConfig = (\n  config: Erc721ScopeBaseConfig,\n): config is Erc721TransferBuilderConfig & Erc721ScopeBaseConfig => {\n  return hasProperties(\n    config as Erc721TransferBuilderConfig & Erc721ScopeBaseConfig,\n    ['tokenAddress', 'tokenId'],\n  );\n};\n\n/**\n * Creates a caveat builder configured for ERC721 unit of authority.\n *\n * @param environment - The DeleGator environment.\n * @param config - Configuration object containing permitted contract and token ID.\n * @returns A configured caveat builder with the specified caveats.\n * @throws Error if any of the required parameters are invalid.\n */\nexport function createErc721CaveatBuilder(\n  environment: DeleGatorEnvironment,\n  config: Erc721ScopeConfig,\n): CoreCaveatBuilder {\n  if (!isErc721TransferConfig(config)) {\n    throw new Error('Invalid ERC721 configuration');\n  }\n\n  const caveatBuilder = createCaveatBuilder(environment).addCaveat(\n    'erc721Transfer',\n    config,\n  );\n\n  return caveatBuilder;\n}\n","import type { DeleGatorEnvironment } from '../../types';\nimport { hasProperties } from '../../utils';\nimport type { AllowedCalldataBuilderConfig } from '../allowedCalldataBuilder';\nimport type { AllowedMethodsBuilderConfig } from '../allowedMethodsBuilder';\nimport type { AllowedTargetsBuilderConfig } from '../allowedTargetsBuilder';\nimport { createCaveatBuilder } from '../coreCaveatBuilder';\nimport type { CoreCaveatBuilder } from '../coreCaveatBuilder';\nimport type { ExactCalldataBuilderConfig } from '../exactCalldataBuilder';\n\ntype FunctionCallScopeBaseConfig = {\n  type: 'functionCall';\n};\n\nexport type FunctionCallScopeConfig = FunctionCallScopeBaseConfig &\n  AllowedTargetsBuilderConfig &\n  AllowedMethodsBuilderConfig & {\n    allowedCalldata?: AllowedCalldataBuilderConfig[];\n    exactCalldata?: ExactCalldataBuilderConfig;\n  };\n\nconst isFunctionCallConfig = (\n  config: FunctionCallScopeConfig,\n): config is FunctionCallScopeConfig => {\n  return hasProperties(config, ['targets', 'selectors']);\n};\n\n/**\n * Creates a caveat builder configured for function call unit of authority.\n *\n * @param environment - The DeleGator environment.\n * @param config - Configuration object containing allowed targets, methods, and optionally calldata.\n * @returns A configured caveat builder with the specified caveats.\n * @throws Error if any of the required parameters are invalid.\n * @throws Error if both allowedCalldata and exactCalldata are provided simultaneously.\n */\nexport function createFunctionCallCaveatBuilder(\n  environment: DeleGatorEnvironment,\n  config: FunctionCallScopeConfig,\n): CoreCaveatBuilder {\n  const { targets, selectors, allowedCalldata, exactCalldata } = config;\n\n  if (!isFunctionCallConfig(config)) {\n    throw new Error('Invalid Function Call configuration');\n  }\n\n  if (allowedCalldata && allowedCalldata.length > 0 && exactCalldata) {\n    throw new Error(\n      'Cannot specify both allowedCalldata and exactCalldata. Please use only one calldata restriction type.',\n    );\n  }\n\n  const caveatBuilder = createCaveatBuilder(environment)\n    .addCaveat('allowedTargets', { targets })\n    .addCaveat('allowedMethods', { selectors });\n\n  if (allowedCalldata && allowedCalldata.length > 0) {\n    allowedCalldata.forEach((calldataConfig) => {\n      caveatBuilder.addCaveat('allowedCalldata', calldataConfig);\n    });\n  } else if (exactCalldata) {\n    caveatBuilder.addCaveat('exactCalldata', exactCalldata);\n  }\n\n  return caveatBuilder;\n}\n","import type { DeleGatorEnvironment } from '../../types';\nimport type { AllowedCalldataBuilderConfig } from '../allowedCalldataBuilder';\nimport { createCaveatBuilder } from '../coreCaveatBuilder';\nimport type { CoreCaveatBuilder } from '../coreCaveatBuilder';\nimport type { ExactCalldataBuilderConfig } from '../exactCalldataBuilder';\nimport type {\n  nativeTokenPeriodTransfer,\n  NativeTokenPeriodTransferBuilderConfig,\n} from '../nativeTokenPeriodTransferBuilder';\n\nexport type NativeTokenPeriodicScopeConfig = {\n  type: typeof nativeTokenPeriodTransfer;\n  allowedCalldata?: AllowedCalldataBuilderConfig[];\n  exactCalldata?: ExactCalldataBuilderConfig;\n} & NativeTokenPeriodTransferBuilderConfig;\n\n/**\n * Creates a caveat builder configured for native token periodic transfers with recurring limits.\n *\n * @param environment - The DeleGator environment.\n * @param config - Configuration object containing native token periodic transfer parameters.\n * @returns A configured caveat builder with native token period transfer and exact calldata caveats.\n * @throws Error if any of the native token periodic transfer parameters are invalid.\n * @throws Error if both allowedCalldata and exactCalldata are provided simultaneously.\n * @throws Error if the environment is not properly configured.\n */\nexport function createNativeTokenPeriodicCaveatBuilder(\n  environment: DeleGatorEnvironment,\n  config: NativeTokenPeriodicScopeConfig,\n): CoreCaveatBuilder {\n  const {\n    periodAmount,\n    periodDuration,\n    startDate,\n    allowedCalldata,\n    exactCalldata,\n  } = config;\n\n  if (allowedCalldata && allowedCalldata.length > 0 && exactCalldata) {\n    throw new Error(\n      'Cannot specify both allowedCalldata and exactCalldata. Please use only one calldata restriction type.',\n    );\n  }\n\n  const caveatBuilder = createCaveatBuilder(environment);\n\n  // Add calldata restrictions\n  if (allowedCalldata && allowedCalldata.length > 0) {\n    allowedCalldata.forEach((calldataConfig) => {\n      caveatBuilder.addCaveat('allowedCalldata', calldataConfig);\n    });\n  } else if (exactCalldata) {\n    caveatBuilder.addCaveat('exactCalldata', exactCalldata);\n  } else {\n    // Default behavior: only allow empty calldata\n    caveatBuilder.addCaveat('exactCalldata', {\n      calldata: '0x',\n    });\n  }\n\n  // Add native token period transfer restriction\n  caveatBuilder.addCaveat('nativeTokenPeriodTransfer', {\n    periodAmount,\n    periodDuration,\n    startDate,\n  });\n\n  return caveatBuilder;\n}\n","import type { DeleGatorEnvironment } from '../../types';\nimport type { AllowedCalldataBuilderConfig } from '../allowedCalldataBuilder';\nimport { createCaveatBuilder } from '../coreCaveatBuilder';\nimport type { CoreCaveatBuilder } from '../coreCaveatBuilder';\nimport type { ExactCalldataBuilderConfig } from '../exactCalldataBuilder';\nimport type {\n  nativeTokenStreaming,\n  NativeTokenStreamingBuilderConfig,\n} from '../nativeTokenStreamingBuilder';\n\nexport type NativeTokenStreamingScopeConfig = {\n  type: typeof nativeTokenStreaming;\n  allowedCalldata?: AllowedCalldataBuilderConfig[];\n  exactCalldata?: ExactCalldataBuilderConfig;\n} & NativeTokenStreamingBuilderConfig;\n\n/**\n * Creates a caveat builder configured for native token streaming with time-based limits.\n *\n * @param environment - The DeleGator environment.\n * @param config - Configuration object containing native token streaming parameters.\n * @returns A configured caveat builder with native token streaming and exact calldata caveats.\n * @throws Error if any of the native token streaming parameters are invalid.\n * @throws Error if both allowedCalldata and exactCalldata are provided simultaneously.\n * @throws Error if the environment is not properly configured.\n */\nexport function createNativeTokenStreamingCaveatBuilder(\n  environment: DeleGatorEnvironment,\n  config: NativeTokenStreamingScopeConfig,\n): CoreCaveatBuilder {\n  const {\n    initialAmount,\n    maxAmount,\n    amountPerSecond,\n    startTime,\n    allowedCalldata,\n    exactCalldata,\n  } = config;\n\n  if (allowedCalldata && allowedCalldata.length > 0 && exactCalldata) {\n    throw new Error(\n      'Cannot specify both allowedCalldata and exactCalldata. Please use only one calldata restriction type.',\n    );\n  }\n\n  const caveatBuilder = createCaveatBuilder(environment);\n\n  // Add calldata restrictions\n  if (allowedCalldata && allowedCalldata.length > 0) {\n    allowedCalldata.forEach((calldataConfig) => {\n      caveatBuilder.addCaveat('allowedCalldata', calldataConfig);\n    });\n  } else if (exactCalldata) {\n    caveatBuilder.addCaveat('exactCalldata', exactCalldata);\n  } else {\n    // Default behavior: only allow empty calldata\n    caveatBuilder.addCaveat('exactCalldata', {\n      calldata: '0x',\n    });\n  }\n\n  // Add native token streaming restriction\n  caveatBuilder.addCaveat('nativeTokenStreaming', {\n    initialAmount,\n    maxAmount,\n    amountPerSecond,\n    startTime,\n  });\n\n  return caveatBuilder;\n}\n","import type { DeleGatorEnvironment } from '../../types';\nimport type { AllowedCalldataBuilderConfig } from '../allowedCalldataBuilder';\nimport { createCaveatBuilder } from '../coreCaveatBuilder';\nimport type { CoreCaveatBuilder } from '../coreCaveatBuilder';\nimport type { ExactCalldataBuilderConfig } from '../exactCalldataBuilder';\nimport type {\n  nativeTokenTransferAmount,\n  NativeTokenTransferAmountBuilderConfig,\n} from '../nativeTokenTransferAmountBuilder';\n\nexport type NativeTokenTransferScopeConfig = {\n  type: typeof nativeTokenTransferAmount;\n  allowedCalldata?: AllowedCalldataBuilderConfig[];\n  exactCalldata?: ExactCalldataBuilderConfig;\n} & NativeTokenTransferAmountBuilderConfig;\n\n/**\n * Creates a caveat builder configured for native token transfers with amount limits.\n *\n * @param environment - The DeleGator environment.\n * @param config - Configuration object containing native token transfer parameters.\n * @returns A configured caveat builder with native token transfer amount and exact calldata caveats.\n * @throws Error if any of the native token transfer parameters are invalid.\n * @throws Error if both allowedCalldata and exactCalldata are provided simultaneously.\n * @throws Error if the environment is not properly configured.\n */\nexport function createNativeTokenTransferCaveatBuilder(\n  environment: DeleGatorEnvironment,\n  config: NativeTokenTransferScopeConfig,\n): CoreCaveatBuilder {\n  const { maxAmount, allowedCalldata, exactCalldata } = config;\n\n  if (allowedCalldata && allowedCalldata.length > 0 && exactCalldata) {\n    throw new Error(\n      'Cannot specify both allowedCalldata and exactCalldata. Please use only one calldata restriction type.',\n    );\n  }\n\n  const caveatBuilder = createCaveatBuilder(environment);\n\n  // Add calldata restrictions\n  if (allowedCalldata && allowedCalldata.length > 0) {\n    allowedCalldata.forEach((calldataConfig) => {\n      caveatBuilder.addCaveat('allowedCalldata', calldataConfig);\n    });\n  } else if (exactCalldata) {\n    caveatBuilder.addCaveat('exactCalldata', exactCalldata);\n  } else {\n    // Default behavior: only allow empty calldata\n    caveatBuilder.addCaveat('exactCalldata', {\n      calldata: '0x',\n    });\n  }\n\n  // Add native token transfer amount restriction\n  caveatBuilder.addCaveat('nativeTokenTransferAmount', {\n    maxAmount,\n  });\n\n  return caveatBuilder;\n}\n","import type { DeleGatorEnvironment } from '../../types';\nimport { hasProperties } from '../../utils';\nimport { createCaveatBuilder } from '../coreCaveatBuilder';\nimport type { CoreCaveatBuilder } from '../coreCaveatBuilder';\nimport type {\n  ownershipTransfer,\n  OwnershipTransferBuilderConfig,\n} from '../ownershipTransferBuilder';\n\ntype OwnershipScopeBaseConfig = {\n  type: typeof ownershipTransfer;\n};\n\nexport type OwnershipScopeConfig = OwnershipScopeBaseConfig &\n  OwnershipTransferBuilderConfig;\n\nconst isOwnershipTransferConfig = (\n  config: OwnershipScopeConfig,\n): config is OwnershipTransferBuilderConfig & OwnershipScopeBaseConfig => {\n  return hasProperties(\n    config as OwnershipTransferBuilderConfig & OwnershipScopeBaseConfig,\n    ['contractAddress'],\n  );\n};\n\n/**\n * Creates a caveat builder configured for ownership transfer unit of authority.\n *\n * @param environment - The DeleGator environment.\n * @param config - Configuration object containing the target contract.\n * @returns A configured caveat builder with the specified caveats.\n * @throws Error if any of the required parameters are invalid.\n */\nexport function createOwnershipCaveatBuilder(\n  environment: DeleGatorEnvironment,\n  config: OwnershipScopeConfig,\n): CoreCaveatBuilder {\n  if (!isOwnershipTransferConfig(config)) {\n    throw new Error('Invalid ownership transfer configuration');\n  }\n\n  const caveatBuilder = createCaveatBuilder(environment).addCaveat(\n    'ownershipTransfer',\n    config,\n  );\n\n  return caveatBuilder;\n}\n","import {\n  type Erc20PeriodicScopeConfig,\n  createErc20PeriodicCaveatBuilder,\n} from './erc20PeriodicScope';\nimport {\n  type Erc20StreamingScopeConfig,\n  createErc20StreamingCaveatBuilder,\n} from './erc20StreamingScope';\nimport {\n  type Erc20TransferScopeConfig,\n  createErc20TransferCaveatBuilder,\n} from './erc20TransferScope';\nimport {\n  type Erc721ScopeConfig,\n  createErc721CaveatBuilder,\n} from './erc721Scope';\nimport {\n  createFunctionCallCaveatBuilder,\n  type FunctionCallScopeConfig,\n} from './functionCallScope';\nimport {\n  type NativeTokenPeriodicScopeConfig,\n  createNativeTokenPeriodicCaveatBuilder,\n} from './nativeTokenPeriodicScope';\nimport {\n  type NativeTokenStreamingScopeConfig,\n  createNativeTokenStreamingCaveatBuilder,\n} from './nativeTokenStreamingScope';\nimport {\n  type NativeTokenTransferScopeConfig,\n  createNativeTokenTransferCaveatBuilder,\n} from './nativeTokenTransferScope';\nimport {\n  createOwnershipCaveatBuilder,\n  type OwnershipScopeConfig,\n} from './ownershipScope';\nimport type { DeleGatorEnvironment } from '../../types';\n// Import caveat builder name constants\nimport { erc20PeriodTransfer } from '../erc20PeriodTransferBuilder';\nimport { erc20Streaming } from '../erc20StreamingBuilder';\nimport { erc20TransferAmount } from '../erc20TransferAmountBuilder';\nimport { erc721Transfer } from '../erc721TransferBuilder';\nimport { nativeTokenPeriodTransfer } from '../nativeTokenPeriodTransferBuilder';\nimport { nativeTokenStreaming } from '../nativeTokenStreamingBuilder';\nimport { nativeTokenTransferAmount } from '../nativeTokenTransferAmountBuilder';\nimport { ownershipTransfer } from '../ownershipTransferBuilder';\n\nexport type ScopeConfig =\n  | Erc20TransferScopeConfig\n  | Erc20StreamingScopeConfig\n  | Erc20PeriodicScopeConfig\n  | NativeTokenTransferScopeConfig\n  | NativeTokenStreamingScopeConfig\n  | NativeTokenPeriodicScopeConfig\n  | Erc721ScopeConfig\n  | OwnershipScopeConfig\n  | FunctionCallScopeConfig;\n\nexport const createCaveatBuilderFromScope = (\n  environment: DeleGatorEnvironment,\n  scopeConfig: ScopeConfig,\n) => {\n  switch (scopeConfig.type) {\n    case erc20TransferAmount:\n      return createErc20TransferCaveatBuilder(environment, scopeConfig);\n    case erc20Streaming:\n      return createErc20StreamingCaveatBuilder(environment, scopeConfig);\n    case erc20PeriodTransfer:\n      return createErc20PeriodicCaveatBuilder(environment, scopeConfig);\n    case nativeTokenTransferAmount:\n      return createNativeTokenTransferCaveatBuilder(environment, scopeConfig);\n    case nativeTokenStreaming:\n      return createNativeTokenStreamingCaveatBuilder(environment, scopeConfig);\n    case nativeTokenPeriodTransfer:\n      return createNativeTokenPeriodicCaveatBuilder(environment, scopeConfig);\n    case erc721Transfer:\n      return createErc721CaveatBuilder(environment, scopeConfig);\n    case ownershipTransfer:\n      return createOwnershipCaveatBuilder(environment, scopeConfig);\n    case 'functionCall':\n      return createFunctionCallCaveatBuilder(environment, scopeConfig);\n    default:\n      // eslint-disable-next-line no-case-declarations\n      const exhaustivenessCheck: never = scopeConfig;\n      throw new Error(\n        `Invalid scope type: ${(exhaustivenessCheck as { type: string }).type}`,\n      );\n  }\n};\n","import type { CaveatBuilder } from './caveatBuilder';\nimport type { CoreCaveatConfiguration } from './coreCaveatBuilder';\nimport { createCaveatBuilderFromScope, type ScopeConfig } from './scope';\nimport type { Caveat, DeleGatorEnvironment } from '../types';\n\nexport type Caveats = CaveatBuilder | (Caveat | CoreCaveatConfiguration)[];\n\n/**\n * Resolves the array of Caveat from a Caveats argument.\n * @param config - The configuration for the caveat builder.\n * @param config.environment - The environment to be used for the caveat builder.\n * @param config.scope - The scope to be used for the caveat builder.\n * @param config.caveats - The caveats to be resolved, which can be either a CaveatBuilder or an array of Caveat or CaveatConfiguration. Optional - if not provided, only scope caveats will be used.\n * @returns The resolved array of caveats.\n */\nexport const resolveCaveats = ({\n  environment,\n  scope,\n  caveats,\n}: {\n  environment: DeleGatorEnvironment;\n  scope: ScopeConfig;\n  caveats?: Caveats;\n}) => {\n  const scopeCaveatBuilder = createCaveatBuilderFromScope(environment, scope);\n\n  if (caveats) {\n    if ('build' in caveats && typeof caveats.build === 'function') {\n      (caveats as CaveatBuilder).build().forEach((caveat) => {\n        scopeCaveatBuilder.addCaveat(caveat);\n      });\n    } else if (Array.isArray(caveats)) {\n      caveats.forEach((caveat) => {\n        try {\n          if ('type' in caveat) {\n            const { type, ...config } = caveat;\n            scopeCaveatBuilder.addCaveat(type, config);\n          } else {\n            scopeCaveatBuilder.addCaveat(caveat);\n          }\n        } catch (error) {\n          throw new Error(`Invalid caveat: ${(error as Error).message}`);\n        }\n      });\n    }\n  }\n\n  return scopeCaveatBuilder.build();\n};\n","import {\n  type Hex,\n  encodePacked,\n  encodeAbiParameters,\n  parseAbiParameters,\n  keccak256,\n  toHex,\n} from 'viem';\n\nimport type { Caveat } from './types';\n\nexport const CAVEAT_ABI_TYPE_COMPONENTS = [\n  { type: 'address', name: 'enforcer' },\n  { type: 'bytes', name: 'terms' },\n  { type: 'bytes', name: 'args' },\n];\n\nexport const CAVEAT_TYPEHASH: Hex = keccak256(\n  toHex('Caveat(address enforcer,bytes terms)'),\n);\n\n/**\n * Calculates the hash of a single Caveat.\n * @param input - The Caveat data.\n * @returns The keccak256 hash of the encoded Caveat packet.\n */\nexport const getCaveatPacketHash = (input: Caveat): Hex => {\n  const encoded = encodeAbiParameters(\n    parseAbiParameters('bytes32, address, bytes32'),\n    [CAVEAT_TYPEHASH, input.enforcer, keccak256(input.terms)],\n  );\n  return keccak256(encoded);\n};\n\n/**\n * Calculates the hash of an array of Caveats.\n * @param input - The array of Caveats.\n * @returns The keccak256 hash of the encoded Caveat array packet.\n */\nexport const getCaveatArrayPacketHash = (input: Caveat[]): Hex => {\n  let encoded: Hex = '0x';\n\n  for (const caveat of input) {\n    const caveatPacketHash = getCaveatPacketHash(caveat);\n    encoded = encodePacked(['bytes', 'bytes32'], [encoded, caveatPacketHash]);\n  }\n  return keccak256(encoded);\n};\n\n/**\n * Creates a caveat.\n * @param enforcer - The contract that guarantees the caveat is upheld.\n * @param terms - The data that the enforcer will use to verify the caveat (unique per enforcer).\n * @param args - Additional arguments for the caveat (optional).\n * @returns A Caveat.\n */\nexport const createCaveat = (\n  enforcer: Hex,\n  terms: Hex,\n  args: Hex = '0x',\n): Caveat => ({\n  enforcer,\n  terms,\n  args,\n});\n","import {\n  encodeDelegations as encodeDelegationsCore,\n  decodeDelegations as decodeDelegationsCore,\n  hashDelegation,\n  ANY_BENEFICIARY,\n  DELEGATION_TYPEHASH,\n  CAVEAT_TYPEHASH,\n  ROOT_AUTHORITY,\n} from '@metamask/delegation-core';\nimport { hashMessage, toBytes, toHex, getAddress } from 'viem';\nimport type { TypedData, AbiParameter, Address, Hex } from 'viem';\nimport { signTypedData } from 'viem/accounts';\n\nimport { type Caveats, resolveCaveats } from './caveatBuilder';\nimport type { ScopeConfig } from './caveatBuilder/scope';\nimport { CAVEAT_ABI_TYPE_COMPONENTS } from './caveats';\nimport type { Delegation, DeleGatorEnvironment } from './types';\n\nexport {\n  ANY_BENEFICIARY,\n  DELEGATION_TYPEHASH,\n  CAVEAT_TYPEHASH,\n  ROOT_AUTHORITY,\n};\n\n/**\n * The ABI type components of a Delegation.\n */\nexport const DELEGATION_ABI_TYPE_COMPONENTS = [\n  { type: 'address', name: 'delegate' },\n  { type: 'address', name: 'delegator' },\n  { type: 'bytes32', name: 'authority' },\n  { type: 'tuple[]', name: 'caveats', components: CAVEAT_ABI_TYPE_COMPONENTS },\n  { type: 'uint256', name: 'salt' },\n  { type: 'bytes', name: 'signature' },\n];\n\n/**\n * Converts a delegation to a delegation struct.\n * @param delegation - The delegation to convert.\n * @returns The delegation struct.\n */\nexport const toDelegationStruct = (\n  delegation: Delegation,\n): DelegationStruct => {\n  const caveats = delegation.caveats.map((caveat) => ({\n    enforcer: getAddress(caveat.enforcer),\n    terms: caveat.terms,\n    args: caveat.args,\n  }));\n\n  const salt = delegation.salt === '0x' ? 0n : BigInt(delegation.salt);\n\n  return {\n    delegate: getAddress(delegation.delegate),\n    delegator: getAddress(delegation.delegator),\n    authority:\n      delegation.authority === undefined\n        ? ROOT_AUTHORITY\n        : delegation.authority,\n    caveats,\n    salt,\n    signature: delegation.signature,\n  };\n};\n\n/**\n * Converts a DelegationStruct to a Delegation.\n * The Delegation type is used for off-chain operations and has a hex string salt.\n * @param delegationStruct - The delegation struct to convert\n * @returns The converted delegation with a hex string salt\n */\n\nexport const toDelegation = (\n  delegationStruct: DelegationStruct,\n): Delegation => {\n  return {\n    ...delegationStruct,\n    salt: toHex(delegationStruct.salt),\n  };\n};\n\n/**\n * Represents a DelegationStruct as defined in the Delegation Framework.\n * This is distinguished from the Delegation type by requiring the salt to be a bigint\n * instead of a Hex string, which is useful for on-chain operations and EIP-712 signing.\n */\nexport type DelegationStruct = Omit<Delegation, 'salt'> & {\n  salt: bigint;\n};\n\n/**\n * ABI Encodes an array of delegations.\n * @param delegations - The delegations to encode.\n * @returns The encoded delegations.\n */\nexport const encodeDelegations = (delegations: Delegation[]): Hex => {\n  const delegationStructs = delegations.map(toDelegationStruct);\n\n  return encodeDelegationsCore(delegationStructs);\n};\n\n/**\n * Abi encodes permission contexts.\n * @param delegations - The delegation chains to encode.\n * @returns The encoded permission contexts.\n */\nexport const encodePermissionContexts = (delegations: Delegation[][]) => {\n  const encodedDelegations = delegations.map((delegationChain) =>\n    encodeDelegations(delegationChain),\n  );\n\n  return encodedDelegations;\n};\n\n/**\n * Decodes an array of delegations from its ABI-encoded representation.\n * @param encoded - The hex-encoded delegation array to decode.\n * @returns An array of decoded delegations.\n */\nexport const decodeDelegations = (encoded: Hex): Delegation[] => {\n  // decodeDelegationsCore returns DelegationStruct, so we need to map it back to Delegation\n  return decodeDelegationsCore(encoded).map(toDelegation);\n};\n\n/**\n * Decodes an array of encoded permission contexts into an array of delegation chains.\n * @param encoded - The hex-encoded permission context to decode.\n * @returns An array of decoded delegations.\n */\nexport const decodePermissionContexts = (encoded: Hex[]): Delegation[][] => {\n  const delegationChains = encoded.map(decodeDelegations);\n\n  return delegationChains;\n};\n\n/**\n * TypedData to be used when signing a Delegation. Delegation value for `signature` and Caveat values for `args` are omitted as they cannot be known at signing time.\n */\nexport const SIGNABLE_DELEGATION_TYPED_DATA: TypedData = {\n  Caveat: [\n    { name: 'enforcer', type: 'address' },\n    { name: 'terms', type: 'bytes' },\n  ],\n  Delegation: [\n    { name: 'delegate', type: 'address' },\n    { name: 'delegator', type: 'address' },\n    { name: 'authority', type: 'bytes32' },\n    { name: 'caveats', type: 'Caveat[]' },\n    { name: 'salt', type: 'uint256' },\n  ],\n} as const;\n\n/**\n * The ABI type for a full delegation.\n */\nexport const DELEGATION_ARRAY_ABI_TYPE: AbiParameter = {\n  type: 'tuple[]',\n  components: DELEGATION_ABI_TYPE_COMPONENTS,\n} as const;\n\n/**\n * Prepares a delegation hash for passkey signing.\n * @param delegationHash - The delegation hash to prepare.\n * @returns The prepared hash for passkey signing.\n */\nexport const prepDelegationHashForPasskeySign = (delegationHash: Hex) => {\n  return hashMessage({\n    raw: toBytes(delegationHash),\n  });\n};\n\n/**\n * Gets a delegation hash offchain.\n * @param input - The delegation to get the hash for.\n * @returns The hash of the delegation parameters.\n */\nexport const getDelegationHashOffchain = (input: Delegation): Hex => {\n  const delegationStruct = toDelegationStruct(input);\n\n  return hashDelegation(delegationStruct);\n};\n\ntype BaseCreateDelegationOptions = {\n  environment: DeleGatorEnvironment;\n  scope: ScopeConfig;\n  from: Hex;\n  caveats?: Caveats;\n  parentDelegation?: Delegation | Hex;\n  salt?: Hex;\n};\n\n/**\n * Options for creating a specific delegation\n */\nexport type CreateDelegationOptions = BaseCreateDelegationOptions & {\n  to: Hex;\n};\n\n/**\n * Options for creating an open delegation\n */\nexport type CreateOpenDelegationOptions = BaseCreateDelegationOptions;\n\n/**\n * Resolves the authority for a delegation based on the parent delegation.\n * @param parentDelegation - The parent delegation or its hash.\n * @returns The resolved authority hash.\n */\nexport const resolveAuthority = (parentDelegation?: Delegation | Hex): Hex => {\n  if (!parentDelegation) {\n    return ROOT_AUTHORITY;\n  }\n\n  if (typeof parentDelegation === 'string') {\n    return parentDelegation;\n  }\n\n  return getDelegationHashOffchain(parentDelegation);\n};\n\n/**\n * Creates a delegation with specific delegate.\n * @param options - The options for creating the delegation.\n * @returns The created delegation data structure.\n */\nexport const createDelegation = (\n  options: CreateDelegationOptions,\n): Delegation => {\n  return {\n    delegate: options.to,\n    delegator: options.from,\n    authority: resolveAuthority(options.parentDelegation),\n    caveats: resolveCaveats(options),\n    salt: options.salt ?? '0x',\n    signature: '0x',\n  };\n};\n\n/**\n * Creates an open delegation that can be redeemed by any delegate.\n * @param options - The options for creating the open delegation.\n * @returns The created delegation data structure.\n */\nexport const createOpenDelegation = (\n  options: CreateOpenDelegationOptions,\n): Delegation => {\n  return {\n    delegate: ANY_BENEFICIARY,\n    delegator: options.from,\n    authority: resolveAuthority(options.parentDelegation),\n    caveats: resolveCaveats(options),\n    salt: options.salt ?? '0x',\n    signature: '0x',\n  };\n};\n\n/**\n * Prepares typed data for delegation signing (internal helper function).\n * @param params - The parameters for preparing the typed data.\n * @param params.delegation - The delegation to prepare for signing.\n * @param params.delegationManager - The address of the delegation manager contract.\n * @param params.chainId - The chain ID for the signature.\n * @param params.name - The name of the contract.\n * @param params.version - The version of the contract.\n * @param params.allowInsecureUnrestrictedDelegation - Whether to allow insecure unrestricted delegation.\n * @returns The typed data parameters ready for signing.\n * @internal\n */\nexport const prepareSignDelegationTypedData = ({\n  delegation,\n  delegationManager,\n  chainId,\n  name = 'DelegationManager',\n  version = '1',\n  allowInsecureUnrestrictedDelegation = false,\n}: {\n  delegation: Omit<Delegation, 'signature'>;\n  delegationManager: Address;\n  chainId: number;\n  name?: string;\n  version?: string;\n  allowInsecureUnrestrictedDelegation?: boolean;\n}) => {\n  const delegationStruct = toDelegationStruct({\n    ...delegation,\n    signature: '0x',\n  });\n\n  if (\n    delegationStruct.caveats.length === 0 &&\n    !allowInsecureUnrestrictedDelegation\n  ) {\n    throw new Error(\n      'No caveats found. If you definitely want to sign a delegation without caveats, set `allowInsecureUnrestrictedDelegation` to `true`.',\n    );\n  }\n\n  return {\n    domain: {\n      chainId,\n      name,\n      version,\n      verifyingContract: delegationManager,\n    },\n    types: SIGNABLE_DELEGATION_TYPED_DATA,\n    primaryType: 'Delegation' as const,\n    message: delegationStruct,\n  };\n};\n\n/**\n * Signs a delegation using a private key.\n * @param params - The parameters for signing the delegation.\n * @param params.privateKey - The private key to use for signing.\n * @param params.delegation - The delegation to sign.\n * @param params.delegationManager - The address of the delegation manager contract.\n * @param params.chainId - The chain ID for the signature.\n * @param params.name - The name of the contract.\n * @param params.version - The version of the contract.\n * @param params.allowInsecureUnrestrictedDelegation - Whether to allow insecure unrestricted delegation.\n * @returns The signed delegation.\n */\nexport const signDelegation = async ({\n  privateKey,\n  delegation,\n  delegationManager,\n  chainId,\n  name = 'DelegationManager',\n  version = '1',\n  allowInsecureUnrestrictedDelegation = false,\n}: {\n  privateKey: Hex;\n  delegation: Omit<Delegation, 'signature'>;\n  delegationManager: Address;\n  chainId: number;\n  name?: string;\n  version?: string;\n  allowInsecureUnrestrictedDelegation?: boolean;\n}) => {\n  const typedData = prepareSignDelegationTypedData({\n    delegation,\n    delegationManager,\n    chainId,\n    name,\n    version,\n    allowInsecureUnrestrictedDelegation,\n  });\n\n  return signTypedData({\n    privateKey,\n    ...typedData,\n  });\n};\n"],"names":["BalanceChangeType","isHex","concat","concat","isHex","concat","toHex","concat","isAddress","isHex","isAddress","isAddress","isAddress","encodePacked","isAddress","encodePacked","concat","isAddress","toHex","isAddress","encodePacked","isAddress","encodePacked","isAddress","toHex","concat","isAddress","encodeAbiParameters","isAddress","isAddress","concat","toHex","toHex","toHex","pad","concat","isAddress","pad","toHex","isAddress","encodePacked","isAddress","encodePacked","encodePacked","isAddress","encodePacked","isAddress","concat","isAddress","concat","isAddress","toHex","isHex","toHex","allowedCalldata","exactCalldata","allowedCalldata","exactCalldata","allowedCalldata","exactCalldata","allowedCalldata","exactCalldata","encodePacked","encodeAbiParameters","toHex","CAVEAT_TYPEHASH","toHex","toHex"],"mappings":"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"}},
    {"offset": {"line": 1550, "column": 0}, "map": {"version":3,"sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/utils.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DeleGatorCore/read.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DeleGatorCore/methods/getDelegationManager.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DeleGatorCore/methods/getDeposit.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DeleGatorCore/methods/getEntryPoint.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DeleGatorCore/methods/getNonce.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DeleGatorCore/methods/getProxyImplementation.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DeleGatorCore/methods/getProxyVersion.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DeleGatorCore/methods/isValidSignature.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/HybridDeleGator/methods/initialize.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/HybridDeleGator/encode.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/HybridDeleGator/methods/addKey.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/HybridDeleGator/methods/reinitialize.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/HybridDeleGator/methods/removeKey.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/HybridDeleGator/methods/updateSigners.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/MultiSigDeleGator/methods/initialize.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/MultiSigDeleGator/encode.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/MultiSigDeleGator/methods/addSigner.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/MultiSigDeleGator/methods/reinitialize.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/MultiSigDeleGator/methods/removeSigner.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/MultiSigDeleGator/methods/replaceSigner.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/MultiSigDeleGator/methods/updateMultiSigParameters.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/MultiSigDeleGator/methods/updateThreshold.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/SimpleFactory/methods/create2Deploy.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/SimpleFactory/encode.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DeleGatorCore/methods/execute.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DeleGatorCore/methods/executeWithMode.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DeleGatorCore/encode.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DeleGatorCore/methods/disableDelegation.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DeleGatorCore/methods/enableDelegation.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DeleGatorCore/methods/upgradeToAndCall.ts"],"sourcesContent":["import { ERC1967Proxy } from '@metamask/delegation-abis';\nimport type { Abi, Address, Client, Hex } from 'viem';\nimport { encodeDeployData } from 'viem';\nimport { getCode } from 'viem/actions';\n\nimport { getProxyImplementation } from './DeleGatorCore/read';\n\n// Where a function signature is duplicated across contracts, we need to narrow\n// the ABI type passed as the `simulateContract` generic argument. Without this,\n// the `simulate()` return type would not match, despite being functionally\n// identical.\nexport type NarrowAbiToFunction<\n  TAbi extends Abi,\n  FunctionName extends string,\n> = [\n  Extract<\n    TAbi[number],\n    {\n      type: 'function';\n      name: FunctionName;\n    }\n  >[],\n];\n\n/**\n * Checks if a contract is deployed at the given address.\n *\n * @param options - The options for checking contract deployment.\n * @param options.client - The client to use for the query.\n * @param options.contractAddress - The address to check for contract deployment.\n * @returns A boolean indicating whether a contract is deployed at the address.\n * @description This function checks if there is actual bytecode at the provided contract address.\n */\nexport async function isContractDeployed({\n  client,\n  contractAddress,\n}: {\n  client: Client;\n  contractAddress: Address;\n}): Promise<boolean> {\n  const code = await getCode(client, {\n    address: contractAddress,\n  });\n  return Boolean(code) && code !== '0x';\n}\n\n/**\n * Checks if a proxy contract at the given address points to the expected implementation.\n *\n * @param options - The options for checking the implementation.\n * @param options.client - The client to use for the query.\n * @param options.contractAddress - The address of the proxy contract.\n * @param options.expectedImplementationAddress - The address that the implementation should match.\n * @returns A boolean indicating whether the implementation matches the expected one.\n * @description This function verifies both that the contract exists and that its implementation address matches.\n */\nexport async function isImplementationExpected({\n  client,\n  contractAddress,\n  expectedImplementationAddress,\n}: {\n  client: Client;\n  contractAddress: Address;\n  expectedImplementationAddress: Address;\n}): Promise<boolean> {\n  if (!(await isContractDeployed({ client, contractAddress }))) {\n    return false;\n  }\n\n  const implementationAddress = await getProxyImplementation({\n    client,\n    contractAddress,\n  });\n\n  return implementationAddress === expectedImplementationAddress;\n}\n\n/**\n * Encodes the \"creation code\" for an ERC1967Proxy contract that will be deployed via CREATE2 with the given implementation and initialization code.\n *\n * @param options - The options for encoding the proxy creation code.\n * @param options.implementationAddress - The address of the implementation contract for the proxy to use.\n * @param options.initcode - The calldata for the initialization function of the implementation contract.\n * @returns The encoded creation code for the proxy.\n * @description This function prepares the deployment bytecode for an ERC1967 proxy pointing to the given implementation.\n */\nexport const encodeProxyCreationCode = ({\n  implementationAddress,\n  initcode,\n}: {\n  implementationAddress: Address;\n  initcode: Hex;\n}): Hex =>\n  encodeDeployData({\n    abi: ERC1967Proxy.abi,\n    args: [implementationAddress, initcode],\n    bytecode: ERC1967Proxy.bytecode,\n  });\n","import { read as getDelegationManager } from './methods/getDelegationManager';\nimport { read as getDeposit } from './methods/getDeposit';\nimport { read as getEntryPoint } from './methods/getEntryPoint';\nimport { read as getNonce } from './methods/getNonce';\nimport { read as getProxyImplementation } from './methods/getProxyImplementation';\nimport { read as getProxyVersion } from './methods/getProxyVersion';\nimport { read as isValidSignature } from './methods/isValidSignature';\n\nexport {\n  getDelegationManager,\n  getDeposit,\n  getEntryPoint,\n  getNonce,\n  getProxyImplementation,\n  getProxyVersion,\n  isValidSignature,\n};\n","import { DeleGatorCore } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetDelegationManagerParameters = {\n  client: Client;\n  contractAddress: Address;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n}: ReadGetDelegationManagerParameters) =>\n  await readContract(client, {\n    address: contractAddress,\n    abi: DeleGatorCore.abi,\n    functionName: 'delegationManager',\n  });\n","import { DeleGatorCore } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetDepositParameters = {\n  client: Client;\n  contractAddress: Address;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n}: ReadGetDepositParameters) =>\n  await readContract(client, {\n    address: contractAddress,\n    abi: DeleGatorCore.abi,\n    functionName: 'getDeposit',\n  });\n","import { DeleGatorCore } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetEntryPointParameters = {\n  client: Client;\n  contractAddress: Address;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n}: ReadGetEntryPointParameters) =>\n  await readContract(client, {\n    address: contractAddress,\n    abi: DeleGatorCore.abi,\n    functionName: 'entryPoint',\n  });\n","import { DeleGatorCore } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetNonceParameters = {\n  client: Client;\n  contractAddress: Address;\n  key?: bigint;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  key,\n}: ReadGetNonceParameters) =>\n  await readContract(client, {\n    address: contractAddress,\n    abi: DeleGatorCore.abi,\n    functionName: 'getNonce',\n    args: key ? [key] : undefined,\n  });\n","import { DeleGatorCore } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetProxyImplementationParameters = {\n  client: Client;\n  contractAddress: Address;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n}: ReadGetProxyImplementationParameters) =>\n  await readContract(client, {\n    address: contractAddress,\n    abi: DeleGatorCore.abi,\n    functionName: 'getImplementation',\n  });\n","import { DeleGatorCore } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetProxyVersionParameters = {\n  client: Client;\n  contractAddress: Address;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n}: ReadGetProxyVersionParameters) =>\n  await readContract(client, {\n    address: contractAddress,\n    abi: DeleGatorCore.abi,\n    functionName: 'getInitializedVersion',\n  });\n","import { DeleGatorCore } from '@metamask/delegation-abis';\nimport type { Address, Hex, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type IsValidSignatureParameters = {\n  client: Client;\n  contractAddress: Address;\n  hash: Hex;\n  signature: Hex;\n};\n\nexport type EncodeIsValidSignatureParameters = {\n  hash: Hex;\n  signature: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  hash,\n  signature,\n}: IsValidSignatureParameters) =>\n  await readContract(client, {\n    address: contractAddress,\n    abi: DeleGatorCore.abi,\n    functionName: 'isValidSignature',\n    args: [hash, signature],\n  });\n\nexport const encode = ({\n  hash,\n  signature,\n}: EncodeIsValidSignatureParameters) => {\n  return encodeFunctionData({\n    abi: DeleGatorCore.abi,\n    functionName: 'isValidSignature',\n    args: [hash, signature],\n  });\n};\n","import { HybridDeleGator } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport type { P256Owner, InitializedClient } from '../../types';\n\nexport type EncodeInitializeParameters = {\n  eoaOwner: Address;\n  p256Owners: P256Owner[];\n};\n\nexport type SimulateInitializeParameters = {\n  client: Client;\n  hybridDeleGatorAddress: Address;\n} & EncodeInitializeParameters;\n\nexport type ExecuteInitializeParameters = {\n  client: InitializedClient;\n  hybridDeleGatorAddress: Address;\n} & EncodeInitializeParameters;\n\nexport const simulate = async ({\n  client,\n  hybridDeleGatorAddress,\n  eoaOwner,\n  p256Owners,\n}: SimulateInitializeParameters) => {\n  return simulateContract(client, {\n    address: hybridDeleGatorAddress,\n    abi: HybridDeleGator.abi,\n    functionName: 'initialize',\n    args: [\n      eoaOwner,\n      p256Owners.map((p256Owner) => p256Owner.keyId),\n      p256Owners.map((p256Owner) => p256Owner.x),\n      p256Owners.map((p256Owner) => p256Owner.y),\n    ],\n  });\n};\n\nexport const execute = async ({\n  client,\n  hybridDeleGatorAddress,\n  eoaOwner,\n  p256Owners,\n}: ExecuteInitializeParameters) => {\n  const { request } = await simulate({\n    client,\n    hybridDeleGatorAddress,\n    eoaOwner,\n    p256Owners,\n  });\n\n  return writeContract(client, request);\n};\n\nexport const encode = ({\n  eoaOwner,\n  p256Owners,\n}: EncodeInitializeParameters) => {\n  return encodeFunctionData({\n    abi: HybridDeleGator.abi,\n    functionName: 'initialize',\n    args: [\n      eoaOwner,\n      p256Owners.map((p256Owner) => p256Owner.keyId),\n      p256Owners.map((p256Owner) => p256Owner.x),\n      p256Owners.map((p256Owner) => p256Owner.y),\n    ],\n  });\n};\n","import { encode as addKey } from './methods/addKey';\nimport { encode as initializeHybridDeleGator } from './methods/initialize';\nimport { encode as reinitializeHybridDeleGator } from './methods/reinitialize';\nimport { encode as removeKey } from './methods/removeKey';\nimport { encode as updateSigners } from './methods/updateSigners';\n\nexport {\n  addKey,\n  initializeHybridDeleGator,\n  reinitializeHybridDeleGator,\n  removeKey,\n  updateSigners,\n};\n","import { HybridDeleGator } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport type { P256Owner, InitializedClient } from '../../types';\n\nexport type EncodeAddKeyParameters = {\n  p256Owner: P256Owner;\n};\n\nexport type SimulateAddKeyParameters = {\n  client: Client;\n  hybridDeleGatorAddress: Address;\n} & EncodeAddKeyParameters;\n\nexport type ExecuteAddKeyParameters = {\n  client: InitializedClient;\n  hybridDeleGatorAddress: Address;\n} & EncodeAddKeyParameters;\n\nexport const simulate = async ({\n  client,\n  hybridDeleGatorAddress,\n  p256Owner,\n}: SimulateAddKeyParameters) => {\n  return simulateContract(client, {\n    address: hybridDeleGatorAddress,\n    abi: HybridDeleGator.abi,\n    functionName: 'addKey',\n    args: [p256Owner.keyId, p256Owner.x, p256Owner.y],\n  });\n};\n\nexport const execute = async ({\n  client,\n  hybridDeleGatorAddress,\n  p256Owner,\n}: ExecuteAddKeyParameters) => {\n  const { request } = await simulate({\n    client,\n    hybridDeleGatorAddress,\n    p256Owner,\n  });\n\n  return writeContract(client, request);\n};\n\nexport const encode = ({ p256Owner }: EncodeAddKeyParameters) => {\n  return encodeFunctionData({\n    abi: HybridDeleGator.abi,\n    functionName: 'addKey',\n    args: [p256Owner.keyId, p256Owner.x, p256Owner.y],\n  });\n};\n","import { HybridDeleGator } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport type { P256Owner, InitializedClient } from '../../types';\n\nexport type EncodeReinitializeParameters = {\n  version: number;\n  eoaOwner: Address;\n  p256Owners: P256Owner[];\n  removeExistingP256Owners: boolean;\n};\n\nexport type SimulateReinitializeParameters = {\n  client: Client;\n  hybridDeleGatorAddress: Address;\n} & EncodeReinitializeParameters;\n\nexport type ExecuteReinitializeParameters = {\n  client: InitializedClient;\n  hybridDeleGatorAddress: Address;\n} & EncodeReinitializeParameters;\n\nexport const simulate = async ({\n  client,\n  hybridDeleGatorAddress,\n  version,\n  eoaOwner,\n  p256Owners,\n  removeExistingP256Owners,\n}: SimulateReinitializeParameters) => {\n  return simulateContract(client, {\n    address: hybridDeleGatorAddress,\n    abi: HybridDeleGator.abi,\n    functionName: 'reinitialize',\n    args: [\n      version,\n      eoaOwner,\n      p256Owners.map((p256Owner) => p256Owner.keyId),\n      p256Owners.map((p256Owner) => p256Owner.x),\n      p256Owners.map((p256Owner) => p256Owner.y),\n      removeExistingP256Owners,\n    ],\n  });\n};\n\nexport const execute = async ({\n  client,\n  hybridDeleGatorAddress,\n  version,\n  eoaOwner,\n  p256Owners,\n  removeExistingP256Owners,\n}: ExecuteReinitializeParameters) => {\n  const { request } = await simulate({\n    client,\n    hybridDeleGatorAddress,\n    version,\n    eoaOwner,\n    p256Owners,\n    removeExistingP256Owners,\n  });\n\n  return writeContract(client, request);\n};\n\nexport const encode = ({\n  version,\n  eoaOwner,\n  p256Owners,\n  removeExistingP256Owners,\n}: EncodeReinitializeParameters) => {\n  return encodeFunctionData({\n    abi: HybridDeleGator.abi,\n    functionName: 'reinitialize',\n    args: [\n      version,\n      eoaOwner,\n      p256Owners.map((p256Owner) => p256Owner.keyId),\n      p256Owners.map((p256Owner) => p256Owner.x),\n      p256Owners.map((p256Owner) => p256Owner.y),\n      removeExistingP256Owners,\n    ],\n  });\n};\n","import { HybridDeleGator } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport type { InitializedClient } from '../../types';\n\nexport type EncodeRemoveKeyParameters = {\n  keyId: string;\n};\n\nexport type SimulateRemoveKeyParameters = {\n  client: Client;\n  hybridDeleGatorAddress: Address;\n} & EncodeRemoveKeyParameters;\n\nexport type ExecuteRemoveKeyParameters = {\n  client: InitializedClient;\n  hybridDeleGatorAddress: Address;\n} & EncodeRemoveKeyParameters;\n\nexport const simulate = async ({\n  client,\n  hybridDeleGatorAddress,\n  keyId,\n}: SimulateRemoveKeyParameters) => {\n  return simulateContract(client, {\n    address: hybridDeleGatorAddress,\n    abi: HybridDeleGator.abi,\n    functionName: 'removeKey',\n    args: [keyId],\n  });\n};\n\nexport const execute = async ({\n  client,\n  hybridDeleGatorAddress,\n  keyId,\n}: ExecuteRemoveKeyParameters) => {\n  const { request } = await simulate({\n    client,\n    hybridDeleGatorAddress,\n    keyId,\n  });\n\n  return writeContract(client, request);\n};\n\nexport const encode = ({ keyId }: EncodeRemoveKeyParameters) => {\n  return encodeFunctionData({\n    abi: HybridDeleGator.abi,\n    functionName: 'removeKey',\n    args: [keyId],\n  });\n};\n","import { HybridDeleGator } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport type { P256Owner, InitializedClient } from '../../types';\n\nexport type EncodeUpdateSignersParameters = {\n  eoaOwner: Address;\n  p256Owners: P256Owner[];\n};\n\nexport type SimulateUpdateSignersParameters = {\n  client: Client;\n  hybridDeleGatorAddress: Address;\n} & EncodeUpdateSignersParameters;\n\nexport type ExecuteUpdateSignersParameters = {\n  client: InitializedClient;\n  hybridDeleGatorAddress: Address;\n} & EncodeUpdateSignersParameters;\n\nexport const simulate = async ({\n  client,\n  hybridDeleGatorAddress,\n  eoaOwner,\n  p256Owners,\n}: SimulateUpdateSignersParameters) => {\n  return simulateContract(client, {\n    address: hybridDeleGatorAddress,\n    abi: HybridDeleGator.abi,\n    functionName: 'updateSigners',\n    args: [\n      eoaOwner,\n      p256Owners.map((p256Owner) => p256Owner.keyId),\n      p256Owners.map((p256Owner) => p256Owner.x),\n      p256Owners.map((p256Owner) => p256Owner.y),\n    ],\n  });\n};\n\nexport const execute = async ({\n  client,\n  hybridDeleGatorAddress,\n  eoaOwner,\n  p256Owners,\n}: ExecuteUpdateSignersParameters) => {\n  const { request } = await simulate({\n    client,\n    hybridDeleGatorAddress,\n    eoaOwner,\n    p256Owners,\n  });\n\n  return writeContract(client, request);\n};\n\nexport const encode = ({\n  eoaOwner,\n  p256Owners,\n}: EncodeUpdateSignersParameters) => {\n  return encodeFunctionData({\n    abi: HybridDeleGator.abi,\n    functionName: 'updateSigners',\n    args: [\n      eoaOwner,\n      p256Owners.map((p256Owner) => p256Owner.keyId),\n      p256Owners.map((p256Owner) => p256Owner.x),\n      p256Owners.map((p256Owner) => p256Owner.y),\n    ],\n  });\n};\n","import { MultiSigDeleGator } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport type { InitializedClient } from '../../types';\n\nexport type EncodeInitializeParameters = {\n  owners: Address[];\n  threshold: bigint;\n};\n\nexport type SimulateInitializeParameters = {\n  client: Client;\n  multiSigDeleGatorAddress: Address;\n} & EncodeInitializeParameters;\n\nexport type ExecuteInitializeParameters = {\n  client: InitializedClient;\n  multiSigDeleGatorAddress: Address;\n} & EncodeInitializeParameters;\n\nexport const simulate = async ({\n  client,\n  multiSigDeleGatorAddress,\n  owners,\n  threshold,\n}: SimulateInitializeParameters) => {\n  return simulateContract(client, {\n    address: multiSigDeleGatorAddress,\n    abi: MultiSigDeleGator.abi,\n    functionName: 'initialize',\n    args: [owners, threshold],\n  });\n};\n\nexport const execute = async ({\n  client,\n  multiSigDeleGatorAddress,\n  owners,\n  threshold,\n}: ExecuteInitializeParameters) => {\n  const { request } = await simulate({\n    client,\n    multiSigDeleGatorAddress,\n    owners,\n    threshold,\n  });\n\n  return writeContract(client, request);\n};\n\nexport const encode = ({ owners, threshold }: EncodeInitializeParameters) => {\n  return encodeFunctionData({\n    abi: MultiSigDeleGator.abi,\n    functionName: 'initialize',\n    args: [owners, threshold],\n  });\n};\n","import { encode as addSigner } from './methods/addSigner';\nimport { encode as initializeMultiSigDeleGator } from './methods/initialize';\nimport { encode as reinitializeMultiSigDeleGator } from './methods/reinitialize';\nimport { encode as removeSigner } from './methods/removeSigner';\nimport { encode as replaceSigner } from './methods/replaceSigner';\nimport { encode as updateMultiSigParameters } from './methods/updateMultiSigParameters';\nimport { encode as updateThreshold } from './methods/updateThreshold';\n\nexport {\n  addSigner,\n  initializeMultiSigDeleGator,\n  reinitializeMultiSigDeleGator,\n  removeSigner,\n  replaceSigner,\n  updateThreshold,\n  updateMultiSigParameters,\n};\n","import { MultiSigDeleGator } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport type { InitializedClient } from '../../types';\n\nexport type EncodeAddSignerParameters = {\n  signer: Address;\n};\n\nexport type SimulateAddSignerParameters = {\n  client: Client;\n  multiSigDeleGatorAddress: Address;\n} & EncodeAddSignerParameters;\n\nexport type ExecuteAddSignerParameters = {\n  client: InitializedClient;\n  multiSigDeleGatorAddress: Address;\n} & EncodeAddSignerParameters;\n\nexport const simulate = async ({\n  client,\n  multiSigDeleGatorAddress,\n  signer,\n}: SimulateAddSignerParameters) => {\n  return simulateContract(client, {\n    address: multiSigDeleGatorAddress,\n    abi: MultiSigDeleGator.abi,\n    functionName: 'addSigner',\n    args: [signer],\n  });\n};\n\nexport const execute = async ({\n  client,\n  multiSigDeleGatorAddress,\n  signer,\n}: ExecuteAddSignerParameters) => {\n  const { request } = await simulate({\n    client,\n    multiSigDeleGatorAddress,\n    signer,\n  });\n\n  return writeContract(client, request);\n};\n\nexport const encode = ({ signer }: EncodeAddSignerParameters) => {\n  return encodeFunctionData({\n    abi: MultiSigDeleGator.abi,\n    functionName: 'addSigner',\n    args: [signer],\n  });\n};\n","import { MultiSigDeleGator } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport type { InitializedClient } from '../../types';\n\nexport type EncodeReinitializeParameters = {\n  version: bigint;\n  owners: Address[];\n  threshold: bigint;\n  removeExistingOwners: boolean;\n};\n\nexport type SimulateReinitializeParameters = {\n  client: Client;\n  multiSigDeleGatorAddress: Address;\n} & EncodeReinitializeParameters;\n\nexport type ExecuteReinitializeParameters = {\n  client: InitializedClient;\n  multiSigDeleGatorAddress: Address;\n} & EncodeReinitializeParameters;\n\nexport const simulate = async ({\n  client,\n  multiSigDeleGatorAddress,\n  version,\n  owners,\n  threshold,\n  removeExistingOwners,\n}: SimulateReinitializeParameters) => {\n  return simulateContract(client, {\n    address: multiSigDeleGatorAddress,\n    abi: MultiSigDeleGator.abi,\n    functionName: 'reinitialize',\n    args: [version, owners, threshold, removeExistingOwners],\n  });\n};\n\nexport const execute = async ({\n  client,\n  multiSigDeleGatorAddress,\n  version,\n  owners,\n  threshold,\n  removeExistingOwners,\n}: ExecuteReinitializeParameters) => {\n  const { request } = await simulate({\n    client,\n    multiSigDeleGatorAddress,\n    version,\n    owners,\n    threshold,\n    removeExistingOwners,\n  });\n\n  return writeContract(client, request);\n};\n\nexport const encode = ({\n  version,\n  owners,\n  threshold,\n  removeExistingOwners,\n}: EncodeReinitializeParameters) => {\n  return encodeFunctionData({\n    abi: MultiSigDeleGator.abi,\n    functionName: 'reinitialize',\n    args: [version, owners, threshold, removeExistingOwners],\n  });\n};\n","import { MultiSigDeleGator } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport type { InitializedClient } from '../../types';\n\nexport type EncodeRemoveSignerParameters = {\n  signer: Address;\n};\n\nexport type SimulateRemoveSignerParameters = {\n  client: Client;\n  multiSigDeleGatorAddress: Address;\n} & EncodeRemoveSignerParameters;\n\nexport type ExecuteRemoveSignerParameters = {\n  client: InitializedClient;\n  multiSigDeleGatorAddress: Address;\n} & EncodeRemoveSignerParameters;\n\nexport const simulate = async ({\n  client,\n  multiSigDeleGatorAddress,\n  signer,\n}: SimulateRemoveSignerParameters) => {\n  return simulateContract(client, {\n    address: multiSigDeleGatorAddress,\n    abi: MultiSigDeleGator.abi,\n    functionName: 'removeSigner',\n    args: [signer],\n  });\n};\n\nexport const execute = async ({\n  client,\n  multiSigDeleGatorAddress,\n  signer,\n}: ExecuteRemoveSignerParameters) => {\n  const { request } = await simulate({\n    client,\n    multiSigDeleGatorAddress,\n    signer,\n  });\n\n  return writeContract(client, request);\n};\n\nexport const encode = ({ signer }: EncodeRemoveSignerParameters) => {\n  return encodeFunctionData({\n    abi: MultiSigDeleGator.abi,\n    functionName: 'removeSigner',\n    args: [signer],\n  });\n};\n","import { MultiSigDeleGator } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport type { InitializedClient } from '../../types';\n\nexport type EncodeReplaceSignerParameters = {\n  oldSigner: Address;\n  newSigner: Address;\n};\n\nexport type SimulateReplaceSignerParameters = {\n  client: Client;\n  multiSigDeleGatorAddress: Address;\n} & EncodeReplaceSignerParameters;\n\nexport type ExecuteReplaceSignerParameters = {\n  client: InitializedClient;\n  multiSigDeleGatorAddress: Address;\n} & EncodeReplaceSignerParameters;\n\nexport const simulate = async ({\n  client,\n  multiSigDeleGatorAddress,\n  oldSigner,\n  newSigner,\n}: SimulateReplaceSignerParameters) => {\n  return simulateContract(client, {\n    address: multiSigDeleGatorAddress,\n    abi: MultiSigDeleGator.abi,\n    functionName: 'replaceSigner',\n    args: [oldSigner, newSigner],\n  });\n};\n\nexport const execute = async ({\n  client,\n  multiSigDeleGatorAddress,\n  oldSigner,\n  newSigner,\n}: ExecuteReplaceSignerParameters) => {\n  const { request } = await simulate({\n    client,\n    multiSigDeleGatorAddress,\n    oldSigner,\n    newSigner,\n  });\n\n  return writeContract(client, request);\n};\n\nexport const encode = ({\n  oldSigner,\n  newSigner,\n}: EncodeReplaceSignerParameters) => {\n  return encodeFunctionData({\n    abi: MultiSigDeleGator.abi,\n    functionName: 'replaceSigner',\n    args: [oldSigner, newSigner],\n  });\n};\n","import { MultiSigDeleGator } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport type { InitializedClient } from '../../types';\n\nexport type EncodeUpdateMultiSigParametersParameters = {\n  owners: Address[];\n  threshold: bigint;\n  removeExistingOwners: boolean;\n};\n\nexport type SimulateUpdateMultiSigParametersParameters = {\n  client: Client;\n  multiSigDeleGatorAddress: Address;\n} & EncodeUpdateMultiSigParametersParameters;\n\nexport type ExecuteUpdateMultiSigParametersParameters = {\n  client: InitializedClient;\n  multiSigDeleGatorAddress: Address;\n} & EncodeUpdateMultiSigParametersParameters;\n\nexport const simulate = async ({\n  client,\n  multiSigDeleGatorAddress,\n  owners,\n  threshold,\n  removeExistingOwners,\n}: SimulateUpdateMultiSigParametersParameters) => {\n  return simulateContract(client, {\n    address: multiSigDeleGatorAddress,\n    abi: MultiSigDeleGator.abi,\n    functionName: 'updateMultiSigParameters',\n    args: [owners, threshold, removeExistingOwners],\n  });\n};\n\nexport const execute = async ({\n  client,\n  multiSigDeleGatorAddress,\n  owners,\n  threshold,\n  removeExistingOwners,\n}: ExecuteUpdateMultiSigParametersParameters) => {\n  const { request } = await simulate({\n    client,\n    multiSigDeleGatorAddress,\n    owners,\n    threshold,\n    removeExistingOwners,\n  });\n\n  return writeContract(client, request);\n};\n\nexport const encode = ({\n  owners,\n  threshold,\n  removeExistingOwners,\n}: EncodeUpdateMultiSigParametersParameters) => {\n  return encodeFunctionData({\n    abi: MultiSigDeleGator.abi,\n    functionName: 'updateMultiSigParameters',\n    args: [owners, threshold, removeExistingOwners],\n  });\n};\n","import { MultiSigDeleGator } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport type { InitializedClient } from '../../types';\n\nexport type EncodeUpdateThresholdParameters = {\n  threshold: bigint;\n};\n\nexport type SimulateUpdateThresholdParameters = {\n  client: Client;\n  multiSigDeleGatorAddress: Address;\n} & EncodeUpdateThresholdParameters;\n\nexport type ExecuteUpdateThresholdParameters = {\n  client: InitializedClient;\n  multiSigDeleGatorAddress: Address;\n} & EncodeUpdateThresholdParameters;\n\nexport const simulate = async ({\n  client,\n  multiSigDeleGatorAddress,\n  threshold,\n}: SimulateUpdateThresholdParameters) => {\n  return simulateContract(client, {\n    address: multiSigDeleGatorAddress,\n    abi: MultiSigDeleGator.abi,\n    functionName: 'updateThreshold',\n    args: [threshold],\n  });\n};\n\nexport const execute = async ({\n  client,\n  multiSigDeleGatorAddress,\n  threshold,\n}: ExecuteUpdateThresholdParameters) => {\n  const { request } = await simulate({\n    client,\n    multiSigDeleGatorAddress,\n    threshold,\n  });\n\n  return writeContract(client, request);\n};\n\nexport const encode = ({ threshold }: EncodeUpdateThresholdParameters) => {\n  return encodeFunctionData({\n    abi: MultiSigDeleGator.abi,\n    functionName: 'updateThreshold',\n    args: [threshold],\n  });\n};\n","import { SimpleFactory } from '@metamask/delegation-abis';\nimport type { Address, Hex, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport type { InitializedClient } from '../../types';\n\nexport type SimulateCreate2DeployParameters = {\n  client: Client;\n  factoryAddress: Address;\n  creationCode: Hex;\n  salt: Hex;\n};\n\nexport type ExecuteCreate2DeployParameters = {\n  client: InitializedClient;\n  factoryAddress: Address;\n  creationCode: Hex;\n  salt: Hex;\n};\n\nexport const simulate = async ({\n  client,\n  factoryAddress,\n  creationCode,\n  salt,\n}: SimulateCreate2DeployParameters) => {\n  return simulateContract(client, {\n    address: factoryAddress,\n    abi: SimpleFactory.abi,\n    functionName: 'deploy',\n    args: [creationCode, salt],\n  });\n};\n\nexport const encode = (creationCode: Hex, salt: Hex) => {\n  return encodeFunctionData({\n    abi: SimpleFactory.abi,\n    functionName: 'deploy',\n    args: [creationCode, salt],\n  });\n};\n\nexport const execute = async ({\n  client,\n  factoryAddress,\n  creationCode,\n  salt,\n}: ExecuteCreate2DeployParameters) => {\n  const { request } = await simulate({\n    client,\n    factoryAddress,\n    creationCode,\n    salt,\n  });\n  return writeContract(client, request);\n};\n","import { encode as create2Deploy } from './methods/create2Deploy';\n\nexport { create2Deploy };\n","import { DeleGatorCore } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport type { ExecutionStruct } from '../../../executions';\nimport type { InitializedClient } from '../../types';\n\nexport type SimulateExecuteParameters = {\n  client: Client;\n  contractAddress: Address;\n  execution: ExecutionStruct;\n};\n\nexport type EncodeExecuteParameters = {\n  execution: ExecutionStruct;\n};\n\nexport type ExecuteExecuteParameters = {\n  client: InitializedClient;\n  contractAddress: Address;\n  execution: ExecutionStruct;\n};\n\nexport const simulate = async ({\n  client,\n  contractAddress,\n  execution,\n}: SimulateExecuteParameters) => {\n  return simulateContract(client, {\n    address: contractAddress,\n    abi: DeleGatorCore.abi,\n    functionName: 'execute',\n    args: [execution],\n  });\n};\n\nexport const execute = async ({\n  client,\n  contractAddress,\n  execution,\n}: ExecuteExecuteParameters) => {\n  const { request } = await simulate({\n    client,\n    contractAddress,\n    execution,\n  });\n\n  return writeContract(client, request);\n};\n\nexport const encode = ({ execution }: EncodeExecuteParameters) => {\n  return encodeFunctionData({\n    abi: DeleGatorCore.abi,\n    functionName: 'execute',\n    args: [execution],\n  });\n};\n","import { DeleGatorCore } from '@metamask/delegation-abis';\nimport { encodeFunctionData } from 'viem';\nimport type { Address, Client } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport { encodeExecutionCalldata } from '../../../executions';\nimport type { ExecutionStruct, ExecutionMode } from '../../../executions';\nimport type { InitializedClient } from '../../types';\n\nexport type SimulateExecuteWithModeParameters = {\n  client: Client;\n  contractAddress: Address;\n} & EncodeExecuteWithModeParameters;\nexport type EncodeExecuteWithModeParameters = {\n  mode: ExecutionMode;\n  executions: ExecutionStruct[];\n};\n\nexport type ExecuteExecuteWithModeParameters = {\n  client: InitializedClient;\n  contractAddress: Address;\n} & EncodeExecuteWithModeParameters;\n\nexport const simulate = async ({\n  client,\n  contractAddress,\n  mode,\n  executions,\n}: SimulateExecuteWithModeParameters) => {\n  return simulateContract(client, {\n    address: contractAddress,\n    abi: DeleGatorCore.abi,\n    functionName: 'execute',\n    args: [mode, encodeExecutionCalldata(executions)],\n  });\n};\n\nexport const execute = async ({\n  client,\n  contractAddress,\n  mode,\n  executions,\n}: ExecuteExecuteWithModeParameters) => {\n  const { request } = await simulate({\n    client,\n    contractAddress,\n    mode,\n    executions,\n  });\n\n  return writeContract(client, request);\n};\n\nexport const encode = ({\n  mode,\n  executions,\n}: EncodeExecuteWithModeParameters) => {\n  return encodeFunctionData({\n    abi: DeleGatorCore.abi,\n    functionName: 'execute',\n    args: [mode, encodeExecutionCalldata(executions)],\n  });\n};\n","import { encode as disableDelegation } from './methods/disableDelegation';\nimport { encode as enableDelegation } from './methods/enableDelegation';\nimport { encode as execute } from './methods/execute';\nimport { encode as executeWithMode } from './methods/executeWithMode';\nimport { encode as isValidSignature } from './methods/isValidSignature';\nimport { encode as upgradeToAndCall } from './methods/upgradeToAndCall';\n\nexport {\n  disableDelegation,\n  enableDelegation,\n  execute,\n  executeWithMode,\n  upgradeToAndCall,\n  isValidSignature,\n};\n","import { DeleGatorCore } from '@metamask/delegation-abis';\nimport { encodeFunctionData } from 'viem';\nimport type { Address, Client } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport { toDelegationStruct } from '../../../delegation';\nimport type { Delegation } from '../../../types';\nimport type { InitializedClient } from '../../types';\nimport type { NarrowAbiToFunction } from '../../utils';\n\nexport type SimulateDisableDelegationParameters = {\n  client: Client;\n  delegationManagerAddress: Address;\n  delegation: Delegation;\n};\n\nexport type EncodeDisableDelegationParameters = {\n  delegation: Delegation;\n};\n\nexport type ExecuteDisableDelegationParameters = {\n  client: InitializedClient;\n  delegationManagerAddress: Address;\n  delegation: Delegation;\n};\n\nexport const simulate = async ({\n  client,\n  delegationManagerAddress,\n  delegation,\n}: SimulateDisableDelegationParameters) => {\n  const abi = DeleGatorCore.abi as any as NarrowAbiToFunction<\n    typeof DeleGatorCore.abi,\n    'disableDelegation'\n  >;\n\n  const delegationStruct = toDelegationStruct(delegation);\n\n  return simulateContract(client, {\n    address: delegationManagerAddress,\n    abi,\n    functionName: 'disableDelegation',\n    args: [delegationStruct],\n  });\n};\n\nexport const execute = async ({\n  client,\n  delegationManagerAddress,\n  delegation,\n}: ExecuteDisableDelegationParameters) => {\n  const { request } = await simulate({\n    client,\n    delegationManagerAddress,\n    delegation,\n  });\n\n  return writeContract(client, request);\n};\n\nexport const encode = ({ delegation }: EncodeDisableDelegationParameters) => {\n  const delegationStruct = toDelegationStruct(delegation);\n\n  return encodeFunctionData({\n    abi: DeleGatorCore.abi,\n    functionName: 'disableDelegation',\n    args: [delegationStruct],\n  });\n};\n","import { DeleGatorCore } from '@metamask/delegation-abis';\nimport { encodeFunctionData } from 'viem';\nimport type { Address, Client } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport { toDelegationStruct } from '../../../delegation';\nimport type { Delegation } from '../../../types';\nimport type { InitializedClient } from '../../types';\nimport type { NarrowAbiToFunction } from '../../utils';\n\nexport type SimulateEnableDelegationParameters = {\n  client: Client;\n  delegationManagerAddress: Address;\n  delegation: Delegation;\n};\n\nexport type EncodeEnableDelegationParameters = {\n  delegation: Delegation;\n};\n\nexport type ExecuteEnableDelegationParameters = {\n  client: InitializedClient;\n  delegationManagerAddress: Address;\n  delegation: Delegation;\n};\n\nexport const simulate = async ({\n  client,\n  delegationManagerAddress,\n  delegation,\n}: SimulateEnableDelegationParameters) => {\n  const abi = DeleGatorCore.abi as any as NarrowAbiToFunction<\n    typeof DeleGatorCore.abi,\n    'enableDelegation'\n  >;\n\n  const delegationStruct = toDelegationStruct(delegation);\n\n  return simulateContract(client, {\n    address: delegationManagerAddress,\n    abi,\n    functionName: 'enableDelegation',\n    args: [delegationStruct],\n  });\n};\n\nexport const execute = async ({\n  client,\n  delegationManagerAddress,\n  delegation,\n}: ExecuteEnableDelegationParameters) => {\n  const { request } = await simulate({\n    client,\n    delegationManagerAddress,\n    delegation,\n  });\n\n  return writeContract(client, request);\n};\n\nexport const encode = ({ delegation }: EncodeEnableDelegationParameters) => {\n  const delegationStruct = toDelegationStruct(delegation);\n\n  return encodeFunctionData({\n    abi: DeleGatorCore.abi,\n    functionName: 'enableDelegation',\n    args: [delegationStruct],\n  });\n};\n","import { DeleGatorCore } from '@metamask/delegation-abis';\nimport type { Address, Hex, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport type { InitializedClient } from '../../types';\n\nexport type SimulateUpgradeToAndCallParameters = {\n  client: Client;\n  contractAddress: Address;\n} & EncodeUpgradeToAndCallParameters;\n\nexport type EncodeUpgradeToAndCallParameters = {\n  implementation: Address;\n  data: Hex;\n};\n\nexport type ExecuteUpgradeToAndCallParameters = {\n  client: InitializedClient;\n  contractAddress: Address;\n} & EncodeUpgradeToAndCallParameters;\n\nexport const simulate = async ({\n  client,\n  contractAddress,\n  implementation,\n  data,\n}: SimulateUpgradeToAndCallParameters) => {\n  return simulateContract(client, {\n    address: contractAddress,\n    abi: DeleGatorCore.abi,\n    functionName: 'upgradeToAndCall',\n    args: [implementation, data],\n  });\n};\n\nexport const execute = async ({\n  client,\n  contractAddress,\n  implementation,\n  data,\n}: ExecuteUpgradeToAndCallParameters) => {\n  const { request } = await simulate({\n    client,\n    contractAddress,\n    implementation,\n    data,\n  });\n\n  return writeContract(client, request);\n};\n\nexport const encode = ({\n  implementation,\n  data,\n}: EncodeUpgradeToAndCallParameters) => {\n  return encodeFunctionData({\n    abi: DeleGatorCore.abi,\n    functionName: 'upgradeToAndCall',\n    args: [implementation, data],\n  });\n};\n"],"names":["read","DeleGatorCore","readContract","read","DeleGatorCore","readContract","read","DeleGatorCore","readContract","read","DeleGatorCore","readContract","read","DeleGatorCore","readContract","read","DeleGatorCore","readContract","read","read","encodeFunctionData","encode","encodeFunctionData","encode","HybridDeleGator","encodeFunctionData","simulateContract","writeContract","simulate","encode","encodeFunctionData","HybridDeleGator","HybridDeleGator","encodeFunctionData","simulateContract","writeContract","simulate","encode","encodeFunctionData","HybridDeleGator","HybridDeleGator","encodeFunctionData","simulateContract","writeContract","simulate","encode","encodeFunctionData","HybridDeleGator","HybridDeleGator","encodeFunctionData","simulateContract","writeContract","simulate","encode","encodeFunctionData","HybridDeleGator","encodeFunctionData","simulateContract","writeContract","simulate","encode","encodeFunctionData","encode_exports","encode","MultiSigDeleGator","encodeFunctionData","simulateContract","writeContract","simulate","encode","encodeFunctionData","MultiSigDeleGator","MultiSigDeleGator","encodeFunctionData","simulateContract","writeContract","simulate","encode","encodeFunctionData","MultiSigDeleGator","MultiSigDeleGator","encodeFunctionData","simulateContract","writeContract","simulate","encode","encodeFunctionData","MultiSigDeleGator","MultiSigDeleGator","encodeFunctionData","simulateContract","writeContract","simulate","encode","encodeFunctionData","MultiSigDeleGator","MultiSigDeleGator","encodeFunctionData","simulateContract","writeContract","simulate","encode","encodeFunctionData","MultiSigDeleGator","MultiSigDeleGator","encodeFunctionData","simulateContract","writeContract","simulate","encode","encodeFunctionData","MultiSigDeleGator","encodeFunctionData","simulateContract","writeContract","simulate","encode","encode_exports","encode","DeleGatorCore","encodeFunctionData","simulateContract","writeContract","simulate","execute","encode","DeleGatorCore","encodeFunctionData","simulateContract","writeContract","simulate","simulateContract","DeleGatorCore","execute","writeContract","encode","encodeFunctionData","encode_exports","encode","DeleGatorCore","encodeFunctionData","simulateContract","writeContract","simulate","DeleGatorCore","simulateContract","execute","writeContract","encode","encodeFunctionData","DeleGatorCore","encodeFunctionData","simulateContract","writeContract","simulate","DeleGatorCore","simulateContract","execute","writeContract","encode","encodeFunctionData","DeleGatorCore","encodeFunctionData","simulateContract","writeContract","simulate","execute","encode"],"mappings":"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"}},
    {"offset": {"line": 2287, "column": 0}, "map": {"version":3,"sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/constants.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/counterfactualAccountData.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/encodeCalls.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/webAuthn.ts"],"sourcesContent":["/**\n * To be used in sdk methods to call Implementation specific code\n * @type {Implementation}\n */\nexport enum Implementation {\n  MultiSig = 'MultiSig',\n  Hybrid = 'Hybrid',\n  Stateless7702 = 'Stateless7702',\n}\n","import type { Address, Hex } from 'viem';\nimport { getContractAddress, pad } from 'viem';\n\nimport { Implementation } from './constants';\nimport { initializeHybridDeleGator } from './DelegationFramework/HybridDeleGator/encode';\nimport { initializeMultiSigDeleGator } from './DelegationFramework/MultiSigDeleGator/encode';\nimport { create2Deploy as encodeCreate2Deploy } from './DelegationFramework/SimpleFactory/encode';\nimport { encodeProxyCreationCode } from './DelegationFramework/utils';\nimport type {\n  DeleGatorEnvironment,\n  HybridDeleGatorDeployParams,\n  MultiSigDeleGatorDeployParams,\n  DeployParams,\n} from './types';\n\n/**\n * Infers counterfactual account data for a DeleGator smart account.\n *\n * @template TImplementation - The type of implementation, extending Implementation.\n * @template TDeployParams - The type of deployment parameters, defaults to DeployParams<Implementation>.\n * @param options - The options for generating counterfactual account data.\n * @param options.factory - The address of the SimpleFactory contract.\n * @param options.implementations - The DeleGator implementation contracts.\n * @param options.implementation - The implementation type to use.\n * @param options.deployParams - The deployment parameters for the specified implementation.\n * @param options.deploySalt - The salt to use for CREATE2 address computation.\n * @returns An object containing the counterfactual address and factory calldata.\n * @description This function calculates the address a DeleGator contract would have if deployed,\n * and provides the calldata needed to deploy it.\n */\nexport const getCounterfactualAccountData = async <\n  TImplementation extends Implementation,\n>({\n  factory,\n  implementations,\n  implementation,\n  deployParams,\n  deploySalt,\n}: {\n  factory: Address;\n  implementations: DeleGatorEnvironment['implementations'];\n  implementation: TImplementation;\n  deployParams: DeployParams<TImplementation>;\n  deploySalt: Hex;\n}): Promise<{ factoryData: Hex; address: Address }> => {\n  let implementationAddress: Address;\n  let initcode: Hex;\n\n  switch (implementation) {\n    case Implementation.Hybrid: {\n      const [owner, keyIds, xValues, yValues] =\n        deployParams as HybridDeleGatorDeployParams;\n\n      if (!implementations.HybridDeleGatorImpl) {\n        throw new Error(\n          'HybridDeleGatorImpl address not provided in environment',\n        );\n      }\n\n      implementationAddress = implementations.HybridDeleGatorImpl;\n\n      const p256Owners = keyIds.map((keyId, index) => {\n        const xValue = xValues[index];\n        const yValue = yValues[index];\n\n        if (!xValue || !yValue) {\n          throw new Error(\n            `Missing X or Y value for keyId ${keyId} at index ${index}`,\n          );\n        }\n\n        return {\n          keyId,\n          x: xValue,\n          y: yValue,\n        };\n      });\n\n      initcode = initializeHybridDeleGator({ eoaOwner: owner, p256Owners });\n      break;\n    }\n    case Implementation.MultiSig: {\n      const [owners, threshold] = deployParams as MultiSigDeleGatorDeployParams;\n\n      if (!implementations.MultiSigDeleGatorImpl) {\n        throw new Error(\n          'MultiSigDeleGatorImpl address not provided in environment',\n        );\n      }\n\n      implementationAddress = implementations.MultiSigDeleGatorImpl;\n      initcode = initializeMultiSigDeleGator({ owners, threshold });\n      break;\n    }\n    default:\n      throw new Error(`Implementation type '${implementation}' not supported`);\n  }\n\n  const salt = pad(deploySalt, { dir: 'left', size: 32 });\n\n  const proxyCreationCode = encodeProxyCreationCode({\n    implementationAddress,\n    initcode,\n  });\n\n  const address = getContractAddress({\n    bytecode: proxyCreationCode,\n    from: factory,\n    opcode: 'CREATE2',\n    salt,\n  });\n\n  const factoryData = encodeCreate2Deploy(proxyCreationCode, salt);\n\n  return {\n    factoryData,\n    address,\n  };\n};\n","import { DelegationManager } from '@metamask/delegation-abis';\nimport { encodeFunctionData } from 'viem';\nimport type { Address, Hex } from 'viem';\n\nimport {\n  execute,\n  executeWithMode,\n} from './DelegationFramework/DeleGatorCore/encode';\nimport {\n  ExecutionMode,\n  createExecution,\n  encodeExecutionCalldatas,\n} from './executions';\nimport type { DelegatedCall } from './experimental/erc7710RedeemDelegationAction';\nimport type { Call } from './types';\n\n/**\n * Checks if a call is a delegated call by checking for the presence of permissionsContext and delegationManager.\n *\n * @param call - The call to check.\n * @returns True if the call is a delegated call, false otherwise.\n */\nconst isDelegatedCall = (call: Call): call is DelegatedCall => {\n  return 'permissionsContext' in call && 'delegationManager' in call;\n};\n\n/**\n * If there's a single call with permissionsContext and delegationManager,\n * processes it as a delegated call.\n *\n * @param call - The call to process.\n * @returns The execution object for the delegated call.\n * @description\n * This function creates an execution that calls redeemDelegations on the delegation manager.\n */\nconst processDelegatedCall = (call: DelegatedCall) => {\n  const {\n    permissionsContext,\n    delegationManager,\n    to: target,\n    value,\n    data: callData,\n  } = call;\n\n  const callAsExecution = createExecution({ target, value, callData });\n\n  if (!permissionsContext) {\n    return callAsExecution;\n  }\n\n  const redeemCalldata = encodeFunctionData({\n    abi: DelegationManager.abi,\n    functionName: 'redeemDelegations',\n    args: [\n      [permissionsContext],\n      [ExecutionMode.SingleDefault],\n      encodeExecutionCalldatas([[callAsExecution]]),\n    ],\n  });\n\n  return createExecution({\n    target: delegationManager,\n    callData: redeemCalldata,\n  });\n};\n\n/**\n * If there's a single call, encode the shorthand `execute` function. Otherwise, encode the `executeWithMode` function. Execution type will always be \"default\".\n *\n * @param calls - The calls to execute.\n * @returns The encoded calldata for the DeleGator to execute the calls.\n * @description\n * This function supports both single and batch execution modes.\n * For single calls, it uses the gas-efficient execute function.\n */\nexport const encodeCalls = (calls: readonly Call[]) => {\n  if (calls.length === 1) {\n    const call = calls[0];\n    if (call && !isDelegatedCall(call)) {\n      const { to: target, value, data: callData } = call;\n      const execution = createExecution({ target, value, callData });\n      return execute({ execution });\n    }\n  }\n\n  const executions = calls.map((call) => {\n    if (isDelegatedCall(call)) {\n      return processDelegatedCall(call);\n    }\n    const { to: target, value, data: callData } = call;\n    return createExecution({ target, value, callData });\n  });\n\n  const mode =\n    calls.length === 1\n      ? ExecutionMode.SingleDefault\n      : ExecutionMode.BatchDefault;\n  return executeWithMode({ mode, executions });\n};\n\n/**\n * Encodes calls for execution by a DeleGator smart contract.\n *\n * @param caller - The address of the DeleGator contract.\n * @param calls - An array of Call objects, each containing 'to', optional 'data', and optional 'value'.\n * @returns A promise that resolves to the encoded function data as a hexadecimal string.\n * @description\n * - If there's a single call directly to the delegator, it returns the call data directly.\n * - For multiple calls or calls to other addresses, it creates executions and encodes them for the DeleGator's execute function.\n * - The execution mode is set to ExecutionMode.SingleDefault for a single call, or ExecutionMode.BatchDefault for multiple calls.\n *\n * todo: This doesn't fully expose the flexibility of the DeleGator's execute function, but it's a start.\n * maybe we add a mechanism where individual calls passed to this function can be encoded batches.\n */\nexport const encodeCallsForCaller = async (\n  caller: Address,\n  calls: readonly Call[],\n): Promise<Hex> => {\n  if (calls.length === 1) {\n    const call = calls[0];\n    if (call && call.to === caller && !isDelegatedCall(call)) {\n      // if there's a single call, and it's to the delegator, we can just return the calldata directly.\n      return call.data ?? '0x';\n    }\n  }\n  return encodeCalls(calls);\n};\n","import {\n  parseAbiParameters,\n  encodeAbiParameters,\n  type Hex,\n  encodePacked,\n  keccak256,\n  concat,\n} from 'viem';\nimport { parseSignature } from 'webauthn-p256';\n\nexport const FIELD_MODULUS =\n  115792089210356248762697446949407573529996955224135760342422259061068512044369n;\nexport const MALLEABILITY_THRESHOLD = FIELD_MODULUS / 2n;\n\nexport const SIGNATURE_ABI_PARAMS = parseAbiParameters(\n  'bytes32, uint256, uint256, bytes, bool, string, string, uint256',\n);\n\n/**\n * This function is used to convert the client data returned from the\n * credentials API into a format that can be consumed by the DeleGator\n * contracts. We need the flattend JSON strings before and after the\n * userOpHash/challenge. This function provides those two client data string\n * slices.\n * @param clientDataJson - The client data JSON string.\n * @returns Returns [clientDataJSONPrefix and clientDataJSONSuffix]\n * ClientDataJSONPrefix contains the client data till the challengeHash\n * ClientDataJSONSuffix contains the client data after the challengeHash.\n */\nexport const splitOnChallenge = (\n  clientDataJson: string,\n): [clientDataJSONPrefix: string, clientDataJSONSuffix: string] => {\n  /*\n  CientData looks like this:\n  {\n    \"type\": \"webauthn.create\" | \"webauthn.get\",\n    \"challenge\": \"{userOpHash}\",\n    \"origin\": \"{Domain}\",\n    \"crossOrigin\": boolean\n  }  \n  */\n  try {\n    const { challenge } = JSON.parse(clientDataJson);\n    if (challenge === undefined) {\n      throw new Error('No \"challenge\" found in the input string');\n    }\n    return clientDataJson.split(challenge) as [string, string];\n  } catch (error) {\n    throw new Error('No \"challenge\" found in the input string', {\n      cause: error,\n    });\n  }\n};\n\n/**\n * Returns the index of '\"type\":' in the ClientData.\n * @param clientDataJson - Stringified ClientDataJSON.\n * @returns The index of '\"type\":' in the ClientData.\n */\nexport const getResponseTypeLocation = (clientDataJson: string): bigint => {\n  try {\n    // Find the index of the `\"type\":` key in the JSON string directly\n    const typeIndex = clientDataJson.indexOf('\"type\":');\n\n    if (typeIndex === -1) {\n      throw new Error('No \"type\" found in the input string');\n    }\n    // Return the index of the `\"type\":` key\n    return BigInt(typeIndex);\n  } catch (error) {\n    // Handle any errors that occur during the search\n    throw new Error('No \"type\" found in the input string', {\n      cause: error,\n    });\n  }\n};\n\n/**\n * Encodes a signature to a hexadecimal signature that will be accepted\n * by the DeleGator contracts.\n * @param keyId - The key used for the signature, represented as a hexadecimal string.\n * @param signature - The signature to convert, as Hex.\n * @param clientDataJSON - The client data used in the creation of the signature.\n * @param authenticatorData - The authenticator data used in the creation of the signature.\n * @returns The signature as a valid DeleGator signature encoded as Hexadecimal string.\n */\nexport function encodeDeleGatorSignature(\n  keyId: string,\n  signature: Hex,\n  clientDataJSON: string,\n  authenticatorData: Hex,\n): Hex {\n  const keyIdHash = keccak256(encodePacked(['string'], [keyId]));\n\n  const parsedSignature = parseSignature(signature);\n\n  let { s } = parsedSignature;\n\n  while (s > MALLEABILITY_THRESHOLD) {\n    s = FIELD_MODULUS - s;\n  }\n\n  const { r } = parsedSignature;\n\n  const [clientDataComponent1, clientDataComponent2] =\n    splitOnChallenge(clientDataJSON);\n\n  const { userVerified } = parseAuthenticatorFlags(authenticatorData);\n\n  const responseTypeLocation = getResponseTypeLocation(clientDataJSON);\n\n  const encodedSignature = encodeAbiParameters(SIGNATURE_ABI_PARAMS, [\n    keyIdHash,\n    r,\n    s,\n    authenticatorData,\n    userVerified,\n    clientDataComponent1,\n    clientDataComponent2,\n    responseTypeLocation,\n  ]);\n  return encodedSignature;\n}\n\nconst AUTHENTICATOR_DATA_FLAGS_OFFSET = 32;\n// We have all of the flag bits defined here for completeness, even though we only extract the userVerified flag.\nenum AuthenticatorDataFlagBitIndex {\n  UserPresence = 0,\n  UserVerified = 2,\n  BackupEligibility = 3,\n  BackupState = 4,\n  AttestedCredentialData = 6,\n  ExtensionData = 7,\n}\n\nexport type AuthenticatorFlags = {\n  userVerified: boolean;\n};\n\n/**\n * Parses the authenticator data and returns an authenticator flags object with the `userVerified` flag.\n * See https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data.\n * @param authenticatorData - The authenticator data to parse.\n * @returns An object representing the parsed authenticator flags.\n */\nexport function parseAuthenticatorFlags(\n  authenticatorData: Hex,\n): AuthenticatorFlags {\n  // eslint-disable-next-line no-restricted-globals\n  const authenticatorDataBuffer = Buffer.from(\n    authenticatorData.slice(2),\n    'hex',\n  );\n  const flags = authenticatorDataBuffer.readUInt8(\n    AUTHENTICATOR_DATA_FLAGS_OFFSET,\n  );\n\n  // Bit 0 is the least significant bit in the flags byte, so we left shift 0b1 by the bit index\n  // eslint-disable-next-line no-bitwise\n  const bitMask = 0b1 << AuthenticatorDataFlagBitIndex.UserVerified;\n\n  return {\n    // eslint-disable-next-line no-bitwise\n    userVerified: (flags & bitMask) !== 0x0,\n  };\n}\n\n/**\n * Creates a dummy signature.\n * This must meet all early-failure conditions of the real signature, but does not need to be a valid signature.\n * @param keyId - The key ID to use for the dummy signature.\n * @returns The encoded signature.\n */\nexport const createDummyWebAuthnSignature = (keyId: Hex) => {\n  // https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API/Authenticator_data#data_structure\n  const rpIdHash = keccak256(encodePacked(['string'], ['AuthenticatorData']));\n  const flags = '0x05';\n  const signCount = '0x00000000';\n  const authenticatorData = concat([rpIdHash, flags, signCount]);\n\n  const keyIdHash = keccak256(encodePacked(['string'], [keyId]));\n  const rs =\n    57896044605178124381348723474703786764998477612067880171211129530534256022184n;\n  const userVerification = true;\n  const clientDataPrefix = '{\"type\":\"webauthn.get\",\"challenge\":\"';\n  const clientDataSuffix = '\",\"origin\":\"passkey-domain\",\"crossOrigin\":false}';\n  const responseTypeLocation = 1n;\n\n  const encodedSignature = encodeAbiParameters(SIGNATURE_ABI_PARAMS, [\n    keyIdHash,\n    rs,\n    rs,\n    authenticatorData,\n    userVerification,\n    clientDataPrefix,\n    clientDataSuffix,\n    responseTypeLocation,\n  ]);\n\n  return encodedSignature;\n};\n"],"names":["Implementation","encode","encode"],"mappings":"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"}},
    {"offset": {"line": 2581, "column": 0}, "map": {"version":3,"sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/ERC20PeriodTransferEnforcer/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/ERC20PeriodTransferEnforcer/read.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/ERC20PeriodTransferEnforcer/methods/getAvailableAmount.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/ERC20StreamingEnforcer/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/ERC20StreamingEnforcer/read.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/ERC20StreamingEnforcer/methods/getAvailableAmount.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/MultiTokenPeriodEnforcer/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/MultiTokenPeriodEnforcer/read.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/MultiTokenPeriodEnforcer/methods/getAvailableAmount.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/NativeTokenPeriodTransferEnforcer/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/NativeTokenPeriodTransferEnforcer/read.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/NativeTokenPeriodTransferEnforcer/methods/getAvailableAmount.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/NativeTokenStreamingEnforcer/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/NativeTokenStreamingEnforcer/read.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/NativeTokenStreamingEnforcer/methods/getAvailableAmount.ts"],"sourcesContent":["import * as read from './read';\n\nexport { read };\n","import { read as getAvailableAmount } from './methods/getAvailableAmount';\n\nexport { getAvailableAmount };\n","import { ERC20PeriodTransferEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetAvailableAmountParameters = {\n  client: Client;\n  contractAddress: Address;\n  delegationHash: Hex;\n  delegationManager: Address;\n  terms: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  delegationHash,\n  delegationManager,\n  terms,\n}: ReadGetAvailableAmountParameters) => {\n  const [availableAmount, isNewPeriod, currentPeriod] = await readContract(\n    client,\n    {\n      address: contractAddress,\n      abi: ERC20PeriodTransferEnforcer.abi,\n      functionName: 'getAvailableAmount',\n      args: [delegationHash, delegationManager, terms],\n    },\n  );\n\n  return {\n    availableAmount,\n    isNewPeriod,\n    currentPeriod,\n  };\n};\n","import * as read from './read';\n\nexport { read };\n","import { read as getAvailableAmount } from './methods/getAvailableAmount';\n\nexport { getAvailableAmount };\n","import { ERC20StreamingEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract, getBlock } from 'viem/actions';\n\nexport type ReadGetAvailableAmountParameters = {\n  client: Client;\n  contractAddress: Address;\n  delegationManager: Address;\n  delegationHash: Hex;\n  terms: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  delegationManager,\n  delegationHash,\n  terms,\n}: ReadGetAvailableAmountParameters) => {\n  // Get current block timestamp from blockchain\n  const currentBlock = await getBlock(client);\n  const currentTimestamp = currentBlock.timestamp;\n\n  // First, get the current state from the contract\n  const allowanceState = await readContract(client, {\n    address: contractAddress,\n    abi: ERC20StreamingEnforcer.abi,\n    functionName: 'streamingAllowances',\n    args: [delegationManager, delegationHash],\n  });\n\n  const [initialAmount, maxAmount, amountPerSecond, startTime, spent] =\n    allowanceState;\n\n  // Check if state exists (startTime != 0)\n  if (startTime !== 0n) {\n    // State exists, calculate available amount using the stored state\n    const availableAmount = getAvailableAmount({\n      initialAmount,\n      maxAmount,\n      amountPerSecond,\n      startTime,\n      spent,\n      currentTimestamp,\n    });\n\n    return {\n      availableAmount,\n    };\n  }\n\n  // State doesn't exist, decode terms and simulate with spent = 0\n  const decodedTerms = await readContract(client, {\n    address: contractAddress,\n    abi: ERC20StreamingEnforcer.abi,\n    functionName: 'getTermsInfo',\n    args: [terms],\n  });\n\n  const [\n    ,\n    decodedInitialAmount,\n    decodedMaxAmount,\n    decodedAmountPerSecond,\n    decodedStartTime,\n  ] = decodedTerms;\n\n  // Simulate using decoded terms with spent = 0\n  const availableAmount = getAvailableAmount({\n    initialAmount: decodedInitialAmount,\n    maxAmount: decodedMaxAmount,\n    amountPerSecond: decodedAmountPerSecond,\n    startTime: decodedStartTime,\n    spent: 0n,\n    currentTimestamp,\n  });\n\n  return {\n    availableAmount,\n  };\n};\n\n/**\n * Replicates the internal _getAvailableAmount logic from the smart contract.\n *\n * @param allowance - The allowance object containing all parameters.\n * @param allowance.initialAmount - The initial amount available.\n * @param allowance.maxAmount - The maximum amount allowed.\n * @param allowance.amountPerSecond - The amount streamed per second.\n * @param allowance.startTime - The start time of the streaming.\n * @param allowance.spent - The amount already spent.\n * @param allowance.currentTimestamp - The current timestamp.\n * @returns The available amount that can be spent.\n */\nfunction getAvailableAmount(allowance: {\n  initialAmount: bigint;\n  maxAmount: bigint;\n  amountPerSecond: bigint;\n  startTime: bigint;\n  spent: bigint;\n  currentTimestamp: bigint;\n}): bigint {\n  // If current time is before start time, nothing is available\n  if (allowance.currentTimestamp < allowance.startTime) {\n    return 0n;\n  }\n\n  // Calculate elapsed time since start\n  const elapsed = allowance.currentTimestamp - allowance.startTime;\n\n  // Calculate total unlocked amount\n  let unlocked = allowance.initialAmount + allowance.amountPerSecond * elapsed;\n\n  // Cap by max amount\n  if (unlocked > allowance.maxAmount) {\n    unlocked = allowance.maxAmount;\n  }\n\n  // If spent >= unlocked, nothing available\n  if (allowance.spent >= unlocked) {\n    return 0n;\n  }\n\n  // Return available amount\n  return unlocked - allowance.spent;\n}\n","import * as read from './read';\n\nexport { read };\n","import { read as getAvailableAmount } from './methods/getAvailableAmount';\n\nexport { getAvailableAmount };\n","import { MultiTokenPeriodEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetAvailableAmountParameters = {\n  client: Client;\n  contractAddress: Address;\n  delegationHash: Hex;\n  delegationManager: Address;\n  terms: Hex;\n  args: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  delegationHash,\n  delegationManager,\n  terms,\n  args,\n}: ReadGetAvailableAmountParameters) => {\n  const [availableAmount, isNewPeriod, currentPeriod] = await readContract(\n    client,\n    {\n      address: contractAddress,\n      abi: MultiTokenPeriodEnforcer.abi,\n      functionName: 'getAvailableAmount',\n      args: [delegationHash, delegationManager, terms, args],\n    },\n  );\n\n  return {\n    availableAmount,\n    isNewPeriod,\n    currentPeriod,\n  };\n};\n","import * as read from './read';\n\nexport { read };\n","import { read as getAvailableAmount } from './methods/getAvailableAmount';\n\nexport { getAvailableAmount };\n","import { NativeTokenPeriodTransferEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetAvailableAmountParameters = {\n  client: Client;\n  contractAddress: Address;\n  delegationHash: Hex;\n  delegationManager: Address;\n  terms: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  delegationHash,\n  delegationManager,\n  terms,\n}: ReadGetAvailableAmountParameters) => {\n  const [availableAmount, isNewPeriod, currentPeriod] = await readContract(\n    client,\n    {\n      address: contractAddress,\n      abi: NativeTokenPeriodTransferEnforcer.abi,\n      functionName: 'getAvailableAmount',\n      args: [delegationHash, delegationManager, terms],\n    },\n  );\n\n  return {\n    availableAmount,\n    isNewPeriod,\n    currentPeriod,\n  };\n};\n","import * as read from './read';\n\nexport { read };\n","import { read as getAvailableAmount } from './methods/getAvailableAmount';\n\nexport { getAvailableAmount };\n","import { NativeTokenStreamingEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract, getBlock } from 'viem/actions';\n\nexport type ReadGetAvailableAmountParameters = {\n  client: Client;\n  contractAddress: Address;\n  delegationManager: Address;\n  delegationHash: Hex;\n  terms: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  delegationManager,\n  delegationHash,\n  terms,\n}: ReadGetAvailableAmountParameters) => {\n  // Get current block timestamp from blockchain\n  const currentBlock = await getBlock(client);\n  const currentTimestamp = currentBlock.timestamp;\n\n  // First, get the current state from the contract\n  const allowanceState = await readContract(client, {\n    address: contractAddress,\n    abi: NativeTokenStreamingEnforcer.abi,\n    functionName: 'streamingAllowances',\n    args: [delegationManager, delegationHash],\n  });\n\n  const [initialAmount, maxAmount, amountPerSecond, startTime, spent] =\n    allowanceState;\n\n  // Check if state exists (startTime != 0)\n  if (startTime !== 0n) {\n    // State exists, calculate available amount using the stored state\n    const availableAmount = getAvailableAmount({\n      initialAmount,\n      maxAmount,\n      amountPerSecond,\n      startTime,\n      spent,\n      currentTimestamp,\n    });\n\n    return {\n      availableAmount,\n    };\n  }\n\n  // State doesn't exist, decode terms and simulate with spent = 0\n  const decodedTerms = await readContract(client, {\n    address: contractAddress,\n    abi: NativeTokenStreamingEnforcer.abi,\n    functionName: 'getTermsInfo',\n    args: [terms],\n  });\n\n  const [\n    decodedInitialAmount,\n    decodedMaxAmount,\n    decodedAmountPerSecond,\n    decodedStartTime,\n  ] = decodedTerms;\n\n  // Simulate using decoded terms with spent = 0\n  const availableAmount = getAvailableAmount({\n    initialAmount: decodedInitialAmount,\n    maxAmount: decodedMaxAmount,\n    amountPerSecond: decodedAmountPerSecond,\n    startTime: decodedStartTime,\n    spent: 0n,\n    currentTimestamp,\n  });\n\n  return {\n    availableAmount,\n  };\n};\n\n/**\n * Replicates the internal _getAvailableAmount logic from the smart contract.\n *\n * @param allowance - The allowance object containing all parameters.\n * @param allowance.initialAmount - The initial amount available.\n * @param allowance.maxAmount - The maximum amount allowed.\n * @param allowance.amountPerSecond - The amount streamed per second.\n * @param allowance.startTime - The start time of the streaming.\n * @param allowance.spent - The amount already spent.\n * @param allowance.currentTimestamp - The current timestamp.\n * @returns The available amount that can be spent.\n */\nfunction getAvailableAmount(allowance: {\n  initialAmount: bigint;\n  maxAmount: bigint;\n  amountPerSecond: bigint;\n  startTime: bigint;\n  spent: bigint;\n  currentTimestamp: bigint;\n}): bigint {\n  // If current time is before start time, nothing is available\n  if (allowance.currentTimestamp < allowance.startTime) {\n    return 0n;\n  }\n\n  // Calculate elapsed time since start\n  const elapsed = allowance.currentTimestamp - allowance.startTime;\n\n  // Calculate total unlocked amount\n  let unlocked = allowance.initialAmount + allowance.amountPerSecond * elapsed;\n\n  // Cap by max amount\n  if (unlocked > allowance.maxAmount) {\n    unlocked = allowance.maxAmount;\n  }\n\n  // If spent >= unlocked, nothing available\n  if (allowance.spent >= unlocked) {\n    return 0n;\n  }\n\n  // Return available amount\n  return unlocked - allowance.spent;\n}\n"],"names":["read_exports","read_exports","read","readContract","read","availableAmount","read_exports","read_exports","read","readContract","read","read_exports","read_exports","read","readContract","read","read_exports","read_exports","read","readContract","getBlock","read","availableAmount","getAvailableAmount"],"mappings":"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"}},
    {"offset": {"line": 2849, "column": 0}, "map": {"version":3,"sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/userOp.ts"],"sourcesContent":["import { concat, encodeAbiParameters, keccak256, pad, toHex } from 'viem';\nimport type { Address, Hex, TypedData } from 'viem';\nimport { toPackedUserOperation } from 'viem/account-abstraction';\nimport { signTypedData } from 'viem/accounts';\n\nimport type { OptionalUserOpProps, PackedUserOperationStruct } from './types';\n\n// v7 off-chain user operation, hexlified incoming data from rpc call\nexport type UserOperationV07Hexlify = {\n  sender: Hex;\n  nonce: Hex;\n  factory?: Hex;\n  factoryData?: Hex;\n  callData: Hex;\n  callGasLimit: Hex;\n\n  verificationGasLimit: Hex;\n  preVerificationGas: Hex;\n  maxFeePerGas: Hex;\n  maxPriorityFeePerGas: Hex;\n\n  paymaster?: Hex;\n  paymasterVerificationGasLimit?: Hex;\n  paymasterPostOpGasLimit?: Hex;\n  paymasterData?: Hex;\n\n  signature: Hex;\n};\n\n// v7 off-chain user operation with BigInt fields\nexport type UserOperationV07 = {\n  sender: Hex;\n  nonce: bigint;\n  factory?: Hex;\n  factoryData?: Hex;\n  callData: Hex;\n\n  callGasLimit: bigint;\n  verificationGasLimit: bigint;\n  preVerificationGas: bigint;\n  maxFeePerGas: bigint;\n  maxPriorityFeePerGas: bigint;\n\n  paymaster?: Hex;\n  paymasterVerificationGasLimit?: bigint;\n  paymasterPostOpGasLimit?: bigint;\n  paymasterData?: Hex;\n\n  signature: Hex;\n};\n\n/**\n * Creates a raw user operation data structure.\n * @param sender - The smart account taking some action.\n * @param nonce - A nonce, ideally fetched from the Entry Point.\n * @param callData - Calldata to invoke on some contract.\n * @param signature - The signature for the user operation.\n * @param options - Optional properties for the user operation.\n * @returns The created raw user operation data structure.\n */\nexport const createRawUserOp = (\n  sender: Hex,\n  nonce: bigint,\n  callData: Hex,\n  signature: Hex = '0x',\n  options?: OptionalUserOpProps,\n): UserOperationV07 => ({\n  sender,\n  nonce,\n  callData,\n  factory: options?.factory,\n  factoryData: options?.factoryData,\n  callGasLimit: options?.callGasLimit ?? 0n,\n  verificationGasLimit: options?.verificationGasLimit ?? 0n,\n  preVerificationGas: options?.preVerificationGas ?? 0n,\n  maxFeePerGas: options?.maxFeePerGas ?? 0n,\n  maxPriorityFeePerGas: options?.maxPriorityFeePerGas ?? 0n,\n  paymaster: options?.paymaster,\n  paymasterVerificationGasLimit: options?.paymasterVerificationGasLimit,\n  paymasterPostOpGasLimit: options?.paymasterPostOpGasLimit,\n  paymasterData: options?.paymasterData,\n  signature,\n});\n\n// //////////////////////////////////////////////////////////////////////////////////////\n\n// TODO: These userOp functions are duplicated in ./apps/ew-client/src/utils/userOpBuilder.ts. We should move them to a shared location along with test(./apps/ew-client/test/UserOpBuilder.test.ts) to avoid duplication\n/**\n * Generates a salt value for address derivation.\n * @param salt - Optional salt value.\n * @returns The chosen salt value.\n */\nexport const getSalt = (salt?: Hex): Hex => {\n  return salt ?? '0x0';\n};\n\nexport const getPaymasterAndData = (userOp: UserOperationV07): Hex => {\n  let paymasterAndData: Hex;\n  if (userOp.paymaster) {\n    paymasterAndData = concat([\n      userOp.paymaster,\n      pad(toHex(userOp.paymasterVerificationGasLimit ?? 0n), {\n        size: 16,\n      }),\n      pad(toHex(userOp.paymasterPostOpGasLimit ?? 0n), {\n        size: 16,\n      }),\n      userOp.paymasterData ?? '0x',\n    ]);\n  } else {\n    paymasterAndData = '0x';\n  }\n\n  return paymasterAndData;\n};\n\nexport const getInitCode = (userOp: UserOperationV07): Hex => {\n  return userOp.factory\n    ? concat([userOp.factory, userOp.factoryData ?? ('0x' as Hex)])\n    : '0x';\n};\n\nexport const getAccountGasLimits = (userOp: UserOperationV07): Hex => {\n  return concat([\n    pad(toHex(userOp.verificationGasLimit), {\n      size: 16,\n    }),\n    pad(toHex(userOp.callGasLimit), { size: 16 }),\n  ]);\n};\n\nexport const getGasFees = (userOp: UserOperationV07): Hex => {\n  return concat([\n    pad(toHex(userOp.maxPriorityFeePerGas), {\n      size: 16,\n    }),\n    pad(toHex(userOp.maxFeePerGas), { size: 16 }),\n  ]);\n};\n\n/**\n * Packs a user operation into a `PackedUserOperationStruct` object.\n *\n * @param userOp - The user operation to pack.\n * @returns The packed user operation.\n */\nexport const packUserOp = (\n  userOp: UserOperationV07,\n): PackedUserOperationStruct => {\n  const packedOp = {\n    sender: userOp.sender,\n    nonce: BigInt(userOp.nonce),\n    initCode: getInitCode(userOp),\n    callData: userOp.callData,\n    accountGasLimits: getAccountGasLimits(userOp),\n    preVerificationGas: BigInt(userOp.preVerificationGas),\n    gasFees: getGasFees(userOp),\n    paymasterAndData: getPaymasterAndData(userOp),\n    signature: userOp.signature,\n  };\n\n  return packedOp;\n};\n\n/**\n * Calculates the user operation hash for a given packed user operation.\n * @param packedOp - The packed user operation.\n * @param entryPoint - The entry point address.\n * @param chainId - The chain ID.\n * @returns The user operation hash.\n */\nexport const createUserOpHashV07 = (\n  packedOp: PackedUserOperationStruct,\n  entryPoint: Hex,\n  chainId: bigint,\n) => {\n  const hash = keccak256(\n    encodeAbiParameters(\n      [\n        {\n          name: 'sender',\n          type: 'address',\n        },\n        {\n          name: 'nonce',\n          type: 'uint256',\n        },\n        {\n          name: 'initCodeHash',\n          type: 'bytes32',\n        },\n        {\n          name: 'callDataHash',\n          type: 'bytes32',\n        },\n        {\n          name: 'accountGasLimits',\n          type: 'bytes32',\n        },\n        {\n          name: 'preVerificationGas',\n          type: 'uint256',\n        },\n        {\n          name: 'gasFees',\n          type: 'bytes32',\n        },\n        {\n          name: 'paymasterAndDataHash',\n          type: 'bytes32',\n        },\n      ],\n      [\n        packedOp.sender,\n        packedOp.nonce,\n        keccak256(packedOp.initCode),\n        keccak256(packedOp.callData),\n        packedOp.accountGasLimits,\n        packedOp.preVerificationGas,\n        packedOp.gasFees,\n        keccak256(packedOp.paymasterAndData),\n      ],\n    ),\n  );\n\n  return keccak256(\n    encodeAbiParameters(\n      [\n        {\n          name: 'userOpHash',\n          type: 'bytes32',\n        },\n        {\n          name: 'entryPointAddress',\n          type: 'address',\n        },\n        {\n          name: 'chainId',\n          type: 'uint256',\n        },\n      ],\n      [hash, entryPoint, chainId],\n    ),\n  );\n};\n\nexport const SIGNABLE_USER_OP_TYPED_DATA: TypedData = {\n  PackedUserOperation: [\n    { name: 'sender', type: 'address' },\n    { name: 'nonce', type: 'uint256' },\n    { name: 'initCode', type: 'bytes' },\n    { name: 'callData', type: 'bytes' },\n    { name: 'accountGasLimits', type: 'bytes32' },\n    { name: 'preVerificationGas', type: 'uint256' },\n    { name: 'gasFees', type: 'bytes32' },\n    { name: 'paymasterAndData', type: 'bytes' },\n    { name: 'entryPoint', type: 'address' },\n  ],\n} as const;\n\n/**\n * Prepares typed data for user operation signing.\n * This is an internal helper function that's not exposed in the public API.\n *\n * @param params - The parameters for preparing the typed data.\n * @param params.userOperation - The user operation to prepare for signing.\n * @param params.entryPoint - The entry point contract address.\n * @param params.entryPoint.address - The address of the entry point contract.\n * @param params.chainId - The chain ID that the entry point is deployed on.\n * @param params.name - The name of the domain of the implementation contract.\n * @param params.version - The version of the domain of the implementation contract.\n * @param params.address - The address of the smart account.\n * @returns The prepared typed data for signing.\n */\nexport const prepareSignUserOperationTypedData = ({\n  userOperation,\n  entryPoint,\n  chainId,\n  name,\n  address,\n  version = '1',\n}: {\n  userOperation: Omit<UserOperationV07, 'signature'>;\n  entryPoint: { address: Address };\n  chainId: number;\n  name: 'HybridDeleGator' | 'MultiSigDeleGator';\n  address: Address;\n  version?: string;\n}) => {\n  const packedUserOp = toPackedUserOperation({\n    ...userOperation,\n    signature: '0x',\n  });\n\n  return {\n    domain: {\n      chainId,\n      name,\n      version,\n      verifyingContract: address,\n    },\n    types: SIGNABLE_USER_OP_TYPED_DATA,\n    primaryType: 'PackedUserOperation' as const,\n    message: { ...packedUserOp, entryPoint: entryPoint.address },\n  };\n};\n\n/**\n * Signs a user operation using a private key.\n * @param params - The parameters for signing the user operation.\n * @param params.privateKey - The private key to use for signing.\n * @param params.userOperation - The user operation to sign.\n * @param params.entryPoint - The entry point contract address.\n * @param params.chainId - The chain ID that the entry point is deployed on.\n * @param params.name - The name of the domain of the implementation contract.\n * @param params.version - The version of the domain of the implementation contract.\n * @param params.address - The address of the smart account.\n * @param params.entryPoint.address - The address of the entry point contract.\n * @returns The signature of the user operation.\n */\nexport const signUserOperation = async ({\n  privateKey,\n  userOperation,\n  entryPoint,\n  chainId,\n  name,\n  address,\n  version = '1',\n}: {\n  privateKey: Hex;\n  userOperation: Omit<UserOperationV07, 'signature'>;\n  entryPoint: { address: Address };\n  chainId: number;\n  address: Address;\n  name: 'HybridDeleGator' | 'MultiSigDeleGator';\n  version?: string;\n}) => {\n  const typedData = prepareSignUserOperationTypedData({\n    userOperation,\n    entryPoint,\n    chainId,\n    name,\n    address,\n    version,\n  });\n\n  return signTypedData({\n    privateKey,\n    ...typedData,\n  });\n};\n"],"names":[],"mappings":";;;;;;;;;AAEA,SAAS,6BAA6B;AACtC,SAAS,qBAAqB;;;;AAmPvB,IAAM,8BAAyC;IACpD,qBAAqB;QACnB;YAAE,MAAM;YAAU,MAAM;QAAU;QAClC;YAAE,MAAM;YAAS,MAAM;QAAU;QACjC;YAAE,MAAM;YAAY,MAAM;QAAQ;QAClC;YAAE,MAAM;YAAY,MAAM;QAAQ;QAClC;YAAE,MAAM;YAAoB,MAAM;QAAU;QAC5C;YAAE,MAAM;YAAsB,MAAM;QAAU;QAC9C;YAAE,MAAM;YAAW,MAAM;QAAU;QACnC;YAAE,MAAM;YAAoB,MAAM;QAAQ;QAC1C;YAAE,MAAM;YAAc,MAAM;QAAU;KACxC;AACF;AAgBO,IAAM,oCAAoC,CAAC,EAChD,aAAA,EACA,UAAA,EACA,OAAA,EACA,IAAA,EACA,OAAA,EACA,UAAU,GAAA,EACZ,KAOM;IACJ,MAAM,mBAAe,qOAAA,EAAsB;QACzC,GAAG,aAAA;QACH,WAAW;IACb,CAAC;IAED,OAAO;QACL,QAAQ;YACN;YACA;YACA;YACA,mBAAmB;QACrB;QACA,OAAO;QACP,aAAa;QACb,SAAS;YAAE,GAAG,YAAA;YAAc,YAAY,WAAW,OAAA;QAAQ;IAC7D;AACF;AAeO,IAAM,oBAAoB,OAAO,EACtC,UAAA,EACA,aAAA,EACA,UAAA,EACA,OAAA,EACA,IAAA,EACA,OAAA,EACA,UAAU,GAAA,EACZ,KAQM;IACJ,MAAM,YAAY,kCAAkC;QAClD;QACA;QACA;QACA;QACA;QACA;IACF,CAAC;IAED,WAAO,sLAAA,EAAc;QACnB;QACA,GAAG,SAAA;IACL,CAAC;AACH"}},
    {"offset": {"line": 2943, "column": 0}, "map": {"version":3,"sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/actions/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/actions/getCaveatAvailableAmount.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/actions/isValid7702Implementation.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/actions/signDelegation.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/actions/signUserOperation.ts"],"sourcesContent":["/* eslint-disable */\n// experimental actions will be moved here once they have stabilized\n\nexport {\n  // Individual action functions\n  getErc20PeriodTransferEnforcerAvailableAmount,\n  getErc20StreamingEnforcerAvailableAmount,\n  getMultiTokenPeriodEnforcerAvailableAmount,\n  getNativeTokenPeriodTransferEnforcerAvailableAmount,\n  getNativeTokenStreamingEnforcerAvailableAmount,\n  // Action builder\n  caveatEnforcerActions,\n  // Parameter types\n  type CaveatEnforcerParams,\n  // Result types\n  type PeriodTransferResult,\n  type StreamingResult,\n} from './getCaveatAvailableAmount';\n\nexport { isValid7702Implementation } from './isValid7702Implementation';\n\n// Signing actions\nexport {\n  signDelegation,\n  signDelegationActions,\n  type SignDelegationParameters,\n  type SignDelegationReturnType,\n} from './signDelegation';\n\nexport {\n  signUserOperation,\n  signUserOperationActions,\n  type SignUserOperationParameters,\n  type SignUserOperationReturnType,\n} from './signUserOperation';\n","import type { Address, Hex, Client } from 'viem';\n\nimport { getDelegationHashOffchain } from '../delegation';\nimport * as ERC20PeriodTransferEnforcer from '../DelegationFramework/ERC20PeriodTransferEnforcer';\nimport * as ERC20StreamingEnforcer from '../DelegationFramework/ERC20StreamingEnforcer';\nimport * as MultiTokenPeriodEnforcer from '../DelegationFramework/MultiTokenPeriodEnforcer';\nimport * as NativeTokenPeriodTransferEnforcer from '../DelegationFramework/NativeTokenPeriodTransferEnforcer';\nimport * as NativeTokenStreamingEnforcer from '../DelegationFramework/NativeTokenStreamingEnforcer';\nimport type { DeleGatorEnvironment, Delegation } from '../types';\n\n/**\n * Parameters for all caveat enforcer actions.\n */\nexport type CaveatEnforcerParams = {\n  delegation: Delegation;\n};\n\n/**\n * Return type for period-based transfer enforcers\n */\nexport type PeriodTransferResult = {\n  availableAmount: bigint;\n  isNewPeriod: boolean;\n  currentPeriod: bigint;\n};\n\n/**\n * Return type for streaming enforcers\n */\nexport type StreamingResult = {\n  availableAmount: bigint;\n};\n\n/**\n * Finds a caveat that matches the specified enforcer address.\n * @param config - The configuration object.\n * @param config.delegation - The delegation to search.\n * @param config.enforcerAddress - The enforcer address to match.\n * @param config.enforcerName - The name of the enforcer.\n * @returns The matching caveat.\n * @throws Error if no matching caveat is found.\n * @throws Error if multiple matching caveats are found.\n */\nfunction findMatchingCaveat({\n  delegation,\n  enforcerAddress,\n  enforcerName,\n}: {\n  delegation: Delegation;\n  enforcerAddress: Address;\n  enforcerName: keyof DeleGatorEnvironment['caveatEnforcers'];\n}): { terms: Hex; args: Hex } {\n  const matchingCaveats = delegation.caveats.filter(\n    (caveat) => caveat.enforcer.toLowerCase() === enforcerAddress.toLowerCase(),\n  );\n\n  if (matchingCaveats.length === 0) {\n    throw new Error(`No caveat found with enforcer matching ${enforcerName}`);\n  }\n\n  if (matchingCaveats.length > 1) {\n    throw new Error(\n      `Multiple caveats found with enforcer matching ${enforcerName}`,\n    );\n  }\n\n  const [{ terms, args }] = matchingCaveats as unknown as [\n    { terms: Hex; args: Hex },\n  ];\n\n  return {\n    terms,\n    args,\n  };\n}\n\n/**\n * Gets the delegation manager address from environment.\n *\n * @param environment - The delegator environment.\n * @returns The delegation manager address.\n */\nfunction getDelegationManager(environment: DeleGatorEnvironment): Address {\n  if (!environment.DelegationManager) {\n    throw new Error('Delegation manager address not found');\n  }\n\n  return environment.DelegationManager;\n}\n\n/**\n * Gets the enforcer address from environment.\n *\n * @param config - The configuration object.\n * @param config.enforcerName - The name of the enforcer.\n * @param config.environment - The delegator environment.\n * @returns The enforcer address.\n */\nfunction getEnforcerAddress({\n  enforcerName,\n  environment,\n}: {\n  enforcerName: keyof DeleGatorEnvironment['caveatEnforcers'];\n  environment: DeleGatorEnvironment;\n}): Address {\n  const enforcerAddress = environment.caveatEnforcers[enforcerName];\n  if (!enforcerAddress) {\n    throw new Error(`${enforcerName} not found in environment`);\n  }\n\n  return enforcerAddress;\n}\n\n/**\n * Get available amount for ERC20 period transfer enforcer.\n *\n * @param client - The viem client.\n * @param environment - The delegator environment.\n * @param params - The parameters for the ERC20 period transfer enforcer.\n * @returns Promise resolving to the period transfer result.\n */\nexport async function getErc20PeriodTransferEnforcerAvailableAmount(\n  client: Client,\n  environment: DeleGatorEnvironment,\n  params: CaveatEnforcerParams,\n): Promise<PeriodTransferResult> {\n  const enforcerName = 'ERC20PeriodTransferEnforcer';\n\n  const delegationManager = getDelegationManager(environment);\n  const enforcerAddress = getEnforcerAddress({\n    enforcerName,\n    environment,\n  });\n\n  const delegationHash = getDelegationHashOffchain(params.delegation);\n  const { terms } = findMatchingCaveat({\n    delegation: params.delegation,\n    enforcerAddress,\n    enforcerName,\n  });\n\n  return ERC20PeriodTransferEnforcer.read.getAvailableAmount({\n    client,\n    contractAddress: enforcerAddress,\n    delegationHash,\n    delegationManager,\n    terms,\n  });\n}\n\n/**\n * Get available amount for ERC20 streaming enforcer.\n *\n * @param client - The viem client.\n * @param environment - The delegator environment.\n * @param params - The parameters for the ERC20 streaming enforcer.\n * @returns Promise resolving to the streaming result.\n */\nexport async function getErc20StreamingEnforcerAvailableAmount(\n  client: Client,\n  environment: DeleGatorEnvironment,\n  params: CaveatEnforcerParams,\n): Promise<StreamingResult> {\n  const enforcerName = 'ERC20StreamingEnforcer';\n  const delegationManager = getDelegationManager(environment);\n  const enforcerAddress = getEnforcerAddress({\n    enforcerName,\n    environment,\n  });\n\n  const delegationHash = getDelegationHashOffchain(params.delegation);\n  const { terms } = findMatchingCaveat({\n    delegation: params.delegation,\n    enforcerAddress,\n    enforcerName,\n  });\n\n  return ERC20StreamingEnforcer.read.getAvailableAmount({\n    client,\n    contractAddress: enforcerAddress,\n    delegationManager,\n    delegationHash,\n    terms,\n  });\n}\n\n/**\n * Get available amount for multi-token period enforcer.\n *\n * @param client - The viem client.\n * @param environment - The delegator environment.\n * @param params - The parameters for the multi-token period enforcer.\n * @returns Promise resolving to the period transfer result.\n */\nexport async function getMultiTokenPeriodEnforcerAvailableAmount(\n  client: Client,\n  environment: DeleGatorEnvironment,\n  params: CaveatEnforcerParams,\n): Promise<PeriodTransferResult> {\n  const enforcerName = 'MultiTokenPeriodEnforcer';\n  const delegationManager = getDelegationManager(environment);\n  const enforcerAddress = getEnforcerAddress({\n    enforcerName,\n    environment,\n  });\n\n  const delegationHash = getDelegationHashOffchain(params.delegation);\n  const { terms, args } = findMatchingCaveat({\n    delegation: params.delegation,\n    enforcerAddress,\n    enforcerName,\n  });\n\n  return MultiTokenPeriodEnforcer.read.getAvailableAmount({\n    client,\n    contractAddress: enforcerAddress,\n    delegationHash,\n    delegationManager,\n    terms,\n    args,\n  });\n}\n\n/**\n * Get available amount for native token period transfer enforcer.\n *\n * @param client - The viem client.\n * @param environment - The delegator environment.\n * @param params - The parameters for the native token period transfer enforcer.\n * @returns Promise resolving to the period transfer result.\n */\nexport async function getNativeTokenPeriodTransferEnforcerAvailableAmount(\n  client: Client,\n  environment: DeleGatorEnvironment,\n  params: CaveatEnforcerParams,\n): Promise<PeriodTransferResult> {\n  const enforcerName = 'NativeTokenPeriodTransferEnforcer';\n  const delegationManager = getDelegationManager(environment);\n  const enforcerAddress = getEnforcerAddress({\n    enforcerName,\n    environment,\n  });\n\n  const delegationHash = getDelegationHashOffchain(params.delegation);\n  const { terms } = findMatchingCaveat({\n    delegation: params.delegation,\n    enforcerAddress,\n    enforcerName,\n  });\n\n  return NativeTokenPeriodTransferEnforcer.read.getAvailableAmount({\n    client,\n    contractAddress: enforcerAddress,\n    delegationHash,\n    delegationManager,\n    terms,\n  });\n}\n\n/**\n * Get available amount for native token streaming enforcer.\n *\n * @param client - The viem client.\n * @param environment - The delegator environment.\n * @param params - The parameters for the native token streaming enforcer.\n * @returns Promise resolving to the streaming result.\n */\nexport async function getNativeTokenStreamingEnforcerAvailableAmount(\n  client: Client,\n  environment: DeleGatorEnvironment,\n  params: CaveatEnforcerParams,\n): Promise<StreamingResult> {\n  const enforcerName = 'NativeTokenStreamingEnforcer';\n  const delegationManager = getDelegationManager(environment);\n  const enforcerAddress = getEnforcerAddress({\n    enforcerName,\n    environment,\n  });\n\n  const delegationHash = getDelegationHashOffchain(params.delegation);\n  const { terms } = findMatchingCaveat({\n    delegation: params.delegation,\n    enforcerAddress,\n    enforcerName,\n  });\n\n  return NativeTokenStreamingEnforcer.read.getAvailableAmount({\n    client,\n    contractAddress: enforcerAddress,\n    delegationManager,\n    delegationHash,\n    terms,\n  });\n}\n\n/**\n * Caveat enforcer actions for extending viem clients.\n *\n * @param params - The parameters object.\n * @param params.environment - The delegator environment.\n * @returns A function that takes a client and returns the client extension with caveat enforcer actions.\n */\nexport const caveatEnforcerActions =\n  ({ environment }: { environment: DeleGatorEnvironment }) =>\n  (client: Client) => ({\n    /**\n     * Get available amount for ERC20 period transfer enforcer.\n     *\n     * @param params - The parameters for the ERC20 period transfer enforcer.\n     * @returns Promise resolving to the period transfer result.\n     */\n    getErc20PeriodTransferEnforcerAvailableAmount: async (\n      params: CaveatEnforcerParams,\n    ): Promise<PeriodTransferResult> => {\n      return getErc20PeriodTransferEnforcerAvailableAmount(\n        client,\n        environment,\n        params,\n      );\n    },\n\n    /**\n     * Get available amount for ERC20 streaming enforcer.\n     *\n     * @param params - The parameters for the ERC20 streaming enforcer.\n     * @returns Promise resolving to the streaming result.\n     */\n    getErc20StreamingEnforcerAvailableAmount: async (\n      params: CaveatEnforcerParams,\n    ): Promise<StreamingResult> => {\n      return getErc20StreamingEnforcerAvailableAmount(\n        client,\n        environment,\n        params,\n      );\n    },\n\n    /**\n     * Get available amount for multi-token period enforcer.\n     *\n     * @param params - The parameters for the multi-token period enforcer.\n     * @returns Promise resolving to the period transfer result.\n     */\n    getMultiTokenPeriodEnforcerAvailableAmount: async (\n      params: CaveatEnforcerParams,\n    ): Promise<PeriodTransferResult> => {\n      return getMultiTokenPeriodEnforcerAvailableAmount(\n        client,\n        environment,\n        params,\n      );\n    },\n\n    /**\n     * Get available amount for native token period transfer enforcer.\n     *\n     * @param params - The parameters for the native token period transfer enforcer.\n     * @returns Promise resolving to the period transfer result.\n     */\n    getNativeTokenPeriodTransferEnforcerAvailableAmount: async (\n      params: CaveatEnforcerParams,\n    ): Promise<PeriodTransferResult> => {\n      return getNativeTokenPeriodTransferEnforcerAvailableAmount(\n        client,\n        environment,\n        params,\n      );\n    },\n\n    /**\n     * Get available amount for native token streaming enforcer.\n     *\n     * @param params - The parameters for the native token streaming enforcer.\n     * @returns Promise resolving to the streaming result.\n     */\n    getNativeTokenStreamingEnforcerAvailableAmount: async (\n      params: CaveatEnforcerParams,\n    ): Promise<StreamingResult> => {\n      return getNativeTokenStreamingEnforcerAvailableAmount(\n        client,\n        environment,\n        params,\n      );\n    },\n  });\n","import type { Client, Address, Hex } from 'viem';\nimport { isAddressEqual } from 'viem';\nimport { getCode } from 'viem/actions';\n\nimport type { DeleGatorEnvironment } from '../types';\n\n// EIP-7702 delegation prefix (0xef0100)\nconst DELEGATION_PREFIX = '0xef0100' as const;\n\n/**\n * Parameters for checking if an account is delegated to the EIP-7702 implementation.\n */\nexport type IsValid7702ImplementationParameters = {\n  /** The client to use for the query. */\n  client: Client;\n  /** The address to check for proper delegation. */\n  accountAddress: Address;\n  /** The DeleGator environment containing contract addresses. */\n  environment: DeleGatorEnvironment;\n};\n\n/**\n * Extracts the delegated contract address from EIP-7702 delegation code.\n *\n * @param code - The code returned from getCode for a delegated account.\n * @returns The delegated contract address or null if not a valid delegation.\n */\nfunction extractDelegatedAddress(code: Hex | undefined): Address | null {\n  if (code?.length !== 48) {\n    // 0x (2 chars) + ef0100 (6 chars) + address (40 chars) = 48 chars\n    return null;\n  }\n\n  if (!code.toLowerCase().startsWith(DELEGATION_PREFIX.toLowerCase())) {\n    return null;\n  }\n\n  // Extract the 20-byte address after the delegation prefix\n  const addressHex = code.slice(8); // Remove '0xef0100' prefix (8 chars)\n  return `0x${addressHex}`;\n}\n\n/**\n * Checks if an account is properly delegated to the EIP-7702 implementation.\n *\n * This function validates EIP-7702 delegations by checking if the EOA has a 7702\n * contract assigned to it and comparing the delegated address against the 7702\n * implementation found in the environment.\n *\n * @param params - The parameters for checking the delegation.\n * @param params.client - The client to use for the query.\n * @param params.accountAddress - The address to check for proper delegation.\n * @param params.environment - The DeleGator environment containing contract addresses.\n * @returns A promise that resolves to true if the account is properly delegated to the 7702 implementation, false otherwise.\n * @example\n * ```typescript\n * const isValid = await isValid7702Implementation({\n *   client: publicClient,\n *   accountAddress: '0x...',\n *   environment: delegatorEnvironment,\n * });\n *\n * if (isValid) {\n *   console.log('Account is properly delegated to EIP-7702 implementation');\n * } else {\n *   console.log('Account is not properly delegated');\n * }\n * ```\n */\nexport async function isValid7702Implementation({\n  client,\n  accountAddress,\n  environment,\n}: IsValid7702ImplementationParameters): Promise<boolean> {\n  try {\n    // Get the code at the account address\n    const code = await getCode(client, {\n      address: accountAddress,\n    });\n\n    // Extract the delegated contract address from the EIP-7702 delegation code\n    const delegatedAddress = extractDelegatedAddress(code);\n\n    // If no valid delegation found, return false\n    if (!delegatedAddress) {\n      return false;\n    }\n\n    // Compare the delegated address with the 7702 implementation in the environment\n    const expectedImplementation =\n      environment.implementations.EIP7702StatelessDeleGatorImpl;\n    if (!expectedImplementation) {\n      return false;\n    }\n\n    return isAddressEqual(delegatedAddress, expectedImplementation);\n  } catch (error) {\n    // If the call fails (e.g., no code at address, network error),\n    // then it's not properly delegated to our implementation\n    return false;\n  }\n}\n","import type {\n  Account,\n  Address,\n  Chain,\n  Client,\n  Hex,\n  Transport,\n  WalletClient,\n} from 'viem';\nimport { BaseError } from 'viem';\nimport { parseAccount } from 'viem/accounts';\n\nimport { prepareSignDelegationTypedData } from '../delegation';\nimport type { Delegation } from '../types';\n\nexport type SignDelegationParameters = {\n  /** Account to sign with */\n  account?: Account | Address;\n  /** The delegation to sign */\n  delegation: Omit<Delegation, 'signature'>;\n  /** The address of the delegation manager contract */\n  delegationManager: Address;\n  /** The chain ID for the signature */\n  chainId: number;\n  /** The name of the contract */\n  name?: string;\n  /** The version of the contract */\n  version?: string;\n  /** Whether to allow insecure unrestricted delegation */\n  allowInsecureUnrestrictedDelegation?: boolean;\n};\n\nexport type SignDelegationReturnType = Hex;\n\n/**\n * Signs a delegation using a wallet client.\n * @param client - The wallet client to use for signing.\n * @param parameters - The parameters for signing the delegation.\n * @returns The signature of the delegation.\n * @example\n * ```ts\n * const signature = await signDelegation(walletClient, {\n *   delegation: {\n *     delegate: '0x...',\n *     delegator: '0x...',\n *     authority: '0x...',\n *     caveats: [],\n *     salt: '0x'\n *   },\n *   delegationManager: '0x...',\n *   chainId: 1\n * });\n * ```\n */\nexport async function signDelegation<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n>(\n  client: Client<Transport, TChain, TAccount> & {\n    signTypedData: WalletClient['signTypedData'];\n  },\n  parameters: SignDelegationParameters,\n): Promise<SignDelegationReturnType> {\n  const {\n    account: accountParam = client.account,\n    delegation,\n    delegationManager,\n    chainId,\n    name = 'DelegationManager',\n    version = '1',\n    allowInsecureUnrestrictedDelegation = false,\n  } = parameters;\n\n  if (!accountParam) {\n    throw new BaseError('Account not found. Please provide an account.');\n  }\n\n  const account = parseAccount(accountParam);\n\n  const typedData = prepareSignDelegationTypedData({\n    delegation,\n    delegationManager,\n    chainId,\n    name,\n    version,\n    allowInsecureUnrestrictedDelegation,\n  });\n\n  return client.signTypedData({\n    account,\n    ...typedData,\n  });\n}\n\n/**\n * Creates a sign delegation action that can be used to extend a wallet client.\n * @returns A function that can be used with wallet client extend method.\n * @example\n * ```ts\n * const walletClient = createWalletClient({\n *   chain: mainnet,\n *   transport: http()\n * }).extend(signDelegationActions());\n * ```\n */\nexport function signDelegationActions() {\n  return <\n    TChain extends Chain | undefined,\n    TAccount extends Account | undefined,\n  >(\n    client: Client<Transport, TChain, TAccount> & {\n      signTypedData: WalletClient['signTypedData'];\n    },\n  ) => ({\n    signDelegation: async (\n      parameters: Omit<SignDelegationParameters, 'chainId'> & {\n        chainId?: number;\n      },\n    ) =>\n      signDelegation(client, {\n        chainId:\n          parameters.chainId ??\n          (() => {\n            if (!client.chain?.id) {\n              throw new BaseError(\n                'Chain ID is required. Either provide it in parameters or configure the client with a chain.',\n              );\n            }\n            return client.chain.id;\n          })(),\n        ...parameters,\n      }),\n  });\n}\n","import type {\n  Account,\n  Address,\n  Chain,\n  Client,\n  Hex,\n  Transport,\n  WalletClient,\n} from 'viem';\nimport { BaseError } from 'viem';\nimport { parseAccount } from 'viem/accounts';\n\nimport { prepareSignUserOperationTypedData } from '../userOp';\nimport type { UserOperationV07 } from '../userOp';\n\nexport type SignUserOperationParameters = {\n  /** Account to sign with */\n  account?: Account | Address;\n  /** The user operation to sign */\n  userOperation: Omit<UserOperationV07, 'signature'>;\n  /** The entry point contract address */\n  entryPoint: { address: Address };\n  /** The chain ID that the entry point is deployed on */\n  chainId: number;\n  /** The address of the smart account */\n  address: Address;\n  /** The name of the domain of the implementation contract */\n  name: 'HybridDeleGator' | 'MultiSigDeleGator';\n  /** The version of the domain of the implementation contract */\n  version?: string;\n};\n\nexport type SignUserOperationReturnType = Hex;\n\n/**\n * Signs a user operation using a wallet client.\n * @param client - The wallet client to use for signing.\n * @param parameters - The parameters for signing the user operation.\n * @returns The signature of the user operation.\n * @example\n * ```ts\n * const signature = await signUserOperation(walletClient, {\n *   userOperation: {\n *     sender: '0x...',\n *     nonce: 0n,\n *     callData: '0x',\n *     callGasLimit: 1000000n,\n *     verificationGasLimit: 1000000n,\n *     preVerificationGas: 21000n,\n *     maxFeePerGas: 1000000000n,\n *     maxPriorityFeePerGas: 1000000000n\n *   },\n *   entryPoint: { address: '0x...' },\n *   chainId: 1,\n *   address: '0x...',\n *   name: 'HybridDeleGator'\n * });\n * ```\n */\nexport async function signUserOperation<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n>(\n  client: Client<Transport, TChain, TAccount> & {\n    signTypedData: WalletClient['signTypedData'];\n  },\n  parameters: SignUserOperationParameters,\n): Promise<SignUserOperationReturnType> {\n  const {\n    account: accountParam = client.account,\n    userOperation,\n    entryPoint,\n    chainId,\n    name,\n    address,\n    version = '1',\n  } = parameters;\n\n  if (!accountParam) {\n    throw new BaseError('Account not found. Please provide an account.');\n  }\n\n  const account = parseAccount(accountParam);\n\n  const typedData = prepareSignUserOperationTypedData({\n    userOperation,\n    entryPoint,\n    chainId,\n    name,\n    address,\n    version,\n  });\n\n  return client.signTypedData({\n    account,\n    ...typedData,\n  });\n}\n\n/**\n * Creates a sign user operation action that can be used to extend a wallet client.\n * @returns A function that can be used with wallet client extend method.\n * @example\n * ```ts\n * const walletClient = createWalletClient({\n *   chain: mainnet,\n *   transport: http()\n * }).extend(signUserOperationActions());\n * ```\n */\nexport function signUserOperationActions() {\n  return <\n    TChain extends Chain | undefined,\n    TAccount extends Account | undefined,\n  >(\n    client: Client<Transport, TChain, TAccount> & {\n      signTypedData: WalletClient['signTypedData'];\n    },\n  ) => ({\n    signUserOperation: async (\n      parameters: Omit<SignUserOperationParameters, 'chainId'> & {\n        chainId?: number;\n      },\n    ) =>\n      signUserOperation(client, {\n        chainId:\n          parameters.chainId ??\n          (() => {\n            if (!client.chain?.id) {\n              throw new BaseError(\n                'Chain ID is required. Either provide it in parameters or configure the client with a chain.',\n              );\n            }\n            return client.chain.id;\n          })(),\n        ...parameters,\n      }),\n  });\n}\n"],"names":["read_exports","BaseError","parseAccount","BaseError","parseAccount"],"mappings":"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"}},
    {"offset": {"line": 3277, "column": 0}, "map": {"version":3,"sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/contracts/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DelegationManager/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DelegationManager/constants.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DelegationManager/encode.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DelegationManager/methods/disableDelegation.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DelegationManager/methods/enableDelegation.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DelegationManager/methods/redeemDelegations.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DelegationManager/execute.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DelegationManager/read.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DelegationManager/methods/disabledDelegations.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DelegationManager/methods/getAnyDelegate.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DelegationManager/methods/getRootAuthority.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DelegationManager/simulate.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DeleGatorCore/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DeleGatorCore/execute.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/DeleGatorCore/simulate.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/EIP712/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/EIP712/read.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/EIP712/methods/getContractName.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/EIP712/methods/getContractVersion.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/EIP712/methods/getDomainVersion.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/EntryPoint/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/EntryPoint/read.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/EntryPoint/methods/getNonce.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/ERC20TransferAmountEnforcer/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/ERC20TransferAmountEnforcer/read.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/ERC20TransferAmountEnforcer/methods/getSpentAmount.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/ERC20TransferAmountEnforcer/methods/getTermsInfo.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/HybridDeleGator/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/HybridDeleGator/read.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/HybridDeleGator/methods/getKey.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/HybridDeleGator/methods/getKeyIdHashes.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/HybridDeleGator/methods/getKeyIdHashesCount.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/HybridDeleGator/simulate.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/HybridDeleGator/constants.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/IdEnforcer/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/IdEnforcer/read.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/IdEnforcer/methods/getIsUsed.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/IdEnforcer/methods/getTermsInfo.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/LimitedCallsEnforcer/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/LimitedCallsEnforcer/read.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/LimitedCallsEnforcer/methods/callCounts.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/LimitedCallsEnforcer/methods/getTermsInfo.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/MultiSigDeleGator/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/MultiSigDeleGator/read.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/MultiSigDeleGator/methods/getMaxNumberOfSigners.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/MultiSigDeleGator/methods/getSigners.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/MultiSigDeleGator/methods/getSignersCount.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/MultiSigDeleGator/methods/getThreshold.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/MultiSigDeleGator/methods/isSigner.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/MultiSigDeleGator/simulate.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/MultiSigDeleGator/constants.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/NativeTokenTransferAmountEnforcer/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/NativeTokenTransferAmountEnforcer/read.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/NativeTokenTransferAmountEnforcer/methods/getSpentAmount.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/NativeTokenTransferAmountEnforcer/methods/getTermsInfo.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/NonceEnforcer/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/NonceEnforcer/encode.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/NonceEnforcer/methods/incrementNonce.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/NonceEnforcer/execute.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/NonceEnforcer/read.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/NonceEnforcer/methods/currentNonce.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/NonceEnforcer/methods/getTermsInfo.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/NonceEnforcer/simulate.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/Ownable2Step/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/Ownable2Step/read.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/Ownable2Step/methods/getOwner.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/Ownable2Step/methods/getPendingOwner.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/Ownable2Step/execute.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/Ownable2Step/methods/acceptOwnership.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/Ownable2Step/methods/renounceOwnership.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/Ownable2Step/methods/transferOwnership.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/Ownable2Step/encode.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/Ownable2Step/simulate.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/Pausable/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/Pausable/read.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/Pausable/methods/isPaused.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/Pausable/execute.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/Pausable/methods/pause.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/Pausable/methods/unpause.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/Pausable/encode.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/Pausable/simulate.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/SimpleFactory/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/SimpleFactory/execute.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/SimpleFactory/read.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/SimpleFactory/methods/getCreate2Address.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/SimpleFactory/simulate.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/SpecificActionERC20TransferBatchEnforcer/index.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/SpecificActionERC20TransferBatchEnforcer/read.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/SpecificActionERC20TransferBatchEnforcer/methods/getTermsInfo.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/DelegationFramework/SpecificActionERC20TransferBatchEnforcer/methods/usedDelegations.ts"],"sourcesContent":["import * as DelegationManager from '../DelegationFramework/DelegationManager';\nimport * as DeleGatorCore from '../DelegationFramework/DeleGatorCore';\nimport * as EIP712 from '../DelegationFramework/EIP712';\nimport * as EntryPoint from '../DelegationFramework/EntryPoint';\nimport * as ERC20PeriodTransferEnforcer from '../DelegationFramework/ERC20PeriodTransferEnforcer';\nimport * as ERC20StreamingEnforcer from '../DelegationFramework/ERC20StreamingEnforcer';\nimport * as ERC20TransferAmountEnforcer from '../DelegationFramework/ERC20TransferAmountEnforcer';\nimport * as HybridDeleGator from '../DelegationFramework/HybridDeleGator';\nimport * as IdEnforcer from '../DelegationFramework/IdEnforcer';\nimport * as LimitedCallsEnforcer from '../DelegationFramework/LimitedCallsEnforcer';\nimport * as MultiSigDeleGator from '../DelegationFramework/MultiSigDeleGator';\nimport * as MultiTokenPeriodEnforcer from '../DelegationFramework/MultiTokenPeriodEnforcer';\nimport * as NativeTokenPeriodTransferEnforcer from '../DelegationFramework/NativeTokenPeriodTransferEnforcer';\nimport * as NativeTokenStreamingEnforcer from '../DelegationFramework/NativeTokenStreamingEnforcer';\nimport * as NativeTokenTransferAmountEnforcer from '../DelegationFramework/NativeTokenTransferAmountEnforcer';\nimport * as NonceEnforcer from '../DelegationFramework/NonceEnforcer';\nimport * as Ownable2Step from '../DelegationFramework/Ownable2Step';\nimport * as Pausable from '../DelegationFramework/Pausable';\nimport * as SimpleFactory from '../DelegationFramework/SimpleFactory';\nimport * as SpecificActionERC20TransferBatchEnforcer from '../DelegationFramework/SpecificActionERC20TransferBatchEnforcer';\n\nexport {\n  isContractDeployed,\n  isImplementationExpected,\n  encodeProxyCreationCode,\n} from '../DelegationFramework/utils';\n\nexport type { NarrowAbiToFunction } from '../DelegationFramework/utils';\n\nexport {\n  DelegationManager,\n  DeleGatorCore,\n  EIP712,\n  EntryPoint,\n  HybridDeleGator,\n  IdEnforcer,\n  LimitedCallsEnforcer,\n  MultiSigDeleGator,\n  NonceEnforcer,\n  Ownable2Step,\n  Pausable,\n  SimpleFactory,\n  SpecificActionERC20TransferBatchEnforcer,\n  ERC20PeriodTransferEnforcer,\n  ERC20StreamingEnforcer,\n  ERC20TransferAmountEnforcer,\n  MultiTokenPeriodEnforcer,\n  NativeTokenPeriodTransferEnforcer,\n  NativeTokenStreamingEnforcer,\n  NativeTokenTransferAmountEnforcer,\n};\n\nexport type {\n  P256Owner,\n  InitializedClient,\n} from '../DelegationFramework/types';\n\nexport type { Redemption } from '../types';\n","import * as constants from './constants';\nimport * as encode from './encode';\nimport * as execute from './execute';\nimport * as read from './read';\nimport * as simulate from './simulate';\n\nexport { encode, execute, read, simulate, constants };\n","export { ROOT_AUTHORITY, ANY_BENEFICIARY } from '../../delegation';\n\nexport const NAME = 'DelegationManager';\nexport const VERSION = '1.3.0';\nexport const DOMAIN_VERSION = '1';\n","import { encode as disableDelegation } from './methods/disableDelegation';\nimport { encode as enableDelegation } from './methods/enableDelegation';\nimport { encode as redeemDelegations } from './methods/redeemDelegations';\n\nexport { disableDelegation, enableDelegation, redeemDelegations };\n","import { DelegationManager } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport { toDelegationStruct } from '../../../delegation';\nimport type { Delegation } from '../../../types';\nimport type { InitializedClient } from '../../types';\nimport type { NarrowAbiToFunction } from '../../utils';\n\nexport type EncodeDisableDelegationParameters = {\n  delegation: Delegation;\n};\n\nexport type SimulateDisableDelegationParameters = {\n  client: Client;\n  delegationManagerAddress: Address;\n} & EncodeDisableDelegationParameters;\n\nexport type ExecuteDisableDelegationParameters = {\n  client: InitializedClient;\n  delegationManagerAddress: Address;\n} & EncodeDisableDelegationParameters;\n\nexport const simulate = async ({\n  client,\n  delegationManagerAddress,\n  delegation,\n}: SimulateDisableDelegationParameters) => {\n  const abi = DelegationManager.abi as any as NarrowAbiToFunction<\n    typeof DelegationManager.abi,\n    'disableDelegation'\n  >;\n\n  const delegationStruct = toDelegationStruct(delegation);\n\n  return simulateContract(client, {\n    address: delegationManagerAddress,\n    abi,\n    functionName: 'disableDelegation',\n    args: [delegationStruct],\n  });\n};\n\nexport const execute = async ({\n  client,\n  delegationManagerAddress,\n  delegation,\n}: ExecuteDisableDelegationParameters) => {\n  const { request } = await simulate({\n    client,\n    delegationManagerAddress,\n    delegation,\n  });\n\n  return writeContract(client, request);\n};\n\nexport const encode = ({ delegation }: EncodeDisableDelegationParameters) => {\n  const delegationStruct = toDelegationStruct(delegation);\n\n  return encodeFunctionData({\n    abi: DelegationManager.abi,\n    functionName: 'disableDelegation',\n    args: [delegationStruct],\n  });\n};\n","import { DelegationManager } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport { toDelegationStruct } from '../../../delegation';\nimport type { Delegation } from '../../../types';\nimport type { InitializedClient } from '../../types';\nimport type { NarrowAbiToFunction } from '../../utils';\n\nexport type EncodeEnableDelegationParameters = {\n  delegation: Delegation;\n};\n\nexport type SimulateEnableDelegationParameters = {\n  client: Client;\n  delegationManagerAddress: Address;\n} & EncodeEnableDelegationParameters;\n\nexport type ExecuteEnableDelegationParameters = {\n  client: InitializedClient;\n  delegationManagerAddress: Address;\n} & EncodeEnableDelegationParameters;\n\nexport const simulate = async ({\n  client,\n  delegationManagerAddress,\n  delegation,\n}: SimulateEnableDelegationParameters) => {\n  const abi = DelegationManager.abi as any as NarrowAbiToFunction<\n    typeof DelegationManager.abi,\n    'enableDelegation'\n  >;\n\n  const delegationStruct = toDelegationStruct(delegation);\n\n  return simulateContract(client, {\n    address: delegationManagerAddress,\n    abi,\n    functionName: 'enableDelegation',\n    args: [delegationStruct],\n  });\n};\n\nexport const execute = async ({\n  client,\n  delegationManagerAddress,\n  delegation,\n}: ExecuteEnableDelegationParameters) => {\n  const { request } = await simulate({\n    client,\n    delegationManagerAddress,\n    delegation,\n  });\n\n  return writeContract(client, request);\n};\n\nexport const encode = ({ delegation }: EncodeEnableDelegationParameters) => {\n  const delegationStruct = toDelegationStruct(delegation);\n\n  return encodeFunctionData({\n    abi: DelegationManager.abi,\n    functionName: 'enableDelegation',\n    args: [delegationStruct],\n  });\n};\n","import { DelegationManager } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport { encodePermissionContexts } from '../../../delegation';\nimport { encodeExecutionCalldatas } from '../../../executions';\nimport type { ExecutionMode, ExecutionStruct } from '../../../executions';\nimport type { Delegation } from '../../../types';\nimport type { InitializedClient } from '../../types';\nimport type { NarrowAbiToFunction } from '../../utils';\n\nexport type EncodeRedeemDelegationsParameters = {\n  delegations: Delegation[][];\n  modes: ExecutionMode[];\n  executions: ExecutionStruct[][];\n};\n\nexport type SimulateRedeemDelegationsParameters = {\n  client: Client;\n  delegationManagerAddress: Address;\n} & EncodeRedeemDelegationsParameters;\n\nexport type ExecuteRedeemDelegationsParameters = {\n  client: InitializedClient;\n  delegationManagerAddress: Address;\n} & EncodeRedeemDelegationsParameters;\n\nexport const simulate = async ({\n  client,\n  delegationManagerAddress,\n  delegations,\n  modes,\n  executions,\n}: SimulateRedeemDelegationsParameters) => {\n  const abi = DelegationManager.abi as any as NarrowAbiToFunction<\n    typeof DelegationManager.abi,\n    'redeemDelegations'\n  >;\n\n  return simulateContract(client, {\n    address: delegationManagerAddress,\n    abi,\n    functionName: 'redeemDelegations',\n    args: [\n      encodePermissionContexts(delegations),\n      modes,\n      encodeExecutionCalldatas(executions),\n    ],\n  });\n};\n\nexport const execute = async ({\n  client,\n  delegationManagerAddress,\n  delegations,\n  modes,\n  executions,\n}: ExecuteRedeemDelegationsParameters) => {\n  const { request } = await simulate({\n    client,\n    delegationManagerAddress,\n    delegations,\n    modes,\n    executions,\n  });\n\n  return writeContract(client, request);\n};\n\nexport const encode = ({\n  delegations,\n  modes,\n  executions,\n}: EncodeRedeemDelegationsParameters) => {\n  return encodeFunctionData({\n    abi: DelegationManager.abi,\n    functionName: 'redeemDelegations',\n    args: [\n      encodePermissionContexts(delegations),\n      modes,\n      encodeExecutionCalldatas(executions),\n    ],\n  });\n};\n","import { execute as disableDelegation } from './methods/disableDelegation';\nimport { execute as enableDelegation } from './methods/enableDelegation';\nimport { execute as redeemDelegations } from './methods/redeemDelegations';\n\nexport { disableDelegation, enableDelegation, redeemDelegations };\n","import { read as disabledDelegations } from './methods/disabledDelegations';\nimport { read as getAnyDelegate } from './methods/getAnyDelegate';\nimport { read as getRootAuthority } from './methods/getRootAuthority';\n\nexport { getAnyDelegate, getRootAuthority, disabledDelegations };\n","import { DelegationManager } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadDisabledDelegationsParameters = {\n  client: Client;\n  contractAddress: Address;\n  delegationHash: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  delegationHash,\n}: ReadDisabledDelegationsParameters) =>\n  await readContract(client, {\n    address: contractAddress,\n    abi: DelegationManager.abi,\n    functionName: 'disabledDelegations',\n    args: [delegationHash],\n  });\n","import { DelegationManager } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetAnyDelegateParameters = {\n  client: Client;\n  contractAddress: Address;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n}: ReadGetAnyDelegateParameters) =>\n  await readContract(client, {\n    address: contractAddress,\n    abi: DelegationManager.abi,\n    functionName: 'ANY_DELEGATE',\n  });\n","import { DelegationManager } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetRootAuthorityParameters = {\n  client: Client;\n  contractAddress: Address;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n}: ReadGetRootAuthorityParameters) =>\n  await readContract(client, {\n    address: contractAddress,\n    abi: DelegationManager.abi,\n    functionName: 'ROOT_AUTHORITY',\n  });\n","import { simulate as disableDelegation } from './methods/disableDelegation';\nimport { simulate as enableDelegation } from './methods/enableDelegation';\nimport { simulate as redeemDelegations } from './methods/redeemDelegations';\n\nexport { disableDelegation, enableDelegation, redeemDelegations };\n","import * as encode from './encode';\nimport * as execute from './execute';\nimport * as read from './read';\nimport * as simulate from './simulate';\n\nexport { encode, simulate, read, execute };\n","import { execute as disableDelegation } from './methods/disableDelegation';\nimport { execute as enableDelegation } from './methods/enableDelegation';\nimport { execute } from './methods/execute';\nimport { execute as executeWithMode } from './methods/executeWithMode';\nimport { execute as upgradeToAndCall } from './methods/upgradeToAndCall';\n\nexport {\n  disableDelegation,\n  enableDelegation,\n  execute,\n  executeWithMode,\n  upgradeToAndCall,\n};\n","import { simulate as disableDelegation } from './methods/disableDelegation';\nimport { simulate as enableDelegation } from './methods/enableDelegation';\nimport { simulate as execute } from './methods/execute';\nimport { simulate as executeWithMode } from './methods/executeWithMode';\nimport { simulate as upgradeToAndCall } from './methods/upgradeToAndCall';\n\nexport {\n  disableDelegation,\n  enableDelegation,\n  execute,\n  executeWithMode,\n  upgradeToAndCall,\n};\n","export * as read from './read';\n","import { read as getContractName } from './methods/getContractName';\nimport { read as getContractVersion } from './methods/getContractVersion';\nimport { read as getDomainVersion } from './methods/getDomainVersion';\n\nexport { getContractName, getContractVersion, getDomainVersion };\n","import type { Client, Address } from 'viem';\nimport { readContract } from 'viem/actions';\n\n// NOTE: ABIs have been extracted and minimized for reuse across contracts. These methods are included in our contracts but are not a part of the EIP712 standard itself.\n\nexport type ReadGetContractNameParameters = {\n  client: Client;\n  contractAddress: Address;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n}: ReadGetContractNameParameters) =>\n  await readContract(client, {\n    address: contractAddress,\n    abi: [\n      {\n        type: 'function',\n        name: 'NAME',\n        inputs: [],\n        outputs: [\n          {\n            name: '',\n            type: 'string',\n            internalType: 'string',\n          },\n        ],\n        stateMutability: 'view',\n      },\n    ],\n    functionName: 'NAME',\n  });\n","import type { Client, Address } from 'viem';\nimport { readContract } from 'viem/actions';\n\n// NOTE: ABIs have been extracted and minimized for reuse across contracts. These methods are included in our contracts but are not a part of the EIP712 standard itself.\n\nexport type ReadGetContractVersionParameters = {\n  client: Client;\n  contractAddress: Address;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n}: ReadGetContractVersionParameters) =>\n  await readContract(client, {\n    address: contractAddress,\n    abi: [\n      {\n        type: 'function',\n        name: 'VERSION',\n        inputs: [],\n        outputs: [\n          {\n            name: '',\n            type: 'string',\n            internalType: 'string',\n          },\n        ],\n        stateMutability: 'view',\n      },\n    ],\n    functionName: 'VERSION',\n  });\n","import type { Client, Address } from 'viem';\nimport { readContract } from 'viem/actions';\n\n// NOTE: ABIs have been extracted and minimized for reuse across contracts. These methods are included in our contracts but are not a part of the EIP712 standard itself.\n\nexport type ReadGetDomainVersionParameters = {\n  client: Client;\n  contractAddress: Address;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n}: ReadGetDomainVersionParameters) =>\n  await readContract(client, {\n    address: contractAddress,\n    abi: [\n      {\n        type: 'function',\n        name: 'DOMAIN_VERSION',\n        inputs: [],\n        outputs: [\n          {\n            name: '',\n            type: 'string',\n            internalType: 'string',\n          },\n        ],\n        stateMutability: 'view',\n      },\n    ],\n    functionName: 'DOMAIN_VERSION',\n  });\n","import * as read from './read';\n\nexport { read };\n","import { read as entryPointGetNonce } from './methods/getNonce';\n\nexport { entryPointGetNonce };\n","import { EntryPoint } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetNonceParameters = {\n  client: Client;\n  entryPoint: Address;\n  contractAddress: Address;\n  key: bigint;\n};\n\nexport const read = async ({\n  client,\n  entryPoint,\n  contractAddress,\n  key,\n}: ReadGetNonceParameters) =>\n  await readContract(client, {\n    address: entryPoint,\n    abi: EntryPoint.abi,\n    functionName: 'getNonce',\n    args: [contractAddress, key],\n  });\n","import * as read from './read';\n\nexport { read };\n","import { read as getSpentAmount } from './methods/getSpentAmount';\nimport { read as getTermsInfo } from './methods/getTermsInfo';\n\nexport { getTermsInfo, getSpentAmount };\n","import { ERC20TransferAmountEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetSpentAmountParameters = {\n  client: Client;\n  contractAddress: Address;\n  delegationManager: Address;\n  delegationHash: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  delegationManager,\n  delegationHash,\n}: ReadGetSpentAmountParameters): Promise<bigint> => {\n  const amount = await readContract(client, {\n    address: contractAddress,\n    abi: ERC20TransferAmountEnforcer.abi,\n    functionName: 'spentMap',\n    args: [delegationManager, delegationHash],\n  });\n\n  return amount;\n};\n","import { ERC20TransferAmountEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetTermsInfoParameters = {\n  client: Client;\n  contractAddress: Address;\n  terms: Hex;\n};\n\nexport type TermsData = {\n  allowedContract: Address;\n  maxTokens: bigint;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  terms,\n}: ReadGetTermsInfoParameters): Promise<TermsData> => {\n  const [allowedContract, maxTokens] = await readContract(client, {\n    address: contractAddress,\n    abi: ERC20TransferAmountEnforcer.abi,\n    functionName: 'getTermsInfo',\n    args: [terms],\n  });\n\n  return {\n    allowedContract,\n    maxTokens,\n  };\n};\n","export * as read from './read';\nexport * as encode from './encode';\nexport * as simulate from './simulate';\nexport * as constants from './constants';\n","import { read as getKey } from './methods/getKey';\nimport { read as getKeyIdHashes } from './methods/getKeyIdHashes';\nimport { read as getKeyIdHashesCount } from './methods/getKeyIdHashesCount';\n\nexport { getKey, getKeyIdHashes, getKeyIdHashesCount };\n","import { HybridDeleGator } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetKeyParameters = {\n  client: Client;\n  hybridDeleGatorAddress: Address;\n  keyId: string;\n};\n\nexport const read = async ({\n  client,\n  hybridDeleGatorAddress,\n  keyId,\n}: ReadGetKeyParameters) =>\n  await readContract(client, {\n    address: hybridDeleGatorAddress,\n    abi: HybridDeleGator.abi,\n    functionName: 'getKey',\n    args: [keyId],\n  });\n","import { HybridDeleGator } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetKeyIdHashesParameters = {\n  client: Client;\n  hybridDeleGatorAddress: Address;\n};\n\nexport const read = async ({\n  client,\n  hybridDeleGatorAddress,\n}: ReadGetKeyIdHashesParameters) =>\n  await readContract(client, {\n    address: hybridDeleGatorAddress,\n    abi: HybridDeleGator.abi,\n    functionName: 'getKeyIdHashes',\n  });\n","import { HybridDeleGator } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetKeyIdHashesCountParameters = {\n  client: Client;\n  hybridDeleGatorAddress: Address;\n};\n\nexport const read = async ({\n  client,\n  hybridDeleGatorAddress,\n}: ReadGetKeyIdHashesCountParameters) =>\n  await readContract(client, {\n    address: hybridDeleGatorAddress,\n    abi: HybridDeleGator.abi,\n    functionName: 'getKeyIdHashesCount',\n  });\n","import { simulate as addKey } from './methods/addKey';\nimport { simulate as initializeHybridDeleGator } from './methods/initialize';\nimport { simulate as reinitializeHybridDeleGator } from './methods/reinitialize';\nimport { simulate as removeKey } from './methods/removeKey';\nimport { simulate as updateSigners } from './methods/updateSigners';\n\nexport {\n  addKey,\n  initializeHybridDeleGator,\n  reinitializeHybridDeleGator,\n  removeKey,\n  updateSigners,\n};\n","export { ROOT_AUTHORITY, ANY_BENEFICIARY } from '../../delegation';\n\nexport const NAME = 'HybridDeleGator';\nexport const VERSION = '1.3.0';\nexport const DOMAIN_VERSION = '1';\n","import * as read from './read';\n\nexport { read };\n","import { read as getIsUsed } from './methods/getIsUsed';\nimport { read as getTermsInfo } from './methods/getTermsInfo';\n\nexport { getTermsInfo, getIsUsed };\n","import { IdEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetIsUsedParameters = {\n  client: Client;\n  contractAddress: Address;\n  delegationManager: Address;\n  delegator: Address;\n  id: bigint;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  delegationManager,\n  delegator,\n  id,\n}: ReadGetIsUsedParameters): Promise<boolean> => {\n  const isUsed = await readContract(client, {\n    address: contractAddress,\n    abi: IdEnforcer.abi,\n    functionName: 'getIsUsed',\n    args: [delegationManager, delegator, id],\n  });\n\n  return isUsed;\n};\n","import { IdEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetTermsInfoParameters = {\n  client: Client;\n  contractAddress: Address;\n  terms: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  terms,\n}: ReadGetTermsInfoParameters): Promise<bigint> => {\n  const id = await readContract(client, {\n    address: contractAddress,\n    abi: IdEnforcer.abi,\n    functionName: 'getTermsInfo',\n    args: [terms],\n  });\n\n  return id;\n};\n","import * as read from './read';\n\nexport { read };\n","import { read as callCounts } from './methods/callCounts';\nimport { read as getTermsInfo } from './methods/getTermsInfo';\n\nexport { callCounts, getTermsInfo };\n","import { LimitedCallsEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadCallCountsParameters = {\n  client: Client;\n  contractAddress: Address;\n  delegationManager: Address;\n  delegationHash: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  delegationManager,\n  delegationHash,\n}: ReadCallCountsParameters): Promise<bigint> => {\n  const count = await readContract(client, {\n    address: contractAddress,\n    abi: LimitedCallsEnforcer.abi,\n    functionName: 'callCounts',\n    args: [delegationManager, delegationHash],\n  });\n\n  return count;\n};\n","import { LimitedCallsEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetTermsInfoParameters = {\n  client: Client;\n  contractAddress: Address;\n  terms: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  terms,\n}: ReadGetTermsInfoParameters): Promise<bigint> => {\n  const limit = await readContract(client, {\n    address: contractAddress,\n    abi: LimitedCallsEnforcer.abi,\n    functionName: 'getTermsInfo',\n    args: [terms],\n  });\n\n  return limit;\n};\n","export * as read from './read';\nexport * as encode from './encode';\nexport * as simulate from './simulate';\nexport * as constants from './constants';\n","import { read as getMaxNumberOfSigners } from './methods/getMaxNumberOfSigners';\nimport { read as getSigners } from './methods/getSigners';\nimport { read as getSignersCount } from './methods/getSignersCount';\nimport { read as getThreshold } from './methods/getThreshold';\nimport { read as isSigner } from './methods/isSigner';\n\nexport {\n  getSigners,\n  getSignersCount,\n  getThreshold,\n  isSigner,\n  getMaxNumberOfSigners,\n};\n","import { MultiSigDeleGator } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetMaxNumberOfSignersParameters = {\n  client: Client;\n  multiSigDeleGatorAddress: Address;\n};\n\nexport const read = async ({\n  client,\n  multiSigDeleGatorAddress,\n}: ReadGetMaxNumberOfSignersParameters) =>\n  await readContract(client, {\n    address: multiSigDeleGatorAddress,\n    abi: MultiSigDeleGator.abi,\n    functionName: 'MAX_NUMBER_OF_SIGNERS',\n  });\n","import { MultiSigDeleGator } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetSignersParameters = {\n  client: Client;\n  multiSigDeleGatorAddress: Address;\n};\n\nexport const read = async ({\n  client,\n  multiSigDeleGatorAddress,\n}: ReadGetSignersParameters) =>\n  await readContract(client, {\n    address: multiSigDeleGatorAddress,\n    abi: MultiSigDeleGator.abi,\n    functionName: 'getSigners',\n  });\n","import { MultiSigDeleGator } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetSignersCountParameters = {\n  client: Client;\n  multiSigDeleGatorAddress: Address;\n};\n\nexport const read = async ({\n  client,\n  multiSigDeleGatorAddress,\n}: ReadGetSignersCountParameters) =>\n  await readContract(client, {\n    address: multiSigDeleGatorAddress,\n    abi: MultiSigDeleGator.abi,\n    functionName: 'getSignersCount',\n  });\n","import { MultiSigDeleGator } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetThresholdParameters = {\n  client: Client;\n  multiSigDeleGatorAddress: Address;\n};\n\nexport const read = async ({\n  client,\n  multiSigDeleGatorAddress,\n}: ReadGetThresholdParameters) =>\n  await readContract(client, {\n    address: multiSigDeleGatorAddress,\n    abi: MultiSigDeleGator.abi,\n    functionName: 'getThreshold',\n  });\n","import { MultiSigDeleGator } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadIsSignerParameters = {\n  client: Client;\n  multiSigDeleGatorAddress: Address;\n  signer: Address;\n};\n\nexport const read = async ({\n  client,\n  multiSigDeleGatorAddress,\n  signer,\n}: ReadIsSignerParameters) =>\n  await readContract(client, {\n    address: multiSigDeleGatorAddress,\n    abi: MultiSigDeleGator.abi,\n    functionName: 'isSigner',\n    args: [signer],\n  });\n","import { simulate as addSigner } from './methods/addSigner';\nimport { simulate as initializeMultiSigDeleGator } from './methods/initialize';\nimport { simulate as reinitializeMultiSigDeleGator } from './methods/reinitialize';\nimport { simulate as removeSigner } from './methods/removeSigner';\nimport { simulate as replaceSigner } from './methods/replaceSigner';\nimport { simulate as updateMultiSigParameters } from './methods/updateMultiSigParameters';\nimport { simulate as updateThreshold } from './methods/updateThreshold';\n\nexport {\n  addSigner,\n  initializeMultiSigDeleGator,\n  reinitializeMultiSigDeleGator,\n  removeSigner,\n  replaceSigner,\n  updateMultiSigParameters,\n  updateThreshold,\n};\n","export const MAX_NUMBER_OF_SIGNERS = 30;\n","import * as read from './read';\n\nexport { read };\n","import { read as getSpentAmount } from './methods/getSpentAmount';\nimport { read as getTermsInfo } from './methods/getTermsInfo';\n\nexport { getSpentAmount, getTermsInfo };\n","import { NativeTokenTransferAmountEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetSpentAmountParameters = {\n  client: Client;\n  contractAddress: Address;\n  delegationManager: Address;\n  delegationHash: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  delegationManager,\n  delegationHash,\n}: ReadGetSpentAmountParameters): Promise<bigint> => {\n  const amount = await readContract(client, {\n    address: contractAddress,\n    abi: NativeTokenTransferAmountEnforcer.abi,\n    functionName: 'spentMap',\n    args: [delegationManager, delegationHash],\n  });\n\n  return amount;\n};\n","import { NativeTokenTransferAmountEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetTermsInfoParameters = {\n  client: Client;\n  contractAddress: Address;\n  terms: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  terms,\n}: ReadGetTermsInfoParameters): Promise<bigint> => {\n  const allowance = await readContract(client, {\n    address: contractAddress,\n    abi: NativeTokenTransferAmountEnforcer.abi,\n    functionName: 'getTermsInfo',\n    args: [terms],\n  });\n\n  return allowance;\n};\n","import * as encode from './encode';\nimport * as execute from './execute';\nimport * as read from './read';\nimport * as simulate from './simulate';\n\nexport { encode, execute, read, simulate };\n","import { encode as incrementNonce } from './methods/incrementNonce';\n\nexport { incrementNonce };\n","import { NonceEnforcer } from '@metamask/delegation-abis';\nimport type { Account, Address, Chain, Client, Transport } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nexport type SimulateIncrementNonceParameters = {\n  client: Client<Transport, Chain, Account>;\n  contractAddress: Address;\n  delegationManager: Address;\n};\n\nexport const encode = (delegationManager: Address) => {\n  return encodeFunctionData({\n    abi: NonceEnforcer.abi,\n    functionName: 'incrementNonce',\n    args: [delegationManager],\n  });\n};\n\nexport const simulate = async ({\n  client,\n  contractAddress,\n  delegationManager,\n}: SimulateIncrementNonceParameters) => {\n  return simulateContract(client, {\n    address: contractAddress,\n    abi: NonceEnforcer.abi,\n    functionName: 'incrementNonce',\n    args: [delegationManager],\n  });\n};\n\nexport const execute = async ({\n  client,\n  contractAddress,\n  delegationManager,\n}: SimulateIncrementNonceParameters) => {\n  const { request } = await simulate({\n    client,\n    contractAddress,\n    delegationManager,\n  });\n  return writeContract(client, request);\n};\n","import { execute as incrementNonce } from './methods/incrementNonce';\n\nexport { incrementNonce };\n","import { read as currentNonce } from './methods/currentNonce';\nimport { read as getTermsInfo } from './methods/getTermsInfo';\n\nexport { currentNonce, getTermsInfo };\n","import { NonceEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadCurrentNonceParameters = {\n  client: Client;\n  contractAddress: Address;\n  delegationManager: Address;\n  delegator: Address;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  delegationManager,\n  delegator,\n}: ReadCurrentNonceParameters): Promise<bigint> => {\n  const nonce = await readContract(client, {\n    address: contractAddress,\n    abi: NonceEnforcer.abi,\n    functionName: 'currentNonce',\n    args: [delegationManager, delegator],\n  });\n\n  return nonce;\n};\n","import { NonceEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetTermsInfoParameters = {\n  client: Client;\n  contractAddress: Address;\n  terms: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  terms,\n}: ReadGetTermsInfoParameters): Promise<bigint> => {\n  const nonce = await readContract(client, {\n    address: contractAddress,\n    abi: NonceEnforcer.abi,\n    functionName: 'getTermsInfo',\n    args: [terms],\n  });\n\n  return nonce;\n};\n","import { simulate as incrementNonce } from './methods/incrementNonce';\n\nexport { incrementNonce };\n","export * as read from './read';\nexport * as execute from './execute';\nexport * as encode from './encode';\nexport * as simulate from './simulate';\n","import { read as getOwner } from './methods/getOwner';\nimport { read as getPendingOwner } from './methods/getPendingOwner';\n\nexport { getPendingOwner, getOwner };\n","import { Ownable2Step } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetOwnerParameters = {\n  client: Client;\n  contractAddress: Address;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n}: ReadGetOwnerParameters) =>\n  await readContract(client, {\n    address: contractAddress,\n    abi: Ownable2Step.abi,\n    functionName: 'owner',\n  });\n","import { Ownable2Step } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetPendingOwnerParameters = {\n  client: Client;\n  contractAddress: Address;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n}: ReadGetPendingOwnerParameters) =>\n  await readContract(client, {\n    address: contractAddress,\n    abi: Ownable2Step.abi,\n    functionName: 'pendingOwner',\n  });\n","import { execute as acceptOwnership } from './methods/acceptOwnership';\nimport { execute as renounceOwnership } from './methods/renounceOwnership';\nimport { execute as transferOwnership } from './methods/transferOwnership';\n\nexport { transferOwnership, renounceOwnership, acceptOwnership };\n","import { Ownable2Step } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport type { InitializedClient } from '../../types';\n\nexport type SimulateAcceptOwnershipParameters = {\n  client: Client;\n  contractAddress: Address;\n};\n\nexport type ExecuteAcceptOwnershipParameters = {\n  client: InitializedClient;\n  contractAddress: Address;\n};\n\nexport const simulate = async ({\n  client,\n  contractAddress,\n}: SimulateAcceptOwnershipParameters) => {\n  return simulateContract(client, {\n    address: contractAddress,\n    abi: Ownable2Step.abi,\n    functionName: 'acceptOwnership',\n  });\n};\n\nexport const execute = async ({\n  client,\n  contractAddress,\n}: ExecuteAcceptOwnershipParameters) => {\n  const { request } = await simulate({\n    client,\n    contractAddress,\n  });\n  return writeContract(client, request);\n};\n\nexport const encode = () => {\n  return encodeFunctionData({\n    abi: Ownable2Step.abi,\n    functionName: 'acceptOwnership',\n  });\n};\n","import { Ownable2Step } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport type { InitializedClient } from '../../types';\n\nexport type SimulateRenounceOwnershipParameters = {\n  client: Client;\n  contractAddress: Address;\n};\n\nexport type ExecuteRenounceOwnershipParameters = {\n  client: InitializedClient;\n  contractAddress: Address;\n};\n\nexport const simulate = async ({\n  client,\n  contractAddress,\n}: SimulateRenounceOwnershipParameters) => {\n  return simulateContract(client, {\n    address: contractAddress,\n    abi: Ownable2Step.abi,\n    functionName: 'renounceOwnership',\n  });\n};\n\nexport const execute = async ({\n  client,\n  contractAddress,\n}: ExecuteRenounceOwnershipParameters) => {\n  const { request } = await simulate({\n    client,\n    contractAddress,\n  });\n  return writeContract(client, request);\n};\n\nexport const encode = () => {\n  return encodeFunctionData({\n    abi: Ownable2Step.abi,\n    functionName: 'renounceOwnership',\n  });\n};\n","import { Ownable2Step } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport type { InitializedClient } from '../../types';\n\nexport type SimulateTransferOwnershipParameters = {\n  client: Client;\n  contractAddress: Address;\n  account: Address;\n};\n\nexport type ExecuteTransferOwnershipParameters = {\n  client: InitializedClient;\n  contractAddress: Address;\n  account: Address;\n};\n\nexport const simulate = async ({\n  client,\n  contractAddress,\n  account,\n}: SimulateTransferOwnershipParameters) => {\n  return simulateContract(client, {\n    address: contractAddress,\n    abi: Ownable2Step.abi,\n    functionName: 'transferOwnership',\n    args: [account],\n  });\n};\n\nexport const execute = async ({\n  client,\n  contractAddress,\n  account,\n}: ExecuteTransferOwnershipParameters) => {\n  const { request } = await simulate({\n    client,\n    contractAddress,\n    account,\n  });\n  return writeContract(client, request);\n};\n\nexport const encode = (account: Address) => {\n  return encodeFunctionData({\n    abi: Ownable2Step.abi,\n    functionName: 'transferOwnership',\n    args: [account],\n  });\n};\n","import { encode as acceptOwnership } from './methods/acceptOwnership';\nimport { encode as renounceOwnership } from './methods/renounceOwnership';\nimport { encode as transferOwnership } from './methods/transferOwnership';\n\nexport { transferOwnership, renounceOwnership, acceptOwnership };\n","import { simulate as acceptOwnership } from './methods/acceptOwnership';\nimport { simulate as renounceOwnership } from './methods/renounceOwnership';\nimport { simulate as transferOwnership } from './methods/transferOwnership';\n\nexport { transferOwnership, renounceOwnership, acceptOwnership };\n","export * as read from './read';\nexport * as execute from './execute';\nexport * as encode from './encode';\nexport * as simulate from './simulate';\n","import { read as isPaused } from './methods/isPaused';\n\nexport { isPaused };\n","import { Pausable } from '@metamask/delegation-abis';\nimport type { Address, Client } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadIsPausedParameters = {\n  client: Client;\n  contractAddress: Address;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n}: ReadIsPausedParameters) =>\n  await readContract(client, {\n    address: contractAddress,\n    abi: Pausable.abi,\n    functionName: 'paused',\n  });\n","import { execute as pause } from './methods/pause';\nimport { execute as unpause } from './methods/unpause';\n\nexport { pause, unpause };\n","import type { Address, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport type { InitializedClient } from '../../types';\n\nconst PauseAbi = [\n  {\n    type: 'function',\n    name: 'pause',\n    inputs: [],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n];\n\nexport type SimulatePauseParameters = {\n  client: Client;\n  contractAddress: Address;\n};\n\nexport type ExecutePauseParameters = {\n  client: InitializedClient;\n  contractAddress: Address;\n};\n\nexport const simulate = async ({\n  client,\n  contractAddress,\n}: SimulatePauseParameters) => {\n  return simulateContract(client, {\n    address: contractAddress,\n    abi: PauseAbi,\n    functionName: 'pause',\n  });\n};\n\nexport const execute = async ({\n  client,\n  contractAddress,\n}: ExecutePauseParameters) => {\n  const { request } = await simulate({\n    client,\n    contractAddress,\n  });\n  return writeContract(client, request);\n};\n\nexport const encode = () => {\n  return encodeFunctionData({\n    abi: PauseAbi,\n    functionName: 'pause',\n  });\n};\n","import type { Address, Client } from 'viem';\nimport { encodeFunctionData } from 'viem';\nimport { simulateContract, writeContract } from 'viem/actions';\n\nimport type { InitializedClient } from '../../types';\n\nconst UnpauseAbi = [\n  {\n    type: 'function',\n    name: 'unpause',\n    inputs: [],\n    outputs: [],\n    stateMutability: 'nonpayable',\n  },\n];\n\nexport type SimulateUnpauseParameters = {\n  client: Client;\n  contractAddress: Address;\n};\n\nexport type ExecuteUnpauseParameters = {\n  client: InitializedClient;\n  contractAddress: Address;\n};\n\nexport const simulate = async ({\n  client,\n  contractAddress,\n}: SimulateUnpauseParameters) => {\n  return simulateContract(client, {\n    address: contractAddress,\n    abi: UnpauseAbi,\n    functionName: 'unpause',\n  });\n};\n\nexport const execute = async ({\n  client,\n  contractAddress,\n}: ExecuteUnpauseParameters) => {\n  const { request } = await simulate({\n    client,\n    contractAddress,\n  });\n  return writeContract(client, request);\n};\n\nexport const encode = () => {\n  return encodeFunctionData({\n    abi: UnpauseAbi,\n    functionName: 'unpause',\n  });\n};\n","import { encode as pause } from './methods/pause';\nimport { encode as unpause } from './methods/unpause';\n\nexport { pause, unpause };\n","import { simulate as pause } from './methods/pause';\nimport { simulate as unpause } from './methods/unpause';\n\nexport { pause, unpause };\n","import * as encode from './encode';\nimport * as execute from './execute';\nimport * as read from './read';\nimport * as simulate from './simulate';\n\nexport { read, simulate, execute, encode };\n","import { execute as create2Deploy } from './methods/create2Deploy';\n\nexport { create2Deploy };\n","import { read as getCreate2Address } from './methods/getCreate2Address';\n\nexport { getCreate2Address };\n","import { SimpleFactory } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport const read = async (\n  client: Client,\n  factoryAddress: Address,\n  creationCode: Hex,\n  salt: Hex,\n) => {\n  return readContract(client, {\n    address: factoryAddress,\n    abi: SimpleFactory.abi,\n    functionName: 'computeAddress',\n    args: [creationCode, salt],\n  });\n};\n","import { simulate as create2Deploy } from './methods/create2Deploy';\n\nexport { create2Deploy };\n","import * as read from './read';\n\nexport { read };\n","import { read as getTermsInfo } from './methods/getTermsInfo';\nimport { read as usedDelegations } from './methods/usedDelegations';\n\nexport { getTermsInfo, usedDelegations };\n","import { SpecificActionERC20TransferBatchEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadGetTermsInfoParameters = {\n  client: Client;\n  contractAddress: Address;\n  terms: Hex;\n};\n\nexport type TermsData = {\n  tokenAddress: Address;\n  recipient: Address;\n  amount: bigint;\n  firstTarget: Address;\n  firstCalldata: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  terms,\n}: ReadGetTermsInfoParameters): Promise<TermsData> => {\n  const termsData = await readContract(client, {\n    address: contractAddress,\n    abi: SpecificActionERC20TransferBatchEnforcer.abi,\n    functionName: 'getTermsInfo',\n    args: [terms],\n  });\n\n  return termsData as TermsData;\n};\n","import { SpecificActionERC20TransferBatchEnforcer } from '@metamask/delegation-abis';\nimport type { Address, Client, Hex } from 'viem';\nimport { readContract } from 'viem/actions';\n\nexport type ReadUsedDelegationsParameters = {\n  client: Client;\n  contractAddress: Address;\n  delegationManager: Address;\n  delegationHash: Hex;\n};\n\nexport const read = async ({\n  client,\n  contractAddress,\n  delegationManager,\n  delegationHash,\n}: ReadUsedDelegationsParameters): Promise<boolean> => {\n  const isUsed = await readContract(client, {\n    address: contractAddress,\n    abi: SpecificActionERC20TransferBatchEnforcer.abi,\n    functionName: 'usedDelegations',\n    args: [delegationManager, delegationHash],\n  });\n\n  return isUsed;\n};\n"],"names":["encode_exports","read_exports","encode_exports","encode","simulate","execute","DelegationManager","encodeFunctionData","simulateContract","writeContract","simulate","DelegationManager","simulateContract","execute","writeContract","encode","encodeFunctionData","DelegationManager","encodeFunctionData","simulateContract","writeContract","simulate","DelegationManager","simulateContract","execute","writeContract","encode","encodeFunctionData","execute","read_exports","read","DelegationManager","DelegationManager","readContract","read","DelegationManager","readContract","read","simulate","encode_exports","execute_exports","simulate_exports","execute_exports","execute","simulate_exports","simulate","read_exports","read_exports","read","readContract","read","readContract","read","readContract","read","read_exports","read_exports","read","readContract","read","read_exports","read_exports","read","readContract","read","ERC20TransferAmountEnforcer","readContract","read","constants_exports","read_exports","simulate_exports","read_exports","read","readContract","read","HybridDeleGator","readContract","read","HybridDeleGator","readContract","read","simulate_exports","simulate","constants_exports","DOMAIN_VERSION","NAME","VERSION","NAME","VERSION","DOMAIN_VERSION","read_exports","read_exports","read","readContract","read","IdEnforcer","readContract","read","read_exports","read_exports","read","readContract","read","LimitedCallsEnforcer","readContract","read","constants_exports","encode_exports","read_exports","simulate_exports","read_exports","read","readContract","read","MultiSigDeleGator","readContract","read","MultiSigDeleGator","readContract","read","MultiSigDeleGator","readContract","read","MultiSigDeleGator","readContract","read","simulate_exports","simulate","constants_exports","read_exports","read_exports","read","readContract","read","NativeTokenTransferAmountEnforcer","readContract","read","encode_exports","execute_exports","read_exports","simulate_exports","encode_exports","encode","encodeFunctionData","simulateContract","writeContract","encode","simulate","execute","execute_exports","execute","read_exports","read","NonceEnforcer","readContract","read","NonceEnforcer","readContract","read","simulate_exports","simulate","encode_exports","execute_exports","read_exports","simulate_exports","read_exports","read","readContract","read","Ownable2Step","readContract","read","execute_exports","execute","Ownable2Step","encodeFunctionData","simulateContract","writeContract","simulate","execute","encode","Ownable2Step","encodeFunctionData","simulateContract","writeContract","simulate","execute","encode","Ownable2Step","encodeFunctionData","simulateContract","writeContract","simulate","execute","encode","encode_exports","encode","simulate_exports","simulate","encode_exports","execute_exports","read_exports","simulate_exports","read_exports","read","readContract","read","execute_exports","execute","encodeFunctionData","simulateContract","writeContract","simulate","execute","encode","encodeFunctionData","simulateContract","writeContract","simulate","execute","encode","encode_exports","encode","simulate_exports","simulate","encode_exports","execute_exports","read_exports","simulate_exports","execute_exports","read_exports","read","readContract","read","simulate_exports","simulate","read_exports","read_exports","read","readContract","read","SpecificActionERC20TransferBatchEnforcer","readContract","read"],"mappings":"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"}},
    {"offset": {"line": 4329, "column": 0}, "map": {"version":3,"sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/write.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/delegatorEnvironment.ts"],"sourcesContent":["import { SimpleFactory, DelegationManager } from '@metamask/delegation-abis';\nimport type { Address, Chain, Hex, PublicClient, WalletClient } from 'viem';\n\nimport { encodePermissionContexts } from './delegation';\nimport type { ExecutionStruct, ExecutionMode } from './executions';\nimport { encodeExecutionCalldatas } from './executions';\nimport type { Delegation, ContractMetaData, Redemption } from './types';\n\n/**\n * Deploys a contract using the SimpleFactory contract.\n * @param walletClient - The wallet client to use for deployment.\n * @param publicClient - The public client to use for simulation.\n * @param simpleFactoryAddress - The address of the SimpleFactory contract.\n * @param creationCode - The creation code for the contract to deploy.\n * @param salt - The salt to use for deterministic deployment.\n * @returns The transaction hash of the deployment.\n */\nexport const deployWithSimpleFactory = async (\n  walletClient: WalletClient,\n  publicClient: PublicClient,\n  simpleFactoryAddress: Address,\n  creationCode: Hex,\n  salt: Hex,\n) => {\n  const { request } = await publicClient.simulateContract({\n    account: walletClient.account,\n    address: simpleFactoryAddress,\n    abi: SimpleFactory.abi,\n    functionName: 'deploy',\n    args: [creationCode, salt],\n  });\n  return await walletClient.writeContract(request);\n};\n\n/**\n * Redeems a delegation to execute the provided executions.\n * @param walletClient - The wallet client to use for redemption.\n * @param publicClient - The public client to use for simulation.\n * @param delegationManagerAddress - The address of the DelegationManager contract.\n * @param redemptions - The redemptions to execute, containing permission contexts, executions, and modes.\n * @returns The transaction hash of the redemption.\n */\nexport const redeemDelegations = async (\n  walletClient: WalletClient,\n  publicClient: PublicClient,\n  delegationManagerAddress: Address,\n  redemptions: Redemption[],\n) => {\n  if (redemptions.length === 0) {\n    throw new Error('RedeemDelegations invalid zero redemptions');\n  }\n\n  const permissionContexts: Delegation[][] = [];\n  const executionsBatch: ExecutionStruct[][] = [];\n  const executionModes: ExecutionMode[] = [];\n\n  redemptions.forEach((redemption) => {\n    permissionContexts.push(redemption.permissionContext);\n    executionsBatch.push(redemption.executions);\n    executionModes.push(redemption.mode);\n  });\n\n  const encodedPermissionContexts =\n    encodePermissionContexts(permissionContexts);\n  const executionCalldatas = encodeExecutionCalldatas(executionsBatch);\n\n  const { request } = await publicClient.simulateContract({\n    account: walletClient.account,\n    address: delegationManagerAddress,\n    abi: DelegationManager.abi,\n    functionName: 'redeemDelegations',\n    args: [encodedPermissionContexts, executionModes, executionCalldatas],\n  });\n  return await walletClient.writeContract(request);\n};\n\n/**\n * Deploys a contract to the blockchain.\n * @param walletClient - The wallet client to use for deployment.\n * @param publicClient - The public client to use for transaction receipt.\n * @param chain - The chain to deploy on.\n * @param contractMetadata - The metadata of the contract to deploy.\n * @param contractMetadata.bytecode - The bytecode of the contract to deploy.\n * @param contractMetadata.abi - The ABI of the contract to deploy.\n * @param args - The constructor arguments for the contract.\n * @returns An object containing the deployed contract address, transaction hash, and receipt.\n */\nexport async function deployContract(\n  walletClient: WalletClient,\n  publicClient: PublicClient,\n  chain: Chain,\n  { bytecode, abi }: ContractMetaData,\n  args: any[] = [],\n) {\n  if (!walletClient.account) {\n    throw new Error('Wallet client account is required');\n  }\n\n  const hash = await walletClient.deployContract({\n    abi,\n    bytecode,\n    args,\n    account: walletClient.account,\n    chain,\n  });\n\n  const receipt = await publicClient.waitForTransactionReceipt({\n    hash,\n  });\n\n  if (!receipt.contractAddress) {\n    throw new Error('No contract address in receipt');\n  }\n\n  return { address: receipt.contractAddress, hash, receipt };\n}\n","import {\n  EntryPoint,\n  SimpleFactory,\n  DelegationManager,\n  MultiSigDeleGator,\n  HybridDeleGator,\n  EIP7702StatelessDeleGator,\n  SCL_RIP7212,\n  AllowedTargetsEnforcer,\n  AllowedMethodsEnforcer,\n  DeployedEnforcer,\n  TimestampEnforcer,\n  NonceEnforcer,\n  AllowedCalldataEnforcer,\n  BlockNumberEnforcer,\n  LimitedCallsEnforcer,\n  ERC20BalanceChangeEnforcer,\n  ERC20StreamingEnforcer,\n  IdEnforcer,\n  ERC20TransferAmountEnforcer,\n  ValueLteEnforcer,\n  NativeTokenTransferAmountEnforcer,\n  NativeBalanceChangeEnforcer,\n  NativeTokenStreamingEnforcer,\n  NativeTokenPaymentEnforcer,\n  RedeemerEnforcer,\n  ArgsEqualityCheckEnforcer,\n  ERC721BalanceChangeEnforcer,\n  ERC721TransferEnforcer,\n  ERC1155BalanceChangeEnforcer,\n  OwnershipTransferEnforcer,\n  SpecificActionERC20TransferBatchEnforcer,\n  ERC20PeriodTransferEnforcer,\n  NativeTokenPeriodTransferEnforcer,\n  ExactCalldataBatchEnforcer,\n  ExactCalldataEnforcer,\n  ExactExecutionEnforcer,\n  ExactExecutionBatchEnforcer,\n  MultiTokenPeriodEnforcer,\n} from '@metamask/delegation-abis';\nimport { DELEGATOR_CONTRACTS } from '@metamask/delegation-deployments';\nimport type { Chain, Hex, PublicClient, WalletClient } from 'viem';\n\nimport type { ContractMetaData, DeleGatorEnvironment } from './types';\nimport { deployContract } from './write';\n\ntype SupportedVersion = '1.0.0' | '1.1.0' | '1.2.0' | '1.3.0';\nexport const PREFERRED_VERSION: SupportedVersion = '1.3.0';\n\nconst contractOverrideMap: Map<string, DeleGatorEnvironment> = new Map();\n\nconst getContractOverrideKey = (chainId: number, version: SupportedVersion) =>\n  `${version}:${chainId}`;\n\n/**\n * Overrides the deployed environment for a specific chain and version.\n * @param chainId - The chain ID to override.\n * @param version - The version of the environment to override.\n * @param environment - The environment to use as override.\n */\nexport function overrideDeployedEnvironment(\n  chainId: number,\n  version: SupportedVersion,\n  environment: DeleGatorEnvironment,\n) {\n  contractOverrideMap.set(\n    getContractOverrideKey(chainId, version),\n    environment,\n  );\n}\n\n/**\n * Gets the DeleGator environment for the specified chain and version.\n * @param chainId - The chain ID to get the environment for.\n * @param version - The version of the environment to get.\n * @returns The DeleGator environment.\n */\nexport function getDeleGatorEnvironment(\n  chainId: number,\n  version: SupportedVersion = PREFERRED_VERSION,\n): DeleGatorEnvironment {\n  const overrideKey = getContractOverrideKey(chainId, version);\n\n  const overriddenContracts = contractOverrideMap.get(overrideKey);\n  if (overriddenContracts) {\n    return overriddenContracts;\n  }\n\n  const contracts = DELEGATOR_CONTRACTS[version]?.[chainId];\n  if (!contracts) {\n    throw new Error(\n      `No contracts found for version ${version} chain ${chainId}`,\n    );\n  }\n  return getDeleGatorEnvironmentV1(contracts);\n}\n\n/**\n * Creates a DeleGator environment from contract addresses.\n * @param contracts - The contract addresses to create the environment from.\n * @returns The created DeleGator environment.\n */\nexport function getDeleGatorEnvironmentV1(contracts: {\n  [contract: string]: Hex;\n}) {\n  return {\n    DelegationManager: contracts.DelegationManager,\n    EntryPoint: contracts.EntryPoint,\n    SimpleFactory: contracts.SimpleFactory,\n    implementations: {\n      MultiSigDeleGatorImpl: contracts.MultiSigDeleGatorImpl,\n      HybridDeleGatorImpl: contracts.HybridDeleGatorImpl,\n      EIP7702StatelessDeleGatorImpl: contracts.EIP7702StatelessDeleGatorImpl,\n    },\n    caveatEnforcers: {\n      AllowedCalldataEnforcer: contracts.AllowedCalldataEnforcer,\n      AllowedMethodsEnforcer: contracts.AllowedMethodsEnforcer,\n      AllowedTargetsEnforcer: contracts.AllowedTargetsEnforcer,\n      ArgsEqualityCheckEnforcer: contracts.ArgsEqualityCheckEnforcer,\n      BlockNumberEnforcer: contracts.BlockNumberEnforcer,\n      DeployedEnforcer: contracts.DeployedEnforcer,\n      ERC20BalanceChangeEnforcer: contracts.ERC20BalanceChangeEnforcer,\n      ERC20TransferAmountEnforcer: contracts.ERC20TransferAmountEnforcer,\n      ERC20StreamingEnforcer: contracts.ERC20StreamingEnforcer,\n      ERC721BalanceChangeEnforcer: contracts.ERC721BalanceChangeEnforcer,\n      ERC721TransferEnforcer: contracts.ERC721TransferEnforcer,\n      ERC1155BalanceChangeEnforcer: contracts.ERC1155BalanceChangeEnforcer,\n      IdEnforcer: contracts.IdEnforcer,\n      LimitedCallsEnforcer: contracts.LimitedCallsEnforcer,\n      NonceEnforcer: contracts.NonceEnforcer,\n      TimestampEnforcer: contracts.TimestampEnforcer,\n      ValueLteEnforcer: contracts.ValueLteEnforcer,\n      NativeTokenTransferAmountEnforcer:\n        contracts.NativeTokenTransferAmountEnforcer,\n      NativeBalanceChangeEnforcer: contracts.NativeBalanceChangeEnforcer,\n      NativeTokenStreamingEnforcer: contracts.NativeTokenStreamingEnforcer,\n      NativeTokenPaymentEnforcer: contracts.NativeTokenPaymentEnforcer,\n      OwnershipTransferEnforcer: contracts.OwnershipTransferEnforcer,\n      RedeemerEnforcer: contracts.RedeemerEnforcer,\n      SpecificActionERC20TransferBatchEnforcer:\n        contracts.SpecificActionERC20TransferBatchEnforcer,\n      ERC20PeriodTransferEnforcer: contracts.ERC20PeriodTransferEnforcer,\n      NativeTokenPeriodTransferEnforcer:\n        contracts.NativeTokenPeriodTransferEnforcer,\n      ExactCalldataBatchEnforcer: contracts.ExactCalldataBatchEnforcer,\n      ExactCalldataEnforcer: contracts.ExactCalldataEnforcer,\n      ExactExecutionEnforcer: contracts.ExactExecutionEnforcer,\n      ExactExecutionBatchEnforcer: contracts.ExactExecutionBatchEnforcer,\n      MultiTokenPeriodEnforcer: contracts.MultiTokenPeriodEnforcer,\n    },\n  } as DeleGatorEnvironment;\n}\n\nexport type DeployedContract = {\n  name: string;\n  address: string;\n};\n\n/**\n * Deploys the contracts needed for the Delegation Framework and DeleGator SCA to be functional as well as all Caveat Enforcers.\n * @param walletClient - The wallet client to use for deployment.\n * @param publicClient - The public client to use for deployment.\n * @param chain - The chain to deploy to.\n * @param deployedContracts - Optional map of already deployed contracts.\n * @returns A promise that resolves when all contracts are deployed.\n */\nexport async function deployDeleGatorEnvironment(\n  walletClient: WalletClient,\n  publicClient: PublicClient,\n  chain: Chain,\n  deployedContracts: { [contract: string]: Hex } = {},\n) {\n  const deployContractCurried = async (\n    name: string,\n    contract: ContractMetaData,\n    params: any[] = [],\n  ) => {\n    const existingAddress = deployedContracts[name];\n    if (existingAddress) {\n      return {\n        address: existingAddress,\n        name,\n      };\n    }\n\n    const deployedContract = await deployContract(\n      walletClient,\n      publicClient,\n      chain,\n      contract,\n      params,\n    );\n\n    const newDeployedContracts = { ...deployedContracts };\n    newDeployedContracts[name] = deployedContract.address;\n    Object.assign(deployedContracts, newDeployedContracts);\n\n    return { ...deployedContract, name };\n  };\n\n  // Deploy v1.3.0 DeleGator contracts\n  // - deploy standalone contracts\n  const standaloneContracts = {\n    SimpleFactory,\n    AllowedCalldataEnforcer,\n    AllowedTargetsEnforcer,\n    AllowedMethodsEnforcer,\n    ArgsEqualityCheckEnforcer,\n    DeployedEnforcer,\n    TimestampEnforcer,\n    BlockNumberEnforcer,\n    LimitedCallsEnforcer,\n    ERC20BalanceChangeEnforcer,\n    ERC20TransferAmountEnforcer,\n    ERC20StreamingEnforcer,\n    ERC721BalanceChangeEnforcer,\n    ERC721TransferEnforcer,\n    ERC1155BalanceChangeEnforcer,\n    IdEnforcer,\n    NonceEnforcer,\n    ValueLteEnforcer,\n    NativeTokenTransferAmountEnforcer,\n    NativeBalanceChangeEnforcer,\n    NativeTokenStreamingEnforcer,\n    OwnershipTransferEnforcer,\n    RedeemerEnforcer,\n    SpecificActionERC20TransferBatchEnforcer,\n    ERC20PeriodTransferEnforcer,\n    NativeTokenPeriodTransferEnforcer,\n    ExactCalldataBatchEnforcer,\n    ExactCalldataEnforcer,\n    ExactExecutionEnforcer,\n    ExactExecutionBatchEnforcer,\n    MultiTokenPeriodEnforcer,\n  };\n  for (const [name, contract] of Object.entries(standaloneContracts)) {\n    await deployContractCurried(name, contract);\n  }\n\n  // - deploy dependencies\n  const delegationManager = await deployContractCurried(\n    'DelegationManager',\n    DelegationManager,\n    [walletClient.account?.address],\n  );\n\n  // - NativeTokenPaymentEnforcer DelegationManager and ArgsEqualityCheckEnforcer as constructor args\n  await deployContractCurried(\n    'NativeTokenPaymentEnforcer',\n    NativeTokenPaymentEnforcer,\n    [delegationManager.address, deployedContracts.ArgsEqualityCheckEnforcer],\n  );\n\n  const entryPoint = await deployContractCurried('EntryPoint', EntryPoint);\n\n  // This is a hack to work around the SCL_RIP7212 being deployed as a library.\n  // Forge handles this gracefully, but in the tests we need to manually link\n  // the library.\n  // We don't use the curried function here because we don't need it added to\n  // the environment.\n  const { address: sclRIP7212 } = await deployContract(\n    walletClient,\n    publicClient,\n    chain,\n    SCL_RIP7212,\n    [],\n  );\n\n  // replace linked library address in bytecode https://docs.soliditylang.org/en/latest/using-the-compiler.html#library-linking\n  const hybridDeleGatorWithLinkedLibrary = {\n    ...HybridDeleGator,\n    bytecode: HybridDeleGator.bytecode.replace(\n      /__\\$b8f96b288d4d0429e38b8ed50fd423070f\\$__/gu,\n      sclRIP7212.slice(2),\n    ) as Hex,\n  };\n\n  // - deploy DeleGator implementations\n  await deployContractCurried(\n    'HybridDeleGatorImpl',\n    hybridDeleGatorWithLinkedLibrary,\n    [delegationManager.address, entryPoint.address],\n  );\n\n  await deployContractCurried('MultiSigDeleGatorImpl', MultiSigDeleGator, [\n    delegationManager.address,\n    entryPoint.address,\n  ]);\n\n  await deployContractCurried(\n    'EIP7702StatelessDeleGatorImpl',\n    EIP7702StatelessDeleGator,\n    [delegationManager.address, entryPoint.address],\n  );\n\n  // Format deployments\n  return getDeleGatorEnvironmentV1(deployedContracts);\n}\n"],"names":["SimpleFactory","DelegationManager","SimpleFactory","DelegationManager"],"mappings":"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"}},
    {"offset": {"line": 4553, "column": 0}, "map": {"version":3,"sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/toMetaMaskSmartAccount.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/signer.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/signatures.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/actions/caveatEnforcerClient.ts","file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-toolkit/src/actions/infuraBundlerClient.ts"],"sourcesContent":["import {\n  EIP7702StatelessDeleGator,\n  HybridDeleGator,\n  MultiSigDeleGator,\n} from '@metamask/delegation-abis';\nimport { type Address, type Hex } from 'viem';\nimport {\n  entryPoint07Abi,\n  toPackedUserOperation,\n  toSmartAccount,\n} from 'viem/account-abstraction';\n\nimport { isValid7702Implementation } from './actions/isValid7702Implementation';\nimport { Implementation } from './constants';\nimport { getCounterfactualAccountData } from './counterfactualAccountData';\nimport {\n  SIGNABLE_DELEGATION_TYPED_DATA,\n  toDelegationStruct,\n} from './delegation';\nimport { entryPointGetNonce as _getNonce } from './DelegationFramework/EntryPoint/read';\nimport { getDeleGatorEnvironment } from './delegatorEnvironment';\nimport { encodeCallsForCaller } from './encodeCalls';\nimport { resolveSigner } from './signer';\nimport type {\n  Call,\n  ToMetaMaskSmartAccountParameters,\n  ToMetaMaskSmartAccountReturnType,\n  SignDelegationParams,\n  SignUserOperationParams,\n  AbiByImplementation,\n} from './types';\nimport { SIGNABLE_USER_OP_TYPED_DATA } from './userOp';\n\nconst ENTRYPOINT_VERSION = '0.7' as const;\n\n/**\n * Creates a MetaMask DeleGator smart account instance.\n *\n * @template TImplementation - The type of implementation, extending Implementation.\n * @param params - The parameters for creating the smart account.\n * @returns A promise that resolves to a MetaMask DeleGator smart account instance.\n * @description\n * This function sets up a MetaMask DeleGator smart account with the specified implementation.\n * It handles both deployed accounts, and counterfactual accounts.\n * A caller may specify a DeleGator environment, otherwise the environment will be inferred from the chain.\n */\nexport async function toMetaMaskSmartAccount<\n  TImplementation extends Implementation,\n>(\n  params: ToMetaMaskSmartAccountParameters<TImplementation>,\n): Promise<ToMetaMaskSmartAccountReturnType<TImplementation>> {\n  const {\n    client,\n    client: { chain },\n    implementation,\n  } = params;\n\n  if (!chain) {\n    throw new Error('Chain not specified');\n  }\n\n  const signer = resolveSigner({\n    implementation,\n    signer: params.signer,\n  });\n\n  const environment = params.environment ?? getDeleGatorEnvironment(chain.id);\n\n  let address: Address, factoryData: Hex | undefined;\n\n  if (params.address) {\n    factoryData = undefined;\n    address = params.address;\n  } else {\n    if (implementation === Implementation.Stateless7702) {\n      throw new Error('Stateless7702 does not support counterfactual accounts');\n    }\n\n    const accountData = await getCounterfactualAccountData({\n      factory: environment.SimpleFactory,\n      implementations: environment.implementations,\n      implementation,\n      deployParams: params.deployParams,\n      deploySalt: params.deploySalt,\n    });\n\n    address = accountData.address;\n    factoryData = accountData.factoryData;\n  }\n\n  const entryPoint = {\n    abi: entryPoint07Abi,\n    address: environment.EntryPoint,\n    version: ENTRYPOINT_VERSION,\n  } as const;\n\n  const { abi, contractName } = {\n    [Implementation.Hybrid]: {\n      contractName: 'HybridDeleGator',\n      abi: HybridDeleGator.abi,\n    },\n    [Implementation.MultiSig]: {\n      contractName: 'MultiSigDeleGator',\n      abi: MultiSigDeleGator.abi,\n    },\n    [Implementation.Stateless7702]: {\n      contractName: 'EIP7702StatelessDeleGator',\n      abi: EIP7702StatelessDeleGator.abi,\n    },\n  }[implementation] as {\n    contractName: string;\n    abi: AbiByImplementation[TImplementation];\n  };\n\n  const getFactoryArgs = async () => {\n    if (factoryData === undefined) {\n      throw new Error(\n        'Deploy params were not provided, so factory args cannot be inferred',\n      );\n    }\n    return {\n      factoryData,\n      factory: environment.SimpleFactory,\n    };\n  };\n\n  const signDelegation = async (delegationParams: SignDelegationParams) => {\n    const { delegation, chainId } = delegationParams;\n\n    const delegationStruct = toDelegationStruct({\n      ...delegation,\n      signature: '0x',\n    });\n\n    const signature = signer.signTypedData({\n      domain: {\n        chainId: chainId ?? chain.id,\n        name: 'DelegationManager',\n        version: '1',\n        verifyingContract: environment.DelegationManager,\n      },\n      types: SIGNABLE_DELEGATION_TYPED_DATA,\n      primaryType: 'Delegation',\n      message: delegationStruct,\n    });\n\n    return signature;\n  };\n\n  const signUserOperation = async (userOpParams: SignUserOperationParams) => {\n    const { chainId } = userOpParams;\n\n    const packedUserOp = toPackedUserOperation({\n      sender: address,\n      ...userOpParams,\n      signature: '0x',\n    });\n\n    const signature = await signer.signTypedData({\n      domain: {\n        chainId: chainId ?? chain.id,\n        name: contractName,\n        version: '1',\n        verifyingContract: address,\n      },\n      types: SIGNABLE_USER_OP_TYPED_DATA,\n      primaryType: 'PackedUserOperation',\n      message: { ...packedUserOp, entryPoint: entryPoint.address },\n    });\n\n    return signature;\n  };\n\n  const getAddress = async () => address;\n\n  const getNonce = async () =>\n    _getNonce({\n      client,\n      entryPoint: environment.EntryPoint,\n      contractAddress: address,\n      key: 0n,\n    });\n\n  const encodeCalls = async (calls: readonly Call[]) =>\n    encodeCallsForCaller(address, calls);\n\n  const smartAccount = await toSmartAccount({\n    abi,\n    client,\n    entryPoint,\n    environment,\n    getAddress,\n    getFactoryArgs,\n    encodeCalls,\n    getNonce,\n    signUserOperation,\n    signDelegation,\n    ...signer,\n  });\n\n  // Override isDeployed only for EIP-7702 implementation to check proper delegation code\n  if (implementation === Implementation.Stateless7702) {\n    return {\n      ...smartAccount,\n      isDeployed: async () =>\n        isValid7702Implementation({\n          client,\n          accountAddress: address,\n          environment,\n        }),\n    };\n  }\n\n  // For other implementations, use the default isDeployed behavior\n  return smartAccount;\n}\n","import { concat } from 'viem';\nimport type {\n  Address,\n  SignableMessage,\n  TypedData,\n  TypedDataDefinition,\n} from 'viem';\nimport type { SignReturnType as WebAuthnSignReturnType } from 'webauthn-p256';\n\nimport { Implementation } from './constants';\nimport { aggregateSignature } from './signatures';\nimport type {\n  AccountSignerConfig,\n  HybridSignerConfig,\n  InternalSigner,\n  MultiSigSignerConfig,\n  SignerConfigByImplementation,\n  Stateless7702SignerConfig,\n  WalletSignerConfig,\n} from './types';\nimport {\n  createDummyWebAuthnSignature,\n  encodeDeleGatorSignature,\n} from './webAuthn';\n\n// A valid ECDSA signature, this must be able to ecrecover an address, otherwise the contracts will revert in isValidSignature\nconst EOA_STUB_SIGNATURE =\n  '0x000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000011b' as const;\n\nconst resolveSignerFromWalletConfig = (\n  config: WalletSignerConfig,\n): InternalSigner => {\n  return {\n    signMessage: config.walletClient.signMessage,\n    signTypedData: async (typedData) => {\n      // todo: figure out this type so that we don't need the type assertion\n      return config.walletClient.signTypedData(typedData as any);\n    },\n    getStubSignature: async () => EOA_STUB_SIGNATURE,\n  };\n};\n\nconst resolveSignerFromAccountConfig = (config: AccountSignerConfig) => {\n  return {\n    signMessage: config.account.signMessage,\n    signTypedData: config.account.signTypedData,\n    getStubSignature: async () => EOA_STUB_SIGNATURE,\n  };\n};\n\nconst resolveHybridSigner = (config: HybridSignerConfig): InternalSigner => {\n  if ('walletClient' in config) {\n    return resolveSignerFromWalletConfig(config);\n  } else if ('account' in config) {\n    const { signMessage, signTypedData, getStubSignature } =\n      resolveSignerFromAccountConfig(config);\n    if (!signMessage) {\n      throw new Error('Account does not support signMessage');\n    }\n    if (!signTypedData) {\n      throw new Error('Account does not support signTypedData');\n    }\n    return {\n      signMessage,\n      signTypedData,\n      getStubSignature,\n    };\n  }\n  const { keyId, webAuthnAccount } = config;\n\n  if (webAuthnAccount.type !== 'webAuthn') {\n    throw new Error('Account is not a webAuthn account');\n  }\n\n  const encodeSignature = ({ signature, webauthn }: WebAuthnSignReturnType) =>\n    encodeDeleGatorSignature(\n      keyId,\n      signature,\n      webauthn.clientDataJSON,\n      webauthn.authenticatorData,\n    );\n\n  const signMessage = async (args: { message: SignableMessage }) =>\n    webAuthnAccount.signMessage(args).then(encodeSignature);\n  const signTypedData = async <\n    const TTypedData extends TypedData | Record<string, unknown>,\n    TPrimaryType extends keyof TTypedData | 'EIP712Domain' = keyof TTypedData,\n  >(\n    typedDataDefinition: TypedDataDefinition<TTypedData, TPrimaryType>,\n  ) => webAuthnAccount.signTypedData(typedDataDefinition).then(encodeSignature);\n\n  const getStubSignature = async () => createDummyWebAuthnSignature(keyId);\n\n  return {\n    signMessage,\n    signTypedData,\n    getStubSignature,\n  };\n};\n\nconst resolveMultiSigSigner = (\n  config: MultiSigSignerConfig,\n): InternalSigner => {\n  const resolvedSigners = config.map((signer) => {\n    let individualSignMessage: InternalSigner['signMessage'];\n    let individualSignTypedData: InternalSigner['signTypedData'];\n    let address: Address;\n    if ('walletClient' in signer) {\n      const { signMessage, signTypedData } =\n        resolveSignerFromWalletConfig(signer);\n      individualSignMessage = signMessage;\n      individualSignTypedData = signTypedData;\n\n      address = signer.walletClient.account.address;\n    } else {\n      const { signMessage, signTypedData } =\n        resolveSignerFromAccountConfig(signer);\n      if (!signMessage) {\n        throw new Error('Account does not support signMessage');\n      }\n      if (!signTypedData) {\n        throw new Error('Account does not support signTypedData');\n      }\n\n      individualSignMessage = signMessage;\n      individualSignTypedData = signTypedData;\n\n      address = signer.account.address;\n    }\n    return {\n      address,\n      individualSignMessage,\n      individualSignTypedData,\n    };\n  });\n\n  const signMessage = async (args: { message: SignableMessage }) => {\n    const addressAndSignatures = resolvedSigners.map(\n      async ({ individualSignMessage, address }) => ({\n        signature: await individualSignMessage(args),\n        signer: address,\n        type: 'ECDSA' as const,\n      }),\n    );\n\n    const signatures = await Promise.all(addressAndSignatures);\n\n    return aggregateSignature({\n      signatures,\n    });\n  };\n\n  const signTypedData = async <\n    const TTypedData extends TypedData | Record<string, unknown>,\n    TPrimaryType extends keyof TTypedData | 'EIP712Domain' = keyof TTypedData,\n  >(\n    typedDataDefinition: TypedDataDefinition<TTypedData, TPrimaryType>,\n  ) => {\n    const addressAndSignatures = resolvedSigners.map(\n      async ({ individualSignTypedData, address }) => ({\n        signature: await individualSignTypedData(typedDataDefinition),\n        signer: address,\n        type: 'ECDSA' as const,\n      }),\n    );\n\n    const signatures = await Promise.all(addressAndSignatures);\n\n    return aggregateSignature({\n      signatures,\n    });\n  };\n\n  const getStubSignature = async () =>\n    concat(resolvedSigners.map(() => EOA_STUB_SIGNATURE));\n\n  return {\n    signMessage,\n    signTypedData,\n    getStubSignature,\n  };\n};\n\nconst resolveStateless7702Signer = (\n  config: Stateless7702SignerConfig,\n): InternalSigner => {\n  if ('walletClient' in config) {\n    return resolveSignerFromWalletConfig(config);\n  } else if ('account' in config) {\n    const { signMessage, signTypedData, getStubSignature } =\n      resolveSignerFromAccountConfig(config);\n    if (!signMessage) {\n      throw new Error('Account does not support signMessage');\n    }\n    if (!signTypedData) {\n      throw new Error('Account does not support signTypedData');\n    }\n\n    return {\n      signMessage,\n      signTypedData,\n      getStubSignature,\n    };\n  }\n\n  throw new Error('Invalid signer config');\n};\n\nexport const resolveSigner = <TImplementation extends Implementation>(config: {\n  implementation: TImplementation;\n  signer: SignerConfigByImplementation<TImplementation>;\n}): InternalSigner => {\n  const { implementation } = config;\n\n  if (implementation === Implementation.Hybrid) {\n    return resolveHybridSigner(config.signer as HybridSignerConfig);\n  } else if (implementation === Implementation.MultiSig) {\n    return resolveMultiSigSigner(config.signer as MultiSigSignerConfig);\n  } else if (implementation === Implementation.Stateless7702) {\n    return resolveStateless7702Signer(\n      config.signer as Stateless7702SignerConfig,\n    );\n  }\n  throw new Error(`Implementation type '${implementation}' not supported`);\n};\n","import type { Address, Hex } from 'viem';\nimport { concat } from 'viem';\n\nconst signatureTypes = ['ECDSA'] as const;\n\nexport type SignatureType = (typeof signatureTypes)[number];\n\n/**\n * Represents a partial signature that can be aggregated with others.\n */\nexport type PartialSignature = {\n  signer: Address;\n  signature: Hex;\n  type: SignatureType;\n};\n\n/**\n * Aggregates signatures into a single signature as expected by the MultiSig implementation.\n * @param params - The parameters for signature aggregation.\n * @param params.signatures - The array of partial signatures to aggregate.\n * @returns The aggregated signature.\n */\nexport const aggregateSignature = ({\n  signatures,\n}: {\n  signatures: PartialSignature[];\n}): Hex => {\n  if (signatures.length === 0) {\n    return '0x';\n  }\n\n  for (const { type } of signatures) {\n    if (!signatureTypes.includes(type)) {\n      throw new Error(`Invalid signature type: ${type}`);\n    }\n  }\n\n  // Sort signatures by signer address as required by MultiSig implementation\n  const sortedSignatures = [...signatures].sort((a, b) =>\n    a.signer.localeCompare(b.signer),\n  );\n\n  // Concatenate all signatures\n  return concat(sortedSignatures.map(({ signature }) => signature));\n};\n\n/**\n * Type definition for the aggregateSignature function parameters.\n */\nexport type AggregateSignatureParams = {\n  signatures: PartialSignature[];\n};\n","import type { Client, Transport, Chain, Account } from 'viem';\n\nimport type { DeleGatorEnvironment } from '../types';\nimport {\n  caveatEnforcerActions,\n  type CaveatEnforcerParams,\n  type PeriodTransferResult,\n  type StreamingResult,\n} from './getCaveatAvailableAmount';\n\n/**\n * Type for client extended with caveat enforcer actions.\n */\nexport type CaveatEnforcerClient<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = Account | undefined,\n> = Client<TTransport, TChain, TAccount> &\n  ReturnType<ReturnType<typeof caveatEnforcerActions>>;\n\n/**\n * Create a viem client extended with caveat enforcer actions.\n *\n * @param params - The parameters object.\n * @param params.client - The viem client.\n * @param params.environment - The delegator environment.\n * @returns The extended client with caveat enforcer actions.\n */\nexport function createCaveatEnforcerClient<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends Account | undefined = Account | undefined,\n>({\n  client,\n  environment,\n}: {\n  client: Client<TTransport, TChain, TAccount>;\n  environment: DeleGatorEnvironment;\n}): CaveatEnforcerClient<TTransport, TChain, TAccount> {\n  return client.extend(caveatEnforcerActions({ environment }));\n}\n\n// Re-export types for convenience\nexport type { CaveatEnforcerParams, PeriodTransferResult, StreamingResult };\n","import type { Transport, Chain, Hex, Client, Account } from 'viem';\nimport {\n  createBundlerClient,\n  type BundlerClient,\n  type BundlerClientConfig,\n  type SmartAccount,\n} from 'viem/account-abstraction';\n\n/**\n * Gas price tiers returned by pimlico_getUserOperationGasPrice\n */\nexport type GasPriceTier = {\n  /** Maximum fee per gas in hex format */\n  maxFeePerGas: Hex;\n  /** Maximum priority fee per gas in hex format */\n  maxPriorityFeePerGas: Hex;\n};\n\n/**\n * Response from pimlico_getUserOperationGasPrice RPC method\n */\nexport type UserOperationGasPriceResponse = {\n  /** Slow gas price tier */\n  slow: GasPriceTier;\n  /** Standard gas price tier */\n  standard: GasPriceTier;\n  /** Fast gas price tier */\n  fast: GasPriceTier;\n};\n\n/**\n * Pimlico bundler schema for type-safe RPC method calls\n */\n/* eslint-disable @typescript-eslint/naming-convention */\ntype PimlicoBundlerSchema = [\n  {\n    Method: 'pimlico_getUserOperationGasPrice';\n    Parameters: [];\n    ReturnType: UserOperationGasPriceResponse;\n  },\n];\n\n/**\n * Infura bundler actions for extending bundler clients.\n *\n * @returns A function that takes a client and returns the client extension with Infura bundler actions.\n */\nconst infuraBundlerActions = () => (client: Client) => ({\n  /**\n   * Get user operation gas prices from Infura bundler.\n   * Calls the pimlico_getUserOperationGasPrice RPC method.\n   *\n   * @returns Promise resolving to gas price tiers (slow, standard, fast).\n   * @example\n   * ```typescript\n   * const gasPrices = await bundlerClient.getUserOperationGasPrice();\n   * console.log(gasPrices.standard.maxFeePerGas);\n   * ```\n   */\n  async getUserOperationGasPrice(): Promise<UserOperationGasPriceResponse> {\n    const pimlicoClient = client as Client<\n      Transport,\n      Chain | undefined,\n      Account | undefined,\n      PimlicoBundlerSchema\n    >;\n\n    return await pimlicoClient.request({\n      method: 'pimlico_getUserOperationGasPrice',\n      params: [],\n    });\n  },\n});\n\n/**\n * Type for bundler client extended with Infura bundler actions.\n */\nexport type InfuraBundlerClient<\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends SmartAccount | undefined = SmartAccount | undefined,\n> = BundlerClient<TTransport, TChain, TAccount> & {\n  /**\n   * Get user operation gas prices from Infura bundler.\n   * Calls the pimlico_getUserOperationGasPrice RPC method.\n   *\n   * @returns Promise resolving to gas price tiers (slow, standard, fast).\n   */\n  getUserOperationGasPrice(): Promise<UserOperationGasPriceResponse>;\n};\n\n/**\n * Creates an Infura bundler client extended with Infura bundler actions.\n *\n * This is a wrapper around viem's createBundlerClient that extends it with\n * the getUserOperationGasPrice method for retrieving gas prices from Pimlico's\n * bundler infrastructure via Infura's proxy.\n *\n * @param config - Configuration for the bundler client.\n * @returns Extended bundler client with Infura bundler actions.\n * @example\n * ```typescript\n * import { createPublicClient, http } from 'viem';\n * import { sepolia } from 'viem/chains';\n * import { createInfuraBundlerClient } from '@metamask/delegation-toolkit';\n *\n * const publicClient = createPublicClient({\n *   chain: sepolia,\n *   transport: http('https://sepolia.infura.io/v3/YOUR_API_KEY'),\n * });\n *\n * const bundlerClient = createInfuraBundlerClient({\n *   client: publicClient,\n *   transport: http('https://sepolia.infura.io/v3/YOUR_API_KEY'),\n *   chain: sepolia,\n * });\n *\n * // Use standard bundler methods\n * const userOpHash = await bundlerClient.sendUserOperation({...});\n *\n * // Use Infura specific methods\n * const gasPrices = await bundlerClient.getUserOperationGasPrice();\n * ```\n */\nexport function createInfuraBundlerClient<\n  TTransport extends Transport,\n  TChain extends Chain | undefined = undefined,\n  TAccount extends SmartAccount | undefined = undefined,\n>(\n  config: BundlerClientConfig<TTransport, TChain, TAccount>,\n): InfuraBundlerClient<TTransport, TChain, TAccount> {\n  // Create the base bundler client using viem's function\n  const baseBundlerClient = createBundlerClient(config);\n\n  // Extend the client with Infura bundler actions\n  return baseBundlerClient.extend(\n    infuraBundlerActions(),\n  ) as unknown as InfuraBundlerClient<TTransport, TChain, TAccount>;\n}\n"],"names":["concat","signMessage","signTypedData","getStubSignature","concat","signDelegation","signUserOperation"],"mappings":"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"}}]
}