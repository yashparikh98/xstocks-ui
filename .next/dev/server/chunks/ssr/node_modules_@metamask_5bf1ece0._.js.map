{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/delegation-core/node_modules/@metamask/utils/dist/misc.mjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-core/node_modules/%40metamask/utils/src/misc.ts"],"sourcesContent":["//\n// Types\n//\n\n/**\n * Makes every specified property of the specified object type mutable.\n *\n * @template ObjectValue - The object whose readonly properties to make mutable.\n * @template TargetKey - The property key(s) to make mutable.\n */\nexport type Mutable<\n  ObjectValue extends Record<string, unknown>,\n  TargetKey extends keyof ObjectValue,\n> = {\n  -readonly [Key in keyof Pick<ObjectValue, TargetKey>]: ObjectValue[Key];\n} & {\n  [Key in keyof Omit<ObjectValue, TargetKey>]: ObjectValue[Key];\n};\n\n/**\n * Get a type representing the public interface of the given type. The\n * returned type will have all public properties, but will omit private\n * properties.\n *\n * @template Interface - The interface to return a public representation of.\n */\nexport type PublicInterface<Interface> = Pick<Interface, keyof Interface>;\n\n/**\n * Useful for representing some value that _might_ be present and / or complete.\n *\n * @template Value - The value that might be present or complete.\n */\nexport type PartialOrAbsent<Value> = Partial<Value> | null | undefined;\n\n/**\n * Like {@link Array}, but always non-empty.\n *\n * @template Element - The non-empty array member type.\n */\nexport type NonEmptyArray<Element> = [Element, ...Element[]];\n\n/**\n * A JavaScript object that is not `null`, a function, or an array.\n */\nexport type RuntimeObject = Record<PropertyKey, unknown>;\n\n//\n// Type Guards\n//\n\n/**\n * A {@link NonEmptyArray} type guard.\n *\n * @template Element - The non-empty array member type.\n * @param value - The value to check.\n * @returns Whether the value is a non-empty array.\n */\nexport function isNonEmptyArray<Element>(\n  value: Element[],\n): value is NonEmptyArray<Element> {\n  return Array.isArray(value) && value.length > 0;\n}\n\n/**\n * Type guard for \"nullishness\".\n *\n * @param value - Any value.\n * @returns `true` if the value is null or undefined, `false` otherwise.\n */\nexport function isNullOrUndefined(value: unknown): value is null | undefined {\n  return value === null || value === undefined;\n}\n\n/**\n * A type guard for {@link RuntimeObject}.\n *\n * @param value - The value to check.\n * @returns Whether the specified value has a runtime type of `object` and is\n * neither `null` nor an `Array`.\n */\nexport function isObject(value: unknown): value is RuntimeObject {\n  return Boolean(value) && typeof value === 'object' && !Array.isArray(value);\n}\n\n//\n// Other utility functions\n//\n\n/**\n * A type guard for ensuring an object has a property.\n *\n * @param objectToCheck - The object to check.\n * @param name - The property name to check for.\n * @returns Whether the specified object has an own property with the specified\n * name, regardless of whether it is enumerable or not.\n */\nexport const hasProperty = <\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  ObjectToCheck extends Object,\n  Property extends PropertyKey,\n>(\n  objectToCheck: ObjectToCheck,\n  name: Property,\n): objectToCheck is ObjectToCheck &\n  Record<\n    Property,\n    Property extends keyof ObjectToCheck ? ObjectToCheck[Property] : unknown\n  > => Object.hasOwnProperty.call(objectToCheck, name);\n\n/**\n * `Object.getOwnPropertyNames()` is intentionally generic: it returns the\n * immediate property names of an object, but it cannot make guarantees about\n * the contents of that object, so the type of the property names is merely\n * `string[]`. While this is technically accurate, it is also unnecessary if we\n * have an object with a type that we own (such as an enum).\n *\n * @param object - The plain object.\n * @returns The own property names of the object which are assigned a type\n * derived from the object itself.\n */\nexport function getKnownPropertyNames<Key extends PropertyKey>(\n  object: Partial<Record<Key, any>>,\n): Key[] {\n  return Object.getOwnPropertyNames(object) as Key[];\n}\n\nexport type PlainObject = Record<number | string | symbol, unknown>;\n\n/**\n * Predefined sizes (in Bytes) of specific parts of JSON structure.\n */\nexport enum JsonSize {\n  Null = 4,\n  Comma = 1,\n  Wrapper = 1,\n  True = 4,\n  False = 5,\n  Quote = 1,\n  Colon = 1,\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  Date = 24,\n}\n\n/**\n * Regular expression with pattern matching for (special) escaped characters.\n */\nexport const ESCAPE_CHARACTERS_REGEXP = /\"|\\\\|\\n|\\r|\\t/gu;\n\n/**\n * Check if the value is plain object.\n *\n * @param value - Value to be checked.\n * @returns True if an object is the plain JavaScript object,\n * false if the object is not plain (e.g. function).\n */\nexport function isPlainObject(value: unknown): value is PlainObject {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n\n  try {\n    let proto = value;\n    while (Object.getPrototypeOf(proto) !== null) {\n      proto = Object.getPrototypeOf(proto);\n    }\n\n    return Object.getPrototypeOf(value) === proto;\n  } catch (_) {\n    return false;\n  }\n}\n\n/**\n * Check if character is ASCII.\n *\n * @param character - Character.\n * @returns True if a character code is ASCII, false if not.\n */\nexport function isASCII(character: string) {\n  return character.charCodeAt(0) <= 127;\n}\n\n/**\n * Calculate string size.\n *\n * @param value - String value to calculate size.\n * @returns Number of bytes used to store whole string value.\n */\nexport function calculateStringSize(value: string): number {\n  const size = value.split('').reduce((total, character) => {\n    if (isASCII(character)) {\n      return total + 1;\n    }\n    return total + 2;\n  }, 0);\n\n  // Also detect characters that need backslash escape\n  return size + (value.match(ESCAPE_CHARACTERS_REGEXP) ?? []).length;\n}\n\n/**\n * Calculate size of a number ofter JSON serialization.\n *\n * @param value - Number value to calculate size.\n * @returns Number of bytes used to store whole number in JSON.\n */\nexport function calculateNumberSize(value: number): number {\n  return value.toString().length;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/delegation-core/node_modules/@metamask/utils/dist/errors.mjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-core/node_modules/%40metamask/utils/src/errors.ts"],"sourcesContent":["import { ErrorWithCause } from 'pony-cause';\n\nimport { isNullOrUndefined, isObject } from './misc';\n\n/**\n * Type guard for determining whether the given value is an instance of Error.\n * For errors generated via `fs.promises`, `error instanceof Error` won't work,\n * so we have to come up with another way of testing.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isError(error: unknown): error is Error {\n  return (\n    error instanceof Error ||\n    (isObject(error) && error.constructor.name === 'Error')\n  );\n}\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `code` property such as the type of error that Node throws for filesystem\n * operations, etc.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nexport function isErrorWithCode(error: unknown): error is { code: string } {\n  return typeof error === 'object' && error !== null && 'code' in error;\n}\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `message` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nexport function isErrorWithMessage(\n  error: unknown,\n): error is { message: string } {\n  return typeof error === 'object' && error !== null && 'message' in error;\n}\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `stack` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nexport function isErrorWithStack(error: unknown): error is { stack: string } {\n  return typeof error === 'object' && error !== null && 'stack' in error;\n}\n\n/**\n * Attempts to obtain the message from a possible error object, defaulting to an\n * empty string if it is impossible to do so.\n *\n * @param error - The possible error to get the message from.\n * @returns The message if `error` is an object with a `message` property;\n * the string version of `error` if it is not `undefined` or `null`; otherwise\n * an empty string.\n */\nexport function getErrorMessage(error: unknown): string {\n  if (isErrorWithMessage(error) && typeof error.message === 'string') {\n    return error.message;\n  }\n\n  if (isNullOrUndefined(error)) {\n    return '';\n  }\n\n  return String(error);\n}\n\n/**\n * Builds a new error object, linking it to the original error via the `cause`\n * property if it is an Error.\n *\n * This function is useful to reframe error messages in general, but is\n * _critical_ when interacting with any of Node's filesystem functions as\n * provided via `fs.promises`, because these do not produce stack traces in the\n * case of an I/O error (see <https://github.com/nodejs/node/issues/30944>).\n *\n * @param originalError - The error to be wrapped (something throwable).\n * @param message - The desired message of the new error.\n * @returns A new error object.\n */\nexport function wrapError<Throwable>(\n  originalError: Throwable,\n  message: string,\n): Error & { code?: string } {\n  if (isError(originalError)) {\n    let error: Error & { code?: string };\n    if (Error.length === 2) {\n      // for some reason `tsserver` is not complaining that the\n      // Error constructor doesn't support a second argument in the editor,\n      // but `tsc` does. Error causes are not supported by our current tsc target (ES2020, we need ES2022 to make this work)\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      error = new Error(message, { cause: originalError });\n    } else {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      error = new ErrorWithCause(message, { cause: originalError });\n    }\n\n    if (isErrorWithCode(originalError)) {\n      error.code = originalError.code;\n    }\n\n    return error;\n  }\n\n  if (message.length > 0) {\n    return new Error(`${String(originalError)}: ${message}`);\n  }\n\n  return new Error(String(originalError));\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,OAAO,EAAE,cAAc,EAAE,mBAAmB;AAE5C,OAAO,EAAE,iBAAiB,EAAE,QAAQ,EAAE,mBAAe;;;AAErD;;;;;;;GAOG,CACH,SAAS,OAAO,CAAC,KAAc;IAC7B,OAAO,AACL,KAAK,YAAY,KAAK,QACrB,oNAAQ,EAAC,KAAK,CAAC,IAAI,KAAK,CAAC,WAAW,CAAC,IAAI,KAAK,OAAO,CAAC,CACxD,CAAC;AACJ,CAAC;AAUK,SAAU,eAAe,CAAC,KAAc;IAC5C,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,IAAI,IAAI,MAAM,IAAI,KAAK,CAAC;AACxE,CAAC;AASK,SAAU,kBAAkB,CAChC,KAAc;IAEd,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,IAAI,IAAI,SAAS,IAAI,KAAK,CAAC;AAC3E,CAAC;AASK,SAAU,gBAAgB,CAAC,KAAc;IAC7C,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,IAAI,IAAI,OAAO,IAAI,KAAK,CAAC;AACzE,CAAC;AAWK,SAAU,eAAe,CAAC,KAAc;IAC5C,IAAI,kBAAkB,CAAC,KAAK,CAAC,IAAI,OAAO,KAAK,CAAC,OAAO,KAAK,QAAQ,EAAE;QAClE,OAAO,KAAK,CAAC,OAAO,CAAC;KACtB;IAED,QAAI,6NAAiB,EAAC,KAAK,CAAC,EAAE;QAC5B,OAAO,EAAE,CAAC;KACX;IAED,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC;AACvB,CAAC;AAeK,SAAU,SAAS,CACvB,aAAwB,EACxB,OAAe;IAEf,IAAI,OAAO,CAAC,aAAa,CAAC,EAAE;QAC1B,IAAI,KAAgC,CAAC;QACrC,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;YACtB,yDAAyD;YACzD,qEAAqE;YACrE,sHAAsH;YACtH,6DAA6D;YAC7D,aAAa;YACb,KAAK,GAAG,IAAI,KAAK,CAAC,OAAO,EAAE;gBAAE,KAAK,EAAE,aAAa;YAAA,CAAE,CAAC,CAAC;SACtD,MAAM;YACL,6DAA6D;YAC7D,aAAa;YACb,KAAK,GAAG,IAAI,iLAAc,CAAC,OAAO,EAAE;gBAAE,KAAK,EAAE,aAAa;YAAA,CAAE,CAAC,CAAC;SAC/D;QAED,IAAI,eAAe,CAAC,aAAa,CAAC,EAAE;YAClC,KAAK,CAAC,IAAI,GAAG,aAAa,CAAC,IAAI,CAAC;SACjC;QAED,OAAO,KAAK,CAAC;KACd;IAED,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;QACtB,OAAO,IAAI,KAAK,CAAC,GAAG,MAAM,CAAC,aAAa,CAAC,CAAA,EAAA,EAAK,OAAO,EAAE,CAAC,CAAC;KAC1D;IAED,OAAO,IAAI,KAAK,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,CAAC;AAC1C,CAAC"}},
    {"offset": {"line": 178, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/delegation-core/node_modules/@metamask/utils/dist/assert.mjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-core/node_modules/%40metamask/utils/src/assert.ts"],"sourcesContent":["import type { Struct } from '@metamask/superstruct';\nimport { assert as assertSuperstruct } from '@metamask/superstruct';\n\nimport { getErrorMessage } from './errors';\n\nexport type AssertionErrorConstructor =\n  | (new (args: { message: string }) => Error)\n  | ((args: { message: string }) => Error);\n\n/**\n * Check if a value is a constructor, i.e., a function that can be called with\n * the `new` keyword.\n *\n * @param fn - The value to check.\n * @returns `true` if the value is a constructor, or `false` otherwise.\n */\nfunction isConstructable(\n  fn: AssertionErrorConstructor,\n): fn is new (args: { message: string }) => Error {\n  /* istanbul ignore next */\n  return Boolean(typeof fn?.prototype?.constructor?.name === 'string');\n}\n\n/**\n * Attempts to obtain the message from a possible error object. If it is\n * possible to do so, any trailing period will be removed from the message;\n * otherwise an empty string is returned.\n *\n * @param error - The error object to get the message from.\n * @returns The message without any trailing period if `error` is an object\n * with a `message` property; the string version of `error` without any trailing\n * period if it is not `undefined` or `null`; otherwise an empty string.\n */\nfunction getErrorMessageWithoutTrailingPeriod(error: unknown): string {\n  // We'll add our own period.\n  return getErrorMessage(error).replace(/\\.$/u, '');\n}\n\n/**\n * Initialise an {@link AssertionErrorConstructor} error.\n *\n * @param ErrorWrapper - The error class to use.\n * @param message - The error message.\n * @returns The error object.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction getError(ErrorWrapper: AssertionErrorConstructor, message: string) {\n  if (isConstructable(ErrorWrapper)) {\n    return new ErrorWrapper({\n      message,\n    });\n  }\n  return ErrorWrapper({\n    message,\n  });\n}\n\n/**\n * The default error class that is thrown if an assertion fails.\n */\nexport class AssertionError extends Error {\n  readonly code = 'ERR_ASSERTION';\n\n  constructor(options: { message: string }) {\n    super(options.message);\n  }\n}\n\n/**\n * Same as Node.js assert.\n * If the value is falsy, throws an error, does nothing otherwise.\n *\n * @throws {@link AssertionError} If value is falsy.\n * @param value - The test that should be truthy to pass.\n * @param message - Message to be passed to {@link AssertionError} or an\n * {@link Error} instance to throw.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}. If a custom error class is provided for\n * the `message` argument, this argument is ignored.\n */\nexport function assert(\n  value: any,\n  message: string | Error = 'Assertion failed.',\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper: AssertionErrorConstructor = AssertionError,\n): asserts value {\n  if (!value) {\n    if (message instanceof Error) {\n      throw message;\n    }\n\n    throw getError(ErrorWrapper, message);\n  }\n}\n\n/**\n * Assert a value against a Superstruct struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param errorPrefix - A prefix to add to the error message. Defaults to\n * \"Assertion failed\".\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the value is not valid.\n */\nexport function assertStruct<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  errorPrefix = 'Assertion failed',\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper: AssertionErrorConstructor = AssertionError,\n): asserts value is Type {\n  try {\n    assertSuperstruct(value, struct);\n  } catch (error) {\n    throw getError(\n      ErrorWrapper,\n      `${errorPrefix}: ${getErrorMessageWithoutTrailingPeriod(error)}.`,\n    );\n  }\n}\n\n/**\n * Use in the default case of a switch that you want to be fully exhaustive.\n * Using this function forces the compiler to enforce exhaustivity during\n * compile-time.\n *\n * @example\n * ```\n * const number = 1;\n * switch (number) {\n *   case 0:\n *     ...\n *   case 1:\n *     ...\n *   default:\n *     assertExhaustive(snapPrefix);\n * }\n * ```\n * @param _object - The object on which the switch is being operated.\n */\nexport function assertExhaustive(_object: never): never {\n  throw new Error(\n    'Invalid branch reached. Should be detected during compilation.',\n  );\n}\n"],"names":[],"mappings":";;;;;;;;;;AACA,OAAO,EAAE,MAAM,IAAI,iBAAiB,EAAE,8BAA8B;AAEpE,OAAO,EAAE,eAAe,EAAE,qBAAiB;;;AAM3C;;;;;;GAMG,CACH,SAAS,eAAe,CACtB,EAA6B;IAE7B,wBAAA,EAA0B,CAC1B,OAAO,OAAO,CAAC,OAAO,EAAE,EAAE,SAAS,EAAE,WAAW,EAAE,IAAI,KAAK,QAAQ,CAAC,CAAC;AACvE,CAAC;AAED;;;;;;;;;GASG,CACH,SAAS,oCAAoC,CAAC,KAAc;IAC1D,4BAA4B;IAC5B,WAAO,6NAAe,EAAC,KAAK,CAAC,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;AACpD,CAAC;AAED;;;;;;GAMG,CACH,gEAAgE;AAChE,SAAS,QAAQ,CAAC,YAAuC,EAAE,OAAe;IACxE,IAAI,eAAe,CAAC,YAAY,CAAC,EAAE;QACjC,OAAO,IAAI,YAAY,CAAC;YACtB,OAAO;SACR,CAAC,CAAC;KACJ;IACD,OAAO,YAAY,CAAC;QAClB,OAAO;KACR,CAAC,CAAC;AACL,CAAC;AAKK,MAAO,cAAe,SAAQ,KAAK;IAGvC,YAAY,OAA4B,CAAA;QACtC,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;QAHhB,IAAA,CAAA,IAAI,GAAG,eAAe,CAAC;IAIhC,CAAC;CACF;AAcK,SAAU,MAAM,CACpB,KAAU,EACV,UAA0B,mBAAmB,EAC7C,gEAAgE;AAChE,eAA0C,cAAc;IAExD,IAAI,CAAC,KAAK,EAAE;QACV,IAAI,OAAO,YAAY,KAAK,EAAE;YAC5B,MAAM,OAAO,CAAC;SACf;QAED,MAAM,QAAQ,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;KACvC;AACH,CAAC;AAaK,SAAU,YAAY,CAC1B,KAAc,EACd,MAA4B,EAC5B,WAAW,GAAG,kBAAkB,EAChC,gEAAgE;AAChE,eAA0C,cAAc;IAExD,IAAI;YACF,sKAAiB,EAAC,KAAK,EAAE,MAAM,CAAC,CAAC;KAClC,CAAC,OAAO,KAAK,EAAE;QACd,MAAM,QAAQ,CACZ,YAAY,EACZ,GAAG,WAAW,CAAA,EAAA,EAAK,oCAAoC,CAAC,KAAK,CAAC,CAAA,CAAA,CAAG,CAClE,CAAC;KACH;AACH,CAAC;AAqBK,SAAU,gBAAgB,CAAC,OAAc;IAC7C,MAAM,IAAI,KAAK,CACb,gEAAgE,CACjE,CAAC;AACJ,CAAC"}},
    {"offset": {"line": 261, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/delegation-core/node_modules/@metamask/utils/dist/hex.mjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-core/node_modules/%40metamask/utils/src/hex.ts"],"sourcesContent":["import { pattern, type Struct, string } from '@metamask/superstruct';\nimport { keccak_256 as keccak256 } from '@noble/hashes/sha3';\nimport { memoize } from 'lodash';\n\nimport { assert } from './assert';\n\nexport type Hex = `0x${string}`;\n\n// Use native regexes instead of superstruct for maximum performance.\n// Pre-compiled regex for maximum performance - avoids recompilation on each call\nconst HEX_REGEX = /^(?:0x)?[0-9a-f]+$/iu;\nconst STRICT_HEX_REGEX = /^0x[0-9a-f]+$/iu;\nconst HEX_ADDRESS_REGEX = /^0x[0-9a-f]{40}$/u;\nconst HEX_CHECKSUM_ADDRESS_REGEX = /^0x[0-9a-fA-F]{40}$/u;\n\nexport const HexStruct = pattern(string(), HEX_REGEX);\nexport const StrictHexStruct = pattern(string(), STRICT_HEX_REGEX) as Struct<\n  Hex,\n  null\n>;\nexport const HexAddressStruct = pattern(string(), HEX_ADDRESS_REGEX) as Struct<\n  Hex,\n  null\n>;\nexport const HexChecksumAddressStruct = pattern(\n  string(),\n  HEX_CHECKSUM_ADDRESS_REGEX,\n) as Struct<Hex, null>;\n\nconst isString = (value: unknown): value is string => typeof value === 'string';\n\n/**\n * Check if a string is a valid hex string.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nexport function isHexString(value: unknown): value is string {\n  return isString(value) && HEX_REGEX.test(value);\n}\n\n/**\n * Strictly check if a string is a valid hex string. A valid hex string must\n * start with the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nexport function isStrictHexString(value: unknown): value is Hex {\n  return isString(value) && STRICT_HEX_REGEX.test(value);\n}\n\n/**\n * Check if a string is a valid hex address.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex address.\n */\nexport function isHexAddress(value: unknown): value is Hex {\n  return isString(value) && HEX_ADDRESS_REGEX.test(value);\n}\n\n/**\n * Check if a string is a valid hex checksum address.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex checksum address.\n */\nexport function isHexChecksumAddress(value: unknown): value is Hex {\n  return isString(value) && HEX_CHECKSUM_ADDRESS_REGEX.test(value);\n}\n\n/**\n * Assert that a value is a valid hex string.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nexport function assertIsHexString(value: unknown): asserts value is string {\n  assert(isHexString(value), 'Value must be a hexadecimal string.');\n}\n\n/**\n * Assert that a value is a valid hex string. A valid hex string must start with\n * the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nexport function assertIsStrictHexString(value: unknown): asserts value is Hex {\n  assert(\n    isStrictHexString(value),\n    'Value must be a hexadecimal string, starting with \"0x\".',\n  );\n}\n\n/**\n * Encode a passed hex string as an ERC-55 mixed-case checksum address.\n * This is the unmemoized version, primarily used for testing.\n *\n * @param hexAddress - The hex address to encode.\n * @returns The address encoded according to ERC-55.\n * @see https://eips.ethereum.org/EIPS/eip-55\n */\nexport function getChecksumAddressUnmemoized(hexAddress: Hex): Hex {\n  assert(isHexChecksumAddress(hexAddress), 'Invalid hex address.');\n  const address = remove0x(hexAddress).toLowerCase();\n\n  const hashBytes = keccak256(address);\n  const { length } = address;\n  const result = new Array(length); // Pre-allocate array\n\n  for (let i = 0; i < length; i++) {\n    /* eslint-disable no-bitwise */\n    const byteIndex = i >> 1; // Faster than Math.floor(i / 2)\n    const nibbleIndex = i & 1; // Faster than i % 2\n    const byte = hashBytes[byteIndex] as number;\n    const nibble = nibbleIndex === 0 ? byte >> 4 : byte & 0x0f;\n    /* eslint-enable no-bitwise */\n\n    result[i] = nibble >= 8 ? (address[i] as string).toUpperCase() : address[i];\n  }\n\n  return `0x${result.join('')}`;\n}\n\n/**\n * Encode a passed hex string as an ERC-55 mixed-case checksum address.\n * This function is memoized for performance.\n *\n * @param hexAddress - The hex address to encode.\n * @returns The address encoded according to ERC-55.\n * @see https://eips.ethereum.org/EIPS/eip-55\n */\nexport const getChecksumAddress = memoize(getChecksumAddressUnmemoized);\n\n/**\n * Validate that the passed hex string is a valid ERC-55 mixed-case\n * checksum address.\n *\n * @param possibleChecksum - The hex address to check.\n * @returns True if the address is a checksum address.\n */\nexport function isValidChecksumAddressUnmemoized(possibleChecksum: Hex) {\n  if (!isHexChecksumAddress(possibleChecksum)) {\n    return false;\n  }\n\n  return getChecksumAddress(possibleChecksum) === possibleChecksum;\n}\n\n/**\n * Validate that the passed hex string is a valid ERC-55 mixed-case\n * checksum address.\n *\n * @param possibleChecksum - The hex address to check.\n * @returns True if the address is a checksum address.\n */\nexport const isValidChecksumAddress = memoize(isValidChecksumAddressUnmemoized);\n\n/**\n * Validate that the passed prefixed hex string is an all-lowercase\n * hex address, or a valid mixed-case checksum address.\n *\n * @param possibleAddress - Input parameter to check against.\n * @returns Whether or not the input is a valid hex address.\n */\nexport function isValidHexAddressUnmemoized(possibleAddress: Hex) {\n  return (\n    isHexAddress(possibleAddress) || isValidChecksumAddress(possibleAddress)\n  );\n}\n\n/**\n * Validate that the passed prefixed hex string is an all-lowercase\n * hex address, or a valid mixed-case checksum address.\n *\n * @param possibleAddress - Input parameter to check against.\n * @returns Whether or not the input is a valid hex address.\n */\nexport const isValidHexAddress = memoize(isValidHexAddressUnmemoized);\n\n/**\n * Add the `0x`-prefix to a hexadecimal string. If the string already has the\n * prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to add the prefix to.\n * @returns The prefixed hexadecimal string.\n */\nexport function add0x(hexadecimal: string): Hex {\n  if (hexadecimal.startsWith('0x')) {\n    return hexadecimal as Hex;\n  }\n\n  if (hexadecimal.startsWith('0X')) {\n    return `0x${hexadecimal.substring(2)}`;\n  }\n\n  return `0x${hexadecimal}`;\n}\n\n/**\n * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have\n * the prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to remove the prefix from.\n * @returns The un-prefixed hexadecimal string.\n */\nexport function remove0x(hexadecimal: string): string {\n  if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {\n    return hexadecimal.substring(2);\n  }\n\n  return hexadecimal;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 384, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/delegation-core/node_modules/@metamask/utils/dist/bytes.mjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/delegation-core/node_modules/%40metamask/utils/src/bytes.ts"],"sourcesContent":["import { base64 } from '@scure/base';\n\nimport { assert } from './assert';\nimport type { Hex } from './hex';\nimport { add0x, assertIsHexString, remove0x } from './hex';\n\n// '0'.charCodeAt(0) === 48\nconst HEX_MINIMUM_NUMBER_CHARACTER = 48;\n\n// '9'.charCodeAt(0) === 57\nconst HEX_MAXIMUM_NUMBER_CHARACTER = 58;\nconst HEX_CHARACTER_OFFSET = 87;\n\nexport type Bytes = bigint | number | string | Uint8Array;\n\n/**\n * Memoized function that returns an array to be used as a lookup table for\n * converting bytes to hexadecimal values.\n *\n * The array is created lazily and then cached for future use. The benefit of\n * this approach is that the performance of converting bytes to hex is much\n * better than if we were to call `toString(16)` on each byte.\n *\n * The downside is that the array is created once and then never garbage\n * collected. This is not a problem in practice because the array is only 256\n * elements long.\n *\n * @returns A function that returns the lookup table.\n */\nfunction getPrecomputedHexValuesBuilder(): () => string[] {\n  // To avoid issues with tree shaking, we need to use a function to return the\n  // array. This is because the array is only used in the `bytesToHex` function\n  // and if we were to use a global variable, the array might be removed by the\n  // tree shaker.\n  const lookupTable: string[] = [];\n\n  return () => {\n    if (lookupTable.length === 0) {\n      for (let i = 0; i < 256; i++) {\n        lookupTable.push(i.toString(16).padStart(2, '0'));\n      }\n    }\n\n    return lookupTable;\n  };\n}\n\n/**\n * Function implementation of the {@link getPrecomputedHexValuesBuilder}\n * function.\n */\nconst getPrecomputedHexValues = getPrecomputedHexValuesBuilder();\n\n/**\n * Check if a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @returns Whether the value is a `Uint8Array`.\n */\nexport function isBytes(value: unknown): value is Uint8Array {\n  return value instanceof Uint8Array;\n}\n\n/**\n * Assert that a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @throws If the value is not a `Uint8Array`.\n */\nexport function assertIsBytes(value: unknown): asserts value is Uint8Array {\n  assert(isBytes(value), 'Value must be a Uint8Array.');\n}\n\n/**\n * Convert a `Uint8Array` to a hexadecimal string.\n *\n * @param bytes - The bytes to convert to a hexadecimal string.\n * @returns The hexadecimal string.\n */\nexport function bytesToHex(bytes: Uint8Array): Hex {\n  assertIsBytes(bytes);\n\n  if (bytes.length === 0) {\n    return '0x';\n  }\n\n  const lookupTable = getPrecomputedHexValues();\n  const hexadecimal = new Array(bytes.length);\n\n  for (let i = 0; i < bytes.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    hexadecimal[i] = lookupTable[bytes[i]!];\n  }\n\n  return add0x(hexadecimal.join(''));\n}\n\n/**\n * Convert a `Uint8Array` to a `bigint`.\n *\n * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.\n * To convert a two's complement encoded `Uint8Array` to a `bigint`, use\n * {@link bytesToSignedBigInt}.\n *\n * @param bytes - The bytes to convert to a `bigint`.\n * @returns The `bigint`.\n */\nexport function bytesToBigInt(bytes: Uint8Array): bigint {\n  assertIsBytes(bytes);\n\n  const hexadecimal = bytesToHex(bytes);\n  return BigInt(hexadecimal);\n}\n\n/**\n * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are\n * encoded in two's complement.\n *\n * To convert a `Uint8Array` to an unsigned `bigint` instead, use\n * {@link bytesToBigInt}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param bytes - The bytes to convert to a signed `bigint`.\n * @returns The signed `bigint`.\n */\nexport function bytesToSignedBigInt(bytes: Uint8Array): bigint {\n  assertIsBytes(bytes);\n\n  let value = BigInt(0);\n  for (const byte of bytes) {\n    // eslint-disable-next-line no-bitwise\n    value = (value << BigInt(8)) + BigInt(byte);\n  }\n\n  return BigInt.asIntN(bytes.length * 8, value);\n}\n\n/**\n * Convert a `Uint8Array` to a `number`.\n *\n * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.\n *\n * @param bytes - The bytes to convert to a number.\n * @returns The number.\n * @throws If the resulting number is not a safe integer.\n */\nexport function bytesToNumber(bytes: Uint8Array): number {\n  assertIsBytes(bytes);\n\n  const bigint = bytesToBigInt(bytes);\n\n  assert(\n    bigint <= BigInt(Number.MAX_SAFE_INTEGER),\n    'Number is not a safe integer. Use `bytesToBigInt` instead.',\n  );\n\n  return Number(bigint);\n}\n\n/**\n * Convert a UTF-8 encoded `Uint8Array` to a `string`.\n *\n * @param bytes - The bytes to convert to a string.\n * @returns The string.\n */\nexport function bytesToString(bytes: Uint8Array): string {\n  assertIsBytes(bytes);\n\n  return new TextDecoder().decode(bytes);\n}\n\n/**\n * Convert a `Uint8Array` to a base64 encoded string.\n *\n * @param bytes - The bytes to convert to a base64 encoded string.\n * @returns The base64 encoded string.\n */\nexport function bytesToBase64(bytes: Uint8Array): string {\n  assertIsBytes(bytes);\n\n  return base64.encode(bytes);\n}\n\n/**\n * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be\n * prefixed with `0x`. It accepts even and odd length strings.\n *\n * If the value is \"0x\", an empty `Uint8Array` is returned.\n *\n * @param value - The hexadecimal string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function hexToBytes(value: string): Uint8Array {\n  // \"0x\" is often used as empty byte array.\n  if (value?.toLowerCase?.() === '0x') {\n    return new Uint8Array();\n  }\n\n  assertIsHexString(value);\n\n  // Remove the `0x` prefix if it exists, and pad the string to have an even\n  // number of characters.\n  const strippedValue = remove0x(value).toLowerCase();\n  const normalizedValue =\n    strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;\n  const bytes = new Uint8Array(normalizedValue.length / 2);\n\n  for (let i = 0; i < bytes.length; i++) {\n    // While this is not the prettiest way to convert a hexadecimal string to a\n    // `Uint8Array`, it is a lot faster than using `parseInt` to convert each\n    // character.\n    const c1 = normalizedValue.charCodeAt(i * 2);\n    const c2 = normalizedValue.charCodeAt(i * 2 + 1);\n    const n1 =\n      c1 -\n      (c1 < HEX_MAXIMUM_NUMBER_CHARACTER\n        ? HEX_MINIMUM_NUMBER_CHARACTER\n        : HEX_CHARACTER_OFFSET);\n    const n2 =\n      c2 -\n      (c2 < HEX_MAXIMUM_NUMBER_CHARACTER\n        ? HEX_MINIMUM_NUMBER_CHARACTER\n        : HEX_CHARACTER_OFFSET);\n\n    bytes[i] = n1 * 16 + n2;\n  }\n\n  return bytes;\n}\n\n/**\n * Convert a `bigint` to a `Uint8Array`.\n *\n * This assumes that the `bigint` is an unsigned integer. To convert a signed\n * `bigint` instead, use {@link signedBigIntToBytes}.\n *\n * @param value - The bigint to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function bigIntToBytes(value: bigint): Uint8Array {\n  assert(typeof value === 'bigint', 'Value must be a bigint.');\n  assert(value >= BigInt(0), 'Value must be a non-negative bigint.');\n\n  const hexadecimal = value.toString(16);\n  return hexToBytes(hexadecimal);\n}\n\n/**\n * Check if a `bigint` fits in a certain number of bytes.\n *\n * @param value - The `bigint` to check.\n * @param bytes - The number of bytes.\n * @returns Whether the `bigint` fits in the number of bytes.\n */\nfunction bigIntFits(value: bigint, bytes: number): boolean {\n  assert(bytes > 0);\n\n  /* eslint-disable no-bitwise */\n  const mask = value >> BigInt(31);\n  return !(((~value & mask) + (value & ~mask)) >> BigInt(bytes * 8 + ~0));\n  /* eslint-enable no-bitwise */\n}\n\n/**\n * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement\n * encoding to represent negative numbers.\n *\n * To convert an unsigned `bigint` to a `Uint8Array` instead, use\n * {@link bigIntToBytes}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param value - The number to convert to bytes.\n * @param byteLength - The length of the resulting `Uint8Array`. If the number\n * is larger than the maximum value that can be represented by the given length,\n * an error is thrown.\n * @returns The bytes as `Uint8Array`.\n */\nexport function signedBigIntToBytes(\n  value: bigint,\n  byteLength: number,\n): Uint8Array {\n  assert(typeof value === 'bigint', 'Value must be a bigint.');\n  assert(typeof byteLength === 'number', 'Byte length must be a number.');\n  assert(byteLength > 0, 'Byte length must be greater than 0.');\n  assert(\n    bigIntFits(value, byteLength),\n    'Byte length is too small to represent the given value.',\n  );\n\n  // ESLint doesn't like mutating function parameters, so to avoid having to\n  // disable the rule, we create a new variable.\n  let numberValue = value;\n  const bytes = new Uint8Array(byteLength);\n\n  for (let i = 0; i < bytes.length; i++) {\n    bytes[i] = Number(BigInt.asUintN(8, numberValue));\n    // eslint-disable-next-line no-bitwise\n    numberValue >>= BigInt(8);\n  }\n\n  return bytes.reverse();\n}\n\n/**\n * Convert a `number` to a `Uint8Array`.\n *\n * @param value - The number to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n * @throws If the number is not a safe integer.\n */\nexport function numberToBytes(value: number): Uint8Array {\n  assert(typeof value === 'number', 'Value must be a number.');\n  assert(value >= 0, 'Value must be a non-negative number.');\n  assert(\n    Number.isSafeInteger(value),\n    'Value is not a safe integer. Use `bigIntToBytes` instead.',\n  );\n\n  const hexadecimal = value.toString(16);\n  return hexToBytes(hexadecimal);\n}\n\n/**\n * Convert a `string` to a UTF-8 encoded `Uint8Array`.\n *\n * @param value - The string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function stringToBytes(value: string): Uint8Array {\n  assert(typeof value === 'string', 'Value must be a string.');\n\n  return new TextEncoder().encode(value);\n}\n\n/**\n * Convert a base64 encoded string to a `Uint8Array`.\n *\n * @param value - The base64 encoded string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function base64ToBytes(value: string): Uint8Array {\n  assert(typeof value === 'string', 'Value must be a string.');\n\n  return base64.decode(value);\n}\n\n/**\n * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,\n * a `bigint`, a `number`, or a `string`.\n *\n * This will attempt to guess the type of the value based on its type and\n * contents. For more control over the conversion, use the more specific\n * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.\n *\n * If the value is a `string`, and it is prefixed with `0x`, it will be\n * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a\n * UTF-8 string. To convert a hexadecimal string to bytes without interpreting\n * it as a UTF-8 string, use {@link hexToBytes} instead.\n *\n * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed\n * `bigint` to bytes, use {@link signedBigIntToBytes} instead.\n *\n * If the value is a `Uint8Array`, it will be returned as-is.\n *\n * @param value - The value to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function valueToBytes(value: Bytes): Uint8Array {\n  if (typeof value === 'bigint') {\n    return bigIntToBytes(value);\n  }\n\n  if (typeof value === 'number') {\n    return numberToBytes(value);\n  }\n\n  if (typeof value === 'string') {\n    if (value.startsWith('0x')) {\n      return hexToBytes(value);\n    }\n\n    return stringToBytes(value);\n  }\n\n  if (isBytes(value)) {\n    return value;\n  }\n\n  throw new TypeError(`Unsupported value type: \"${typeof value}\".`);\n}\n\n/**\n * Concatenate multiple byte-like values into a single `Uint8Array`. The values\n * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses\n * {@link valueToBytes} under the hood to convert each value to bytes. Refer to\n * the documentation of that function for more information.\n *\n * @param values - The values to concatenate.\n * @returns The concatenated bytes as `Uint8Array`.\n */\nexport function concatBytes(values: Bytes[]): Uint8Array {\n  const normalizedValues = new Array(values.length);\n  let byteLength = 0;\n\n  for (let i = 0; i < values.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const value = valueToBytes(values[i]!);\n\n    normalizedValues[i] = value;\n    byteLength += value.length;\n  }\n\n  const bytes = new Uint8Array(byteLength);\n  for (let i = 0, offset = 0; i < normalizedValues.length; i++) {\n    // While we could simply spread the values into an array and use\n    // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.\n    bytes.set(normalizedValues[i], offset);\n    offset += normalizedValues[i].length;\n  }\n\n  return bytes;\n}\n\n/**\n * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience\n * function that avoids having to create a {@link DataView} manually, which\n * requires passing the `byteOffset` and `byteLength` parameters every time.\n *\n * Not passing the `byteOffset` and `byteLength` parameters can result in\n * unexpected behavior when the {@link Uint8Array} is a view of a larger\n * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.\n *\n * This function also supports Node.js {@link Buffer}s.\n *\n * @example\n * ```typescript\n * const bytes = new Uint8Array([1, 2, 3]);\n *\n * // This is equivalent to:\n * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n * const dataView = createDataView(bytes);\n * ```\n * @param bytes - The bytes to create the {@link DataView} from.\n * @returns The {@link DataView}.\n */\nexport function createDataView(bytes: Uint8Array): DataView {\n  // To maintain compatibility with Node.js, we need to check if the bytes are\n  // a Buffer. If so, we need to slice the buffer to get the underlying\n  // ArrayBuffer.\n  // eslint-disable-next-line no-restricted-globals\n  if (typeof Buffer !== 'undefined' && bytes instanceof Buffer) {\n    const buffer = bytes.buffer.slice(\n      bytes.byteOffset,\n      bytes.byteOffset + bytes.byteLength,\n    );\n\n    return new DataView(buffer);\n  }\n\n  return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n}\n\n/**\n * Compare two Uint8Arrays using a constant-time style loop to reduce timing\n * side-channels when comparing sensitive data (e.g., mnemonic bytes, keys,\n * authentication tags). Does not early-return on the first difference:\n * work done depends only on the input lengths, so byte content does not affect timing.\n *\n * When to use:\n * - Use for secret or security-sensitive byte comparisons to avoid content-based timing leaks.\n * - Prefer when inputs are fixed-length (or validated to equal length) at the API boundary.\n *\n * @param a - The first Uint8Array to compare.\n * @param b - The second Uint8Array to compare.\n * @returns Whether the Uint8Arrays are equal.\n */\nexport function areUint8ArraysEqual(a: Uint8Array, b: Uint8Array): boolean {\n  // eslint-disable-next-line no-bitwise\n  let diff = a.byteLength ^ b.byteLength;\n  const len = Math.max(a.byteLength, b.byteLength);\n\n  for (let i = 0; i < len; i++) {\n    const aByte = a[i] ?? 0;\n    const bByte = b[i] ?? 0;\n    // eslint-disable-next-line no-bitwise\n    diff |= aByte ^ bByte;\n  }\n\n  return diff === 0;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 646, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/misc.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/misc.ts"],"sourcesContent":["//\n// Types\n//\n\n/**\n * Makes every specified property of the specified object type mutable.\n *\n * @template ObjectValue - The object whose readonly properties to make mutable.\n * @template TargetKey - The property key(s) to make mutable.\n */\nexport type Mutable<\n  ObjectValue extends Record<string, unknown>,\n  TargetKey extends keyof ObjectValue,\n> = {\n  -readonly [Key in keyof Pick<ObjectValue, TargetKey>]: ObjectValue[Key];\n} & {\n  [Key in keyof Omit<ObjectValue, TargetKey>]: ObjectValue[Key];\n};\n\n/**\n * Get a type representing the public interface of the given type. The\n * returned type will have all public properties, but will omit private\n * properties.\n *\n * @template Interface - The interface to return a public representation of.\n */\nexport type PublicInterface<Interface> = Pick<Interface, keyof Interface>;\n\n/**\n * Useful for representing some value that _might_ be present and / or complete.\n *\n * @template Value - The value that might be present or complete.\n */\nexport type PartialOrAbsent<Value> = Partial<Value> | null | undefined;\n\n/**\n * Like {@link Array}, but always non-empty.\n *\n * @template Element - The non-empty array member type.\n */\nexport type NonEmptyArray<Element> = [Element, ...Element[]];\n\n/**\n * A JavaScript object that is not `null`, a function, or an array.\n */\nexport type RuntimeObject = Record<PropertyKey, unknown>;\n\n//\n// Type Guards\n//\n\n/**\n * A {@link NonEmptyArray} type guard.\n *\n * @template Element - The non-empty array member type.\n * @param value - The value to check.\n * @returns Whether the value is a non-empty array.\n */\nexport function isNonEmptyArray<Element>(\n  value: Element[],\n): value is NonEmptyArray<Element> {\n  return Array.isArray(value) && value.length > 0;\n}\n\n/**\n * Type guard for \"nullishness\".\n *\n * @param value - Any value.\n * @returns `true` if the value is null or undefined, `false` otherwise.\n */\nexport function isNullOrUndefined(value: unknown): value is null | undefined {\n  return value === null || value === undefined;\n}\n\n/**\n * A type guard for {@link RuntimeObject}.\n *\n * @param value - The value to check.\n * @returns Whether the specified value has a runtime type of `object` and is\n * neither `null` nor an `Array`.\n */\nexport function isObject(value: unknown): value is RuntimeObject {\n  return Boolean(value) && typeof value === 'object' && !Array.isArray(value);\n}\n\n//\n// Other utility functions\n//\n\n/**\n * A type guard for ensuring an object has a property.\n *\n * @param objectToCheck - The object to check.\n * @param name - The property name to check for.\n * @returns Whether the specified object has an own property with the specified\n * name, regardless of whether it is enumerable or not.\n */\nexport const hasProperty = <\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  ObjectToCheck extends Object,\n  Property extends PropertyKey,\n>(\n  objectToCheck: ObjectToCheck,\n  name: Property,\n): objectToCheck is ObjectToCheck &\n  Record<\n    Property,\n    Property extends keyof ObjectToCheck ? ObjectToCheck[Property] : unknown\n  > => Object.hasOwnProperty.call(objectToCheck, name);\n\n/**\n * `Object.getOwnPropertyNames()` is intentionally generic: it returns the\n * immediate property names of an object, but it cannot make guarantees about\n * the contents of that object, so the type of the property names is merely\n * `string[]`. While this is technically accurate, it is also unnecessary if we\n * have an object with a type that we own (such as an enum).\n *\n * @param object - The plain object.\n * @returns The own property names of the object which are assigned a type\n * derived from the object itself.\n */\nexport function getKnownPropertyNames<Key extends PropertyKey>(\n  object: Partial<Record<Key, any>>,\n): Key[] {\n  return Object.getOwnPropertyNames(object) as Key[];\n}\n\nexport type PlainObject = Record<number | string | symbol, unknown>;\n\n/**\n * Predefined sizes (in Bytes) of specific parts of JSON structure.\n */\nexport enum JsonSize {\n  Null = 4,\n  Comma = 1,\n  Wrapper = 1,\n  True = 4,\n  False = 5,\n  Quote = 1,\n  Colon = 1,\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  Date = 24,\n}\n\n/**\n * Regular expression with pattern matching for (special) escaped characters.\n */\nexport const ESCAPE_CHARACTERS_REGEXP = /\"|\\\\|\\n|\\r|\\t/gu;\n\n/**\n * Check if the value is plain object.\n *\n * @param value - Value to be checked.\n * @returns True if an object is the plain JavaScript object,\n * false if the object is not plain (e.g. function).\n */\nexport function isPlainObject(value: unknown): value is PlainObject {\n  if (typeof value !== 'object' || value === null) {\n    return false;\n  }\n\n  try {\n    let proto = value;\n    while (Object.getPrototypeOf(proto) !== null) {\n      proto = Object.getPrototypeOf(proto);\n    }\n\n    return Object.getPrototypeOf(value) === proto;\n  } catch (_) {\n    return false;\n  }\n}\n\n/**\n * Check if character is ASCII.\n *\n * @param character - Character.\n * @returns True if a character code is ASCII, false if not.\n */\nexport function isASCII(character: string) {\n  return character.charCodeAt(0) <= 127;\n}\n\n/**\n * Calculate string size.\n *\n * @param value - String value to calculate size.\n * @returns Number of bytes used to store whole string value.\n */\nexport function calculateStringSize(value: string): number {\n  const size = value.split('').reduce((total, character) => {\n    if (isASCII(character)) {\n      return total + 1;\n    }\n    return total + 2;\n  }, 0);\n\n  // Also detect characters that need backslash escape\n  return size + (value.match(ESCAPE_CHARACTERS_REGEXP) ?? []).length;\n}\n\n/**\n * Calculate size of a number ofter JSON serialization.\n *\n * @param value - Number value to calculate size.\n * @returns Number of bytes used to store whole number in JSON.\n */\nexport function calculateNumberSize(value: number): number {\n  return value.toString().length;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 787, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/errors.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/errors.ts"],"sourcesContent":["import { ErrorWithCause } from 'pony-cause';\n\nimport { isNullOrUndefined, isObject } from './misc';\n\n/**\n * Type guard for determining whether the given value is an instance of Error.\n * For errors generated via `fs.promises`, `error instanceof Error` won't work,\n * so we have to come up with another way of testing.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isError(error: unknown): error is Error {\n  return (\n    error instanceof Error ||\n    (isObject(error) && error.constructor.name === 'Error')\n  );\n}\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `code` property such as the type of error that Node throws for filesystem\n * operations, etc.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nexport function isErrorWithCode(error: unknown): error is { code: string } {\n  return typeof error === 'object' && error !== null && 'code' in error;\n}\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `message` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nexport function isErrorWithMessage(\n  error: unknown,\n): error is { message: string } {\n  return typeof error === 'object' && error !== null && 'message' in error;\n}\n\n/**\n * Type guard for determining whether the given value is an error object with a\n * `stack` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nexport function isErrorWithStack(error: unknown): error is { stack: string } {\n  return typeof error === 'object' && error !== null && 'stack' in error;\n}\n\n/**\n * Attempts to obtain the message from a possible error object, defaulting to an\n * empty string if it is impossible to do so.\n *\n * @param error - The possible error to get the message from.\n * @returns The message if `error` is an object with a `message` property;\n * the string version of `error` if it is not `undefined` or `null`; otherwise\n * an empty string.\n */\nexport function getErrorMessage(error: unknown): string {\n  if (isErrorWithMessage(error) && typeof error.message === 'string') {\n    return error.message;\n  }\n\n  if (isNullOrUndefined(error)) {\n    return '';\n  }\n\n  return String(error);\n}\n\n/**\n * Builds a new error object, linking it to the original error via the `cause`\n * property if it is an Error.\n *\n * This function is useful to reframe error messages in general, but is\n * _critical_ when interacting with any of Node's filesystem functions as\n * provided via `fs.promises`, because these do not produce stack traces in the\n * case of an I/O error (see <https://github.com/nodejs/node/issues/30944>).\n *\n * @param originalError - The error to be wrapped (something throwable).\n * @param message - The desired message of the new error.\n * @returns A new error object.\n */\nexport function wrapError<Throwable>(\n  originalError: Throwable,\n  message: string,\n): Error & { code?: string } {\n  if (isError(originalError)) {\n    let error: Error & { code?: string };\n    if (Error.length === 2) {\n      // for some reason `tsserver` is not complaining that the\n      // Error constructor doesn't support a second argument in the editor,\n      // but `tsc` does. Error causes are not supported by our current tsc target (ES2020, we need ES2022 to make this work)\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      error = new Error(message, { cause: originalError });\n    } else {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      error = new ErrorWithCause(message, { cause: originalError });\n    }\n\n    if (isErrorWithCode(originalError)) {\n      error.code = originalError.code;\n    }\n\n    return error;\n  }\n\n  if (message.length > 0) {\n    return new Error(`${String(originalError)}: ${message}`);\n  }\n\n  return new Error(String(originalError));\n}\n"],"names":[],"mappings":";;;;AAAA,MAAA,qCAA4C;AAE5C,MAAA,+BAAqD;AAErD;;;;;;;GAOG,CACH,SAAS,OAAO,CAAC,KAAc;IAC7B,OAAO,AACL,KAAK,YAAY,KAAK,IACrB,CAAA,GAAA,OAAA,QAAQ,EAAC,KAAK,CAAC,IAAI,KAAK,CAAC,WAAW,CAAC,IAAI,KAAK,OAAO,CAAC,CACxD,CAAC;AACJ,CAAC;AAED;;;;;;;GAOG,CACH,SAAgB,eAAe,CAAC,KAAc;IAC5C,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,IAAI,IAAI,MAAM,IAAI,KAAK,CAAC;AACxE,CAAC;AAFD,QAAA,eAAA,GAAA,gBAEC;AAED;;;;;;GAMG,CACH,SAAgB,kBAAkB,CAChC,KAAc;IAEd,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,IAAI,IAAI,SAAS,IAAI,KAAK,CAAC;AAC3E,CAAC;AAJD,QAAA,kBAAA,GAAA,mBAIC;AAED;;;;;;GAMG,CACH,SAAgB,gBAAgB,CAAC,KAAc;IAC7C,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,KAAK,IAAI,IAAI,OAAO,IAAI,KAAK,CAAC;AACzE,CAAC;AAFD,QAAA,gBAAA,GAAA,iBAEC;AAED;;;;;;;;GAQG,CACH,SAAgB,eAAe,CAAC,KAAc;IAC5C,IAAI,kBAAkB,CAAC,KAAK,CAAC,IAAI,OAAO,KAAK,CAAC,OAAO,KAAK,QAAQ,EAAE;QAClE,OAAO,KAAK,CAAC,OAAO,CAAC;KACtB;IAED,IAAI,CAAA,GAAA,OAAA,iBAAiB,EAAC,KAAK,CAAC,EAAE;QAC5B,OAAO,EAAE,CAAC;KACX;IAED,OAAO,MAAM,CAAC,KAAK,CAAC,CAAC;AACvB,CAAC;AAVD,QAAA,eAAA,GAAA,gBAUC;AAED;;;;;;;;;;;;GAYG,CACH,SAAgB,SAAS,CACvB,aAAwB,EACxB,OAAe;IAEf,IAAI,OAAO,CAAC,aAAa,CAAC,EAAE;QAC1B,IAAI,KAAgC,CAAC;QACrC,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;YACtB,yDAAyD;YACzD,qEAAqE;YACrE,sHAAsH;YACtH,6DAA6D;YAC7D,aAAa;YACb,KAAK,GAAG,IAAI,KAAK,CAAC,OAAO,EAAE;gBAAE,KAAK,EAAE,aAAa;YAAA,CAAE,CAAC,CAAC;SACtD,MAAM;YACL,6DAA6D;YAC7D,aAAa;YACb,KAAK,GAAG,IAAI,aAAA,cAAc,CAAC,OAAO,EAAE;gBAAE,KAAK,EAAE,aAAa;YAAA,CAAE,CAAC,CAAC;SAC/D;QAED,IAAI,eAAe,CAAC,aAAa,CAAC,EAAE;YAClC,KAAK,CAAC,IAAI,GAAG,aAAa,CAAC,IAAI,CAAC;SACjC;QAED,OAAO,KAAK,CAAC;KACd;IAED,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;QACtB,OAAO,IAAI,KAAK,CAAC,GAAG,MAAM,CAAC,aAAa,CAAC,CAAA,EAAA,EAAK,OAAO,EAAE,CAAC,CAAC;KAC1D;IAED,OAAO,IAAI,KAAK,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,CAAC;AAC1C,CAAC;AA/BD,QAAA,SAAA,GAAA,UA+BC"}},
    {"offset": {"line": 898, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/assert.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/assert.ts"],"sourcesContent":["import type { Struct } from '@metamask/superstruct';\nimport { assert as assertSuperstruct } from '@metamask/superstruct';\n\nimport { getErrorMessage } from './errors';\n\nexport type AssertionErrorConstructor =\n  | (new (args: { message: string }) => Error)\n  | ((args: { message: string }) => Error);\n\n/**\n * Check if a value is a constructor, i.e., a function that can be called with\n * the `new` keyword.\n *\n * @param fn - The value to check.\n * @returns `true` if the value is a constructor, or `false` otherwise.\n */\nfunction isConstructable(\n  fn: AssertionErrorConstructor,\n): fn is new (args: { message: string }) => Error {\n  /* istanbul ignore next */\n  return Boolean(typeof fn?.prototype?.constructor?.name === 'string');\n}\n\n/**\n * Attempts to obtain the message from a possible error object. If it is\n * possible to do so, any trailing period will be removed from the message;\n * otherwise an empty string is returned.\n *\n * @param error - The error object to get the message from.\n * @returns The message without any trailing period if `error` is an object\n * with a `message` property; the string version of `error` without any trailing\n * period if it is not `undefined` or `null`; otherwise an empty string.\n */\nfunction getErrorMessageWithoutTrailingPeriod(error: unknown): string {\n  // We'll add our own period.\n  return getErrorMessage(error).replace(/\\.$/u, '');\n}\n\n/**\n * Initialise an {@link AssertionErrorConstructor} error.\n *\n * @param ErrorWrapper - The error class to use.\n * @param message - The error message.\n * @returns The error object.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction getError(ErrorWrapper: AssertionErrorConstructor, message: string) {\n  if (isConstructable(ErrorWrapper)) {\n    return new ErrorWrapper({\n      message,\n    });\n  }\n  return ErrorWrapper({\n    message,\n  });\n}\n\n/**\n * The default error class that is thrown if an assertion fails.\n */\nexport class AssertionError extends Error {\n  readonly code = 'ERR_ASSERTION';\n\n  constructor(options: { message: string }) {\n    super(options.message);\n  }\n}\n\n/**\n * Same as Node.js assert.\n * If the value is falsy, throws an error, does nothing otherwise.\n *\n * @throws {@link AssertionError} If value is falsy.\n * @param value - The test that should be truthy to pass.\n * @param message - Message to be passed to {@link AssertionError} or an\n * {@link Error} instance to throw.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}. If a custom error class is provided for\n * the `message` argument, this argument is ignored.\n */\nexport function assert(\n  value: any,\n  message: string | Error = 'Assertion failed.',\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper: AssertionErrorConstructor = AssertionError,\n): asserts value {\n  if (!value) {\n    if (message instanceof Error) {\n      throw message;\n    }\n\n    throw getError(ErrorWrapper, message);\n  }\n}\n\n/**\n * Assert a value against a Superstruct struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param errorPrefix - A prefix to add to the error message. Defaults to\n * \"Assertion failed\".\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the value is not valid.\n */\nexport function assertStruct<Type, Schema>(\n  value: unknown,\n  struct: Struct<Type, Schema>,\n  errorPrefix = 'Assertion failed',\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper: AssertionErrorConstructor = AssertionError,\n): asserts value is Type {\n  try {\n    assertSuperstruct(value, struct);\n  } catch (error) {\n    throw getError(\n      ErrorWrapper,\n      `${errorPrefix}: ${getErrorMessageWithoutTrailingPeriod(error)}.`,\n    );\n  }\n}\n\n/**\n * Use in the default case of a switch that you want to be fully exhaustive.\n * Using this function forces the compiler to enforce exhaustivity during\n * compile-time.\n *\n * @example\n * ```\n * const number = 1;\n * switch (number) {\n *   case 0:\n *     ...\n *   case 1:\n *     ...\n *   default:\n *     assertExhaustive(snapPrefix);\n * }\n * ```\n * @param _object - The object on which the switch is being operated.\n */\nexport function assertExhaustive(_object: never): never {\n  throw new Error(\n    'Invalid branch reached. Should be detected during compilation.',\n  );\n}\n"],"names":[],"mappings":";;;;AACA,MAAA,iDAAoE;AAEpE,MAAA,mCAA2C;AAM3C;;;;;;GAMG,CACH,SAAS,eAAe,CACtB,EAA6B;IAE7B,wBAAA,EAA0B,CAC1B,OAAO,OAAO,CAAC,OAAO,EAAE,EAAE,SAAS,EAAE,WAAW,EAAE,IAAI,KAAK,QAAQ,CAAC,CAAC;AACvE,CAAC;AAED;;;;;;;;;GASG,CACH,SAAS,oCAAoC,CAAC,KAAc;IAC1D,4BAA4B;IAC5B,OAAO,CAAA,GAAA,SAAA,eAAe,EAAC,KAAK,CAAC,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;AACpD,CAAC;AAED;;;;;;GAMG,CACH,gEAAgE;AAChE,SAAS,QAAQ,CAAC,YAAuC,EAAE,OAAe;IACxE,IAAI,eAAe,CAAC,YAAY,CAAC,EAAE;QACjC,OAAO,IAAI,YAAY,CAAC;YACtB,OAAO;SACR,CAAC,CAAC;KACJ;IACD,OAAO,YAAY,CAAC;QAClB,OAAO;KACR,CAAC,CAAC;AACL,CAAC;AAED;;GAEG,CACH,MAAa,cAAe,SAAQ,KAAK;IAGvC,YAAY,OAA4B,CAAA;QACtC,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;QAHhB,IAAA,CAAA,IAAI,GAAG,eAAe,CAAC;IAIhC,CAAC;CACF;AAND,QAAA,cAAA,GAAA,eAMC;AAED;;;;;;;;;;;GAWG,CACH,SAAgB,MAAM,CACpB,KAAU,EACV,UAA0B,mBAAmB,EAC7C,gEAAgE;AAChE,eAA0C,cAAc;IAExD,IAAI,CAAC,KAAK,EAAE;QACV,IAAI,OAAO,YAAY,KAAK,EAAE;YAC5B,MAAM,OAAO,CAAC;SACf;QAED,MAAM,QAAQ,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;KACvC;AACH,CAAC;AAbD,QAAA,MAAA,GAAA,OAaC;AAED;;;;;;;;;;GAUG,CACH,SAAgB,YAAY,CAC1B,KAAc,EACd,MAA4B,EAC5B,WAAW,GAAG,kBAAkB,EAChC,gEAAgE;AAChE,eAA0C,cAAc;IAExD,IAAI;QACF,CAAA,GAAA,cAAA,MAAiB,EAAC,KAAK,EAAE,MAAM,CAAC,CAAC;KAClC,CAAC,OAAO,KAAK,EAAE;QACd,MAAM,QAAQ,CACZ,YAAY,EACZ,GAAG,WAAW,CAAA,EAAA,EAAK,oCAAoC,CAAC,KAAK,CAAC,CAAA,CAAA,CAAG,CAClE,CAAC;KACH;AACH,CAAC;AAfD,QAAA,YAAA,GAAA,aAeC;AAED;;;;;;;;;;;;;;;;;;GAkBG,CACH,SAAgB,gBAAgB,CAAC,OAAc;IAC7C,MAAM,IAAI,KAAK,CACb,gEAAgE,CACjE,CAAC;AACJ,CAAC;AAJD,QAAA,gBAAA,GAAA,iBAIC"}},
    {"offset": {"line": 1018, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/base64.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/base64.ts"],"sourcesContent":["import type { Struct } from '@metamask/superstruct';\nimport { pattern } from '@metamask/superstruct';\n\nimport { assert } from './assert';\n\nexport type Base64Options = {\n  /**\n   * Is the `=` padding at the end required or not.\n   *\n   * @default false\n   */\n  // Padding is optional in RFC 4648, that's why the default value is false\n  paddingRequired?: boolean;\n  /**\n   * Which character set should be used.\n   * The sets are based on {@link https://datatracker.ietf.org/doc/html/rfc4648 RFC 4648}.\n   *\n   * @default 'base64'\n   */\n  characterSet?: 'base64' | 'base64url';\n};\n\n/**\n * Ensure that a provided string-based struct is valid base64.\n *\n * @param struct - The string based struct.\n * @param options - Optional options to specialize base64 validation. See {@link Base64Options} documentation.\n * @returns A superstruct validating base64.\n */\nexport const base64 = <Type extends string, Schema>(\n  struct: Struct<Type, Schema>,\n  options: Base64Options = {},\n) => {\n  const paddingRequired = options.paddingRequired ?? false;\n  const characterSet = options.characterSet ?? 'base64';\n\n  let letters: string;\n  if (characterSet === 'base64') {\n    letters = String.raw`[A-Za-z0-9+\\/]`;\n  } else {\n    assert(characterSet === 'base64url');\n    letters = String.raw`[-_A-Za-z0-9]`;\n  }\n\n  let re: RegExp;\n  if (paddingRequired) {\n    re = new RegExp(\n      `^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`,\n      'u',\n    );\n  } else {\n    re = new RegExp(\n      `^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`,\n      'u',\n    );\n  }\n\n  return pattern(struct, re);\n};\n"],"names":[],"mappings":";;;;AACA,MAAA,iDAAgD;AAEhD,MAAA,mCAAkC;AAmBlC;;;;;;GAMG,CACI,MAAM,MAAM,GAAG,CACpB,MAA4B,EAC5B,UAAyB,CAAA,CAAE,EAC3B,EAAE;IACF,MAAM,eAAe,GAAG,OAAO,CAAC,eAAe,IAAI,KAAK,CAAC;IACzD,MAAM,YAAY,GAAG,OAAO,CAAC,YAAY,IAAI,QAAQ,CAAC;IAEtD,IAAI,OAAe,CAAC;IACpB,IAAI,YAAY,KAAK,QAAQ,EAAE;QAC7B,OAAO,GAAG,MAAM,CAAC,GAAG,CAAA,cAAA,CAAgB,CAAC;KACtC,MAAM;QACL,CAAA,GAAA,SAAA,MAAM,EAAC,YAAY,KAAK,WAAW,CAAC,CAAC;QACrC,OAAO,GAAG,MAAM,CAAC,GAAG,CAAA,aAAA,CAAe,CAAC;KACrC;IAED,IAAI,EAAU,CAAC;IACf,IAAI,eAAe,EAAE;QACnB,EAAE,GAAG,IAAI,MAAM,CACb,CAAA,IAAA,EAAO,OAAO,CAAA,QAAA,EAAW,OAAO,CAAA,KAAA,EAAQ,OAAO,CAAA,QAAA,CAAU,EACzD,GAAG,CACJ,CAAC;KACH,MAAM;QACL,EAAE,GAAG,IAAI,MAAM,CACb,CAAA,IAAA,EAAO,OAAO,CAAA,QAAA,EAAW,OAAO,CAAA,MAAA,EAAS,OAAO,CAAA,KAAA,EAAQ,OAAO,CAAA,QAAA,CAAU,EACzE,GAAG,CACJ,CAAC;KACH;IAED,OAAO,CAAA,GAAA,cAAA,OAAO,EAAC,MAAM,EAAE,EAAE,CAAC,CAAC;AAC7B,CAAC,CAAC;AA7BW,QAAA,MAAM,GAAA,OA6BjB"}},
    {"offset": {"line": 1053, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/hex.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/hex.ts"],"sourcesContent":["import { pattern, type Struct, string } from '@metamask/superstruct';\nimport { keccak_256 as keccak256 } from '@noble/hashes/sha3';\nimport { memoize } from 'lodash';\n\nimport { assert } from './assert';\n\nexport type Hex = `0x${string}`;\n\n// Use native regexes instead of superstruct for maximum performance.\n// Pre-compiled regex for maximum performance - avoids recompilation on each call\nconst HEX_REGEX = /^(?:0x)?[0-9a-f]+$/iu;\nconst STRICT_HEX_REGEX = /^0x[0-9a-f]+$/iu;\nconst HEX_ADDRESS_REGEX = /^0x[0-9a-f]{40}$/u;\nconst HEX_CHECKSUM_ADDRESS_REGEX = /^0x[0-9a-fA-F]{40}$/u;\n\nexport const HexStruct = pattern(string(), HEX_REGEX);\nexport const StrictHexStruct = pattern(string(), STRICT_HEX_REGEX) as Struct<\n  Hex,\n  null\n>;\nexport const HexAddressStruct = pattern(string(), HEX_ADDRESS_REGEX) as Struct<\n  Hex,\n  null\n>;\nexport const HexChecksumAddressStruct = pattern(\n  string(),\n  HEX_CHECKSUM_ADDRESS_REGEX,\n) as Struct<Hex, null>;\n\nconst isString = (value: unknown): value is string => typeof value === 'string';\n\n/**\n * Check if a string is a valid hex string.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nexport function isHexString(value: unknown): value is string {\n  return isString(value) && HEX_REGEX.test(value);\n}\n\n/**\n * Strictly check if a string is a valid hex string. A valid hex string must\n * start with the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nexport function isStrictHexString(value: unknown): value is Hex {\n  return isString(value) && STRICT_HEX_REGEX.test(value);\n}\n\n/**\n * Check if a string is a valid hex address.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex address.\n */\nexport function isHexAddress(value: unknown): value is Hex {\n  return isString(value) && HEX_ADDRESS_REGEX.test(value);\n}\n\n/**\n * Check if a string is a valid hex checksum address.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex checksum address.\n */\nexport function isHexChecksumAddress(value: unknown): value is Hex {\n  return isString(value) && HEX_CHECKSUM_ADDRESS_REGEX.test(value);\n}\n\n/**\n * Assert that a value is a valid hex string.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nexport function assertIsHexString(value: unknown): asserts value is string {\n  assert(isHexString(value), 'Value must be a hexadecimal string.');\n}\n\n/**\n * Assert that a value is a valid hex string. A valid hex string must start with\n * the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nexport function assertIsStrictHexString(value: unknown): asserts value is Hex {\n  assert(\n    isStrictHexString(value),\n    'Value must be a hexadecimal string, starting with \"0x\".',\n  );\n}\n\n/**\n * Encode a passed hex string as an ERC-55 mixed-case checksum address.\n * This is the unmemoized version, primarily used for testing.\n *\n * @param hexAddress - The hex address to encode.\n * @returns The address encoded according to ERC-55.\n * @see https://eips.ethereum.org/EIPS/eip-55\n */\nexport function getChecksumAddressUnmemoized(hexAddress: Hex): Hex {\n  assert(isHexChecksumAddress(hexAddress), 'Invalid hex address.');\n  const address = remove0x(hexAddress).toLowerCase();\n\n  const hashBytes = keccak256(address);\n  const { length } = address;\n  const result = new Array(length); // Pre-allocate array\n\n  for (let i = 0; i < length; i++) {\n    /* eslint-disable no-bitwise */\n    const byteIndex = i >> 1; // Faster than Math.floor(i / 2)\n    const nibbleIndex = i & 1; // Faster than i % 2\n    const byte = hashBytes[byteIndex] as number;\n    const nibble = nibbleIndex === 0 ? byte >> 4 : byte & 0x0f;\n    /* eslint-enable no-bitwise */\n\n    result[i] = nibble >= 8 ? (address[i] as string).toUpperCase() : address[i];\n  }\n\n  return `0x${result.join('')}`;\n}\n\n/**\n * Encode a passed hex string as an ERC-55 mixed-case checksum address.\n * This function is memoized for performance.\n *\n * @param hexAddress - The hex address to encode.\n * @returns The address encoded according to ERC-55.\n * @see https://eips.ethereum.org/EIPS/eip-55\n */\nexport const getChecksumAddress = memoize(getChecksumAddressUnmemoized);\n\n/**\n * Validate that the passed hex string is a valid ERC-55 mixed-case\n * checksum address.\n *\n * @param possibleChecksum - The hex address to check.\n * @returns True if the address is a checksum address.\n */\nexport function isValidChecksumAddressUnmemoized(possibleChecksum: Hex) {\n  if (!isHexChecksumAddress(possibleChecksum)) {\n    return false;\n  }\n\n  return getChecksumAddress(possibleChecksum) === possibleChecksum;\n}\n\n/**\n * Validate that the passed hex string is a valid ERC-55 mixed-case\n * checksum address.\n *\n * @param possibleChecksum - The hex address to check.\n * @returns True if the address is a checksum address.\n */\nexport const isValidChecksumAddress = memoize(isValidChecksumAddressUnmemoized);\n\n/**\n * Validate that the passed prefixed hex string is an all-lowercase\n * hex address, or a valid mixed-case checksum address.\n *\n * @param possibleAddress - Input parameter to check against.\n * @returns Whether or not the input is a valid hex address.\n */\nexport function isValidHexAddressUnmemoized(possibleAddress: Hex) {\n  return (\n    isHexAddress(possibleAddress) || isValidChecksumAddress(possibleAddress)\n  );\n}\n\n/**\n * Validate that the passed prefixed hex string is an all-lowercase\n * hex address, or a valid mixed-case checksum address.\n *\n * @param possibleAddress - Input parameter to check against.\n * @returns Whether or not the input is a valid hex address.\n */\nexport const isValidHexAddress = memoize(isValidHexAddressUnmemoized);\n\n/**\n * Add the `0x`-prefix to a hexadecimal string. If the string already has the\n * prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to add the prefix to.\n * @returns The prefixed hexadecimal string.\n */\nexport function add0x(hexadecimal: string): Hex {\n  if (hexadecimal.startsWith('0x')) {\n    return hexadecimal as Hex;\n  }\n\n  if (hexadecimal.startsWith('0X')) {\n    return `0x${hexadecimal.substring(2)}`;\n  }\n\n  return `0x${hexadecimal}`;\n}\n\n/**\n * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have\n * the prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to remove the prefix from.\n * @returns The un-prefixed hexadecimal string.\n */\nexport function remove0x(hexadecimal: string): string {\n  if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {\n    return hexadecimal.substring(2);\n  }\n\n  return hexadecimal;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1229, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/bytes.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/bytes.ts"],"sourcesContent":["import { base64 } from '@scure/base';\n\nimport { assert } from './assert';\nimport type { Hex } from './hex';\nimport { add0x, assertIsHexString, remove0x } from './hex';\n\n// '0'.charCodeAt(0) === 48\nconst HEX_MINIMUM_NUMBER_CHARACTER = 48;\n\n// '9'.charCodeAt(0) === 57\nconst HEX_MAXIMUM_NUMBER_CHARACTER = 58;\nconst HEX_CHARACTER_OFFSET = 87;\n\nexport type Bytes = bigint | number | string | Uint8Array;\n\n/**\n * Memoized function that returns an array to be used as a lookup table for\n * converting bytes to hexadecimal values.\n *\n * The array is created lazily and then cached for future use. The benefit of\n * this approach is that the performance of converting bytes to hex is much\n * better than if we were to call `toString(16)` on each byte.\n *\n * The downside is that the array is created once and then never garbage\n * collected. This is not a problem in practice because the array is only 256\n * elements long.\n *\n * @returns A function that returns the lookup table.\n */\nfunction getPrecomputedHexValuesBuilder(): () => string[] {\n  // To avoid issues with tree shaking, we need to use a function to return the\n  // array. This is because the array is only used in the `bytesToHex` function\n  // and if we were to use a global variable, the array might be removed by the\n  // tree shaker.\n  const lookupTable: string[] = [];\n\n  return () => {\n    if (lookupTable.length === 0) {\n      for (let i = 0; i < 256; i++) {\n        lookupTable.push(i.toString(16).padStart(2, '0'));\n      }\n    }\n\n    return lookupTable;\n  };\n}\n\n/**\n * Function implementation of the {@link getPrecomputedHexValuesBuilder}\n * function.\n */\nconst getPrecomputedHexValues = getPrecomputedHexValuesBuilder();\n\n/**\n * Check if a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @returns Whether the value is a `Uint8Array`.\n */\nexport function isBytes(value: unknown): value is Uint8Array {\n  return value instanceof Uint8Array;\n}\n\n/**\n * Assert that a value is a `Uint8Array`.\n *\n * @param value - The value to check.\n * @throws If the value is not a `Uint8Array`.\n */\nexport function assertIsBytes(value: unknown): asserts value is Uint8Array {\n  assert(isBytes(value), 'Value must be a Uint8Array.');\n}\n\n/**\n * Convert a `Uint8Array` to a hexadecimal string.\n *\n * @param bytes - The bytes to convert to a hexadecimal string.\n * @returns The hexadecimal string.\n */\nexport function bytesToHex(bytes: Uint8Array): Hex {\n  assertIsBytes(bytes);\n\n  if (bytes.length === 0) {\n    return '0x';\n  }\n\n  const lookupTable = getPrecomputedHexValues();\n  const hexadecimal = new Array(bytes.length);\n\n  for (let i = 0; i < bytes.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    hexadecimal[i] = lookupTable[bytes[i]!];\n  }\n\n  return add0x(hexadecimal.join(''));\n}\n\n/**\n * Convert a `Uint8Array` to a `bigint`.\n *\n * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.\n * To convert a two's complement encoded `Uint8Array` to a `bigint`, use\n * {@link bytesToSignedBigInt}.\n *\n * @param bytes - The bytes to convert to a `bigint`.\n * @returns The `bigint`.\n */\nexport function bytesToBigInt(bytes: Uint8Array): bigint {\n  assertIsBytes(bytes);\n\n  const hexadecimal = bytesToHex(bytes);\n  return BigInt(hexadecimal);\n}\n\n/**\n * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are\n * encoded in two's complement.\n *\n * To convert a `Uint8Array` to an unsigned `bigint` instead, use\n * {@link bytesToBigInt}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param bytes - The bytes to convert to a signed `bigint`.\n * @returns The signed `bigint`.\n */\nexport function bytesToSignedBigInt(bytes: Uint8Array): bigint {\n  assertIsBytes(bytes);\n\n  let value = BigInt(0);\n  for (const byte of bytes) {\n    // eslint-disable-next-line no-bitwise\n    value = (value << BigInt(8)) + BigInt(byte);\n  }\n\n  return BigInt.asIntN(bytes.length * 8, value);\n}\n\n/**\n * Convert a `Uint8Array` to a `number`.\n *\n * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.\n *\n * @param bytes - The bytes to convert to a number.\n * @returns The number.\n * @throws If the resulting number is not a safe integer.\n */\nexport function bytesToNumber(bytes: Uint8Array): number {\n  assertIsBytes(bytes);\n\n  const bigint = bytesToBigInt(bytes);\n\n  assert(\n    bigint <= BigInt(Number.MAX_SAFE_INTEGER),\n    'Number is not a safe integer. Use `bytesToBigInt` instead.',\n  );\n\n  return Number(bigint);\n}\n\n/**\n * Convert a UTF-8 encoded `Uint8Array` to a `string`.\n *\n * @param bytes - The bytes to convert to a string.\n * @returns The string.\n */\nexport function bytesToString(bytes: Uint8Array): string {\n  assertIsBytes(bytes);\n\n  return new TextDecoder().decode(bytes);\n}\n\n/**\n * Convert a `Uint8Array` to a base64 encoded string.\n *\n * @param bytes - The bytes to convert to a base64 encoded string.\n * @returns The base64 encoded string.\n */\nexport function bytesToBase64(bytes: Uint8Array): string {\n  assertIsBytes(bytes);\n\n  return base64.encode(bytes);\n}\n\n/**\n * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be\n * prefixed with `0x`. It accepts even and odd length strings.\n *\n * If the value is \"0x\", an empty `Uint8Array` is returned.\n *\n * @param value - The hexadecimal string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function hexToBytes(value: string): Uint8Array {\n  // \"0x\" is often used as empty byte array.\n  if (value?.toLowerCase?.() === '0x') {\n    return new Uint8Array();\n  }\n\n  assertIsHexString(value);\n\n  // Remove the `0x` prefix if it exists, and pad the string to have an even\n  // number of characters.\n  const strippedValue = remove0x(value).toLowerCase();\n  const normalizedValue =\n    strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;\n  const bytes = new Uint8Array(normalizedValue.length / 2);\n\n  for (let i = 0; i < bytes.length; i++) {\n    // While this is not the prettiest way to convert a hexadecimal string to a\n    // `Uint8Array`, it is a lot faster than using `parseInt` to convert each\n    // character.\n    const c1 = normalizedValue.charCodeAt(i * 2);\n    const c2 = normalizedValue.charCodeAt(i * 2 + 1);\n    const n1 =\n      c1 -\n      (c1 < HEX_MAXIMUM_NUMBER_CHARACTER\n        ? HEX_MINIMUM_NUMBER_CHARACTER\n        : HEX_CHARACTER_OFFSET);\n    const n2 =\n      c2 -\n      (c2 < HEX_MAXIMUM_NUMBER_CHARACTER\n        ? HEX_MINIMUM_NUMBER_CHARACTER\n        : HEX_CHARACTER_OFFSET);\n\n    bytes[i] = n1 * 16 + n2;\n  }\n\n  return bytes;\n}\n\n/**\n * Convert a `bigint` to a `Uint8Array`.\n *\n * This assumes that the `bigint` is an unsigned integer. To convert a signed\n * `bigint` instead, use {@link signedBigIntToBytes}.\n *\n * @param value - The bigint to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function bigIntToBytes(value: bigint): Uint8Array {\n  assert(typeof value === 'bigint', 'Value must be a bigint.');\n  assert(value >= BigInt(0), 'Value must be a non-negative bigint.');\n\n  const hexadecimal = value.toString(16);\n  return hexToBytes(hexadecimal);\n}\n\n/**\n * Check if a `bigint` fits in a certain number of bytes.\n *\n * @param value - The `bigint` to check.\n * @param bytes - The number of bytes.\n * @returns Whether the `bigint` fits in the number of bytes.\n */\nfunction bigIntFits(value: bigint, bytes: number): boolean {\n  assert(bytes > 0);\n\n  /* eslint-disable no-bitwise */\n  const mask = value >> BigInt(31);\n  return !(((~value & mask) + (value & ~mask)) >> BigInt(bytes * 8 + ~0));\n  /* eslint-enable no-bitwise */\n}\n\n/**\n * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement\n * encoding to represent negative numbers.\n *\n * To convert an unsigned `bigint` to a `Uint8Array` instead, use\n * {@link bigIntToBytes}.\n *\n * @see https://en.wikipedia.org/wiki/Two%27s_complement\n * @param value - The number to convert to bytes.\n * @param byteLength - The length of the resulting `Uint8Array`. If the number\n * is larger than the maximum value that can be represented by the given length,\n * an error is thrown.\n * @returns The bytes as `Uint8Array`.\n */\nexport function signedBigIntToBytes(\n  value: bigint,\n  byteLength: number,\n): Uint8Array {\n  assert(typeof value === 'bigint', 'Value must be a bigint.');\n  assert(typeof byteLength === 'number', 'Byte length must be a number.');\n  assert(byteLength > 0, 'Byte length must be greater than 0.');\n  assert(\n    bigIntFits(value, byteLength),\n    'Byte length is too small to represent the given value.',\n  );\n\n  // ESLint doesn't like mutating function parameters, so to avoid having to\n  // disable the rule, we create a new variable.\n  let numberValue = value;\n  const bytes = new Uint8Array(byteLength);\n\n  for (let i = 0; i < bytes.length; i++) {\n    bytes[i] = Number(BigInt.asUintN(8, numberValue));\n    // eslint-disable-next-line no-bitwise\n    numberValue >>= BigInt(8);\n  }\n\n  return bytes.reverse();\n}\n\n/**\n * Convert a `number` to a `Uint8Array`.\n *\n * @param value - The number to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n * @throws If the number is not a safe integer.\n */\nexport function numberToBytes(value: number): Uint8Array {\n  assert(typeof value === 'number', 'Value must be a number.');\n  assert(value >= 0, 'Value must be a non-negative number.');\n  assert(\n    Number.isSafeInteger(value),\n    'Value is not a safe integer. Use `bigIntToBytes` instead.',\n  );\n\n  const hexadecimal = value.toString(16);\n  return hexToBytes(hexadecimal);\n}\n\n/**\n * Convert a `string` to a UTF-8 encoded `Uint8Array`.\n *\n * @param value - The string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function stringToBytes(value: string): Uint8Array {\n  assert(typeof value === 'string', 'Value must be a string.');\n\n  return new TextEncoder().encode(value);\n}\n\n/**\n * Convert a base64 encoded string to a `Uint8Array`.\n *\n * @param value - The base64 encoded string to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function base64ToBytes(value: string): Uint8Array {\n  assert(typeof value === 'string', 'Value must be a string.');\n\n  return base64.decode(value);\n}\n\n/**\n * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,\n * a `bigint`, a `number`, or a `string`.\n *\n * This will attempt to guess the type of the value based on its type and\n * contents. For more control over the conversion, use the more specific\n * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.\n *\n * If the value is a `string`, and it is prefixed with `0x`, it will be\n * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a\n * UTF-8 string. To convert a hexadecimal string to bytes without interpreting\n * it as a UTF-8 string, use {@link hexToBytes} instead.\n *\n * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed\n * `bigint` to bytes, use {@link signedBigIntToBytes} instead.\n *\n * If the value is a `Uint8Array`, it will be returned as-is.\n *\n * @param value - The value to convert to bytes.\n * @returns The bytes as `Uint8Array`.\n */\nexport function valueToBytes(value: Bytes): Uint8Array {\n  if (typeof value === 'bigint') {\n    return bigIntToBytes(value);\n  }\n\n  if (typeof value === 'number') {\n    return numberToBytes(value);\n  }\n\n  if (typeof value === 'string') {\n    if (value.startsWith('0x')) {\n      return hexToBytes(value);\n    }\n\n    return stringToBytes(value);\n  }\n\n  if (isBytes(value)) {\n    return value;\n  }\n\n  throw new TypeError(`Unsupported value type: \"${typeof value}\".`);\n}\n\n/**\n * Concatenate multiple byte-like values into a single `Uint8Array`. The values\n * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses\n * {@link valueToBytes} under the hood to convert each value to bytes. Refer to\n * the documentation of that function for more information.\n *\n * @param values - The values to concatenate.\n * @returns The concatenated bytes as `Uint8Array`.\n */\nexport function concatBytes(values: Bytes[]): Uint8Array {\n  const normalizedValues = new Array(values.length);\n  let byteLength = 0;\n\n  for (let i = 0; i < values.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const value = valueToBytes(values[i]!);\n\n    normalizedValues[i] = value;\n    byteLength += value.length;\n  }\n\n  const bytes = new Uint8Array(byteLength);\n  for (let i = 0, offset = 0; i < normalizedValues.length; i++) {\n    // While we could simply spread the values into an array and use\n    // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.\n    bytes.set(normalizedValues[i], offset);\n    offset += normalizedValues[i].length;\n  }\n\n  return bytes;\n}\n\n/**\n * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience\n * function that avoids having to create a {@link DataView} manually, which\n * requires passing the `byteOffset` and `byteLength` parameters every time.\n *\n * Not passing the `byteOffset` and `byteLength` parameters can result in\n * unexpected behavior when the {@link Uint8Array} is a view of a larger\n * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.\n *\n * This function also supports Node.js {@link Buffer}s.\n *\n * @example\n * ```typescript\n * const bytes = new Uint8Array([1, 2, 3]);\n *\n * // This is equivalent to:\n * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n * const dataView = createDataView(bytes);\n * ```\n * @param bytes - The bytes to create the {@link DataView} from.\n * @returns The {@link DataView}.\n */\nexport function createDataView(bytes: Uint8Array): DataView {\n  // To maintain compatibility with Node.js, we need to check if the bytes are\n  // a Buffer. If so, we need to slice the buffer to get the underlying\n  // ArrayBuffer.\n  // eslint-disable-next-line no-restricted-globals\n  if (typeof Buffer !== 'undefined' && bytes instanceof Buffer) {\n    const buffer = bytes.buffer.slice(\n      bytes.byteOffset,\n      bytes.byteOffset + bytes.byteLength,\n    );\n\n    return new DataView(buffer);\n  }\n\n  return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n}\n\n/**\n * Compare two Uint8Arrays using a constant-time style loop to reduce timing\n * side-channels when comparing sensitive data (e.g., mnemonic bytes, keys,\n * authentication tags). Does not early-return on the first difference:\n * work done depends only on the input lengths, so byte content does not affect timing.\n *\n * When to use:\n * - Use for secret or security-sensitive byte comparisons to avoid content-based timing leaks.\n * - Prefer when inputs are fixed-length (or validated to equal length) at the API boundary.\n *\n * @param a - The first Uint8Array to compare.\n * @param b - The second Uint8Array to compare.\n * @returns Whether the Uint8Arrays are equal.\n */\nexport function areUint8ArraysEqual(a: Uint8Array, b: Uint8Array): boolean {\n  // eslint-disable-next-line no-bitwise\n  let diff = a.byteLength ^ b.byteLength;\n  const len = Math.max(a.byteLength, b.byteLength);\n\n  for (let i = 0; i < len; i++) {\n    const aByte = a[i] ?? 0;\n    const bByte = b[i] ?? 0;\n    // eslint-disable-next-line no-bitwise\n    diff |= aByte ^ bByte;\n  }\n\n  return diff === 0;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1631, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/superstruct.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/superstruct.ts"],"sourcesContent":["import type { Struct } from '@metamask/superstruct';\nimport { define } from '@metamask/superstruct';\n\n/**\n * Defines a new string-struct matching a regular expression.\n *\n * @example\n * const EthAddressStruct = definePattern('EthAddress', /^0x[0-9a-f]{40}$/iu);\n * type EthAddress = Infer<typeof EthAddressStruct>; // string\n *\n * const CaipChainIdStruct = defineTypedPattern<`${string}:${string}`>(\n *   'CaipChainId',\n *   /^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$/u;\n * );\n * type CaipChainId = Infer<typeof CaipChainIdStruct>; // `${string}:${string}`\n * @param name - Type name.\n * @param pattern - Regular expression to match.\n * @template Pattern - The pattern type, defaults to `string`.\n * @returns A new string-struct that matches the given pattern.\n */\nexport function definePattern<Pattern extends string = string>(\n  name: string,\n  pattern: RegExp,\n): Struct<Pattern, null> {\n  return define<Pattern>(name, (value: unknown): boolean | string => {\n    return typeof value === 'string' && pattern.test(value);\n  });\n}\n"],"names":[],"mappings":";;;;AACA,MAAA,iDAA+C;AAE/C;;;;;;;;;;;;;;;;GAgBG,CACH,SAAgB,aAAa,CAC3B,IAAY,EACZ,OAAe;IAEf,OAAO,CAAA,GAAA,cAAA,MAAM,EAAU,IAAI,EAAE,CAAC,KAAc,EAAoB,EAAE;QAChE,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAC1D,CAAC,CAAC,CAAC;AACL,CAAC;AAPD,QAAA,aAAA,GAAA,cAOC"}},
    {"offset": {"line": 1662, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/caip-types.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/caip-types.ts"],"sourcesContent":["import type { Infer } from '@metamask/superstruct';\n\nimport { definePattern } from './superstruct';\n\nexport const CAIP_CHAIN_ID_REGEX =\n  /^(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})$/u;\n\nexport const CAIP_NAMESPACE_REGEX = /^[-a-z0-9]{3,8}$/u;\n\nexport const CAIP_REFERENCE_REGEX = /^[-_a-zA-Z0-9]{1,32}$/u;\n\nexport const CAIP_ACCOUNT_ID_REGEX =\n  /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})):(?<accountAddress>[-.%a-zA-Z0-9]{1,128})$/u;\n\nexport const CAIP_ACCOUNT_ADDRESS_REGEX = /^[-.%a-zA-Z0-9]{1,128}$/u;\n\nexport const CAIP_ASSET_NAMESPACE_REGEX = /^[-a-z0-9]{3,8}$/u;\n\nexport const CAIP_ASSET_REFERENCE_REGEX = /^[-.%a-zA-Z0-9]{1,128}$/u;\n\nexport const CAIP_TOKEN_ID_REGEX = /^[-.%a-zA-Z0-9]{1,78}$/u;\n\nexport const CAIP_ASSET_TYPE_REGEX =\n  /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32}))\\/(?<assetNamespace>[-a-z0-9]{3,8}):(?<assetReference>[-.%a-zA-Z0-9]{1,128})$/u;\n\nexport const CAIP_ASSET_ID_REGEX =\n  /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32}))\\/(?<assetNamespace>[-a-z0-9]{3,8}):(?<assetReference>[-.%a-zA-Z0-9]{1,128})\\/(?<tokenId>[-.%a-zA-Z0-9]{1,78})$/u;\n\nconst CAIP_ASSET_TYPE_OR_ID_REGEX =\n  /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32}))\\/(?<assetNamespace>[-a-z0-9]{3,8}):(?<assetReference>[-.%a-zA-Z0-9]{1,128})(\\/(?<tokenId>[-.%a-zA-Z0-9]{1,78}))?$/u;\n\n/**\n * A CAIP-2 chain ID, i.e., a human-readable namespace and reference.\n */\nexport const CaipChainIdStruct = definePattern<`${string}:${string}`>(\n  'CaipChainId',\n  CAIP_CHAIN_ID_REGEX,\n);\nexport type CaipChainId = Infer<typeof CaipChainIdStruct>;\n\n/**\n * A CAIP-2 namespace, i.e., the first part of a CAIP chain ID.\n */\nexport const CaipNamespaceStruct = definePattern(\n  'CaipNamespace',\n  CAIP_NAMESPACE_REGEX,\n);\nexport type CaipNamespace = Infer<typeof CaipNamespaceStruct>;\n\n/**\n * A CAIP-2 reference, i.e., the second part of a CAIP chain ID.\n */\nexport const CaipReferenceStruct = definePattern(\n  'CaipReference',\n  CAIP_REFERENCE_REGEX,\n);\nexport type CaipReference = Infer<typeof CaipReferenceStruct>;\n\n/**\n * A CAIP-10 account ID, i.e., a human-readable namespace, reference, and account address.\n */\nexport const CaipAccountIdStruct =\n  definePattern<`${string}:${string}:${string}`>(\n    'CaipAccountId',\n    CAIP_ACCOUNT_ID_REGEX,\n  );\nexport type CaipAccountId = Infer<typeof CaipAccountIdStruct>;\n\n/**\n * A CAIP-10 account address, i.e., the third part of the CAIP account ID.\n */\nexport const CaipAccountAddressStruct = definePattern(\n  'CaipAccountAddress',\n  CAIP_ACCOUNT_ADDRESS_REGEX,\n);\nexport type CaipAccountAddress = Infer<typeof CaipAccountAddressStruct>;\n\n/**\n * A CAIP-19 asset namespace, i.e., a namespace domain of an asset.\n */\nexport const CaipAssetNamespaceStruct = definePattern(\n  'CaipAssetNamespace',\n  CAIP_ASSET_NAMESPACE_REGEX,\n);\nexport type CaipAssetNamespace = Infer<typeof CaipAssetNamespaceStruct>;\n\n/**\n * A CAIP-19 asset reference, i.e., an identifier for an asset within a given namespace.\n */\nexport const CaipAssetReferenceStruct = definePattern(\n  'CaipAssetReference',\n  CAIP_ASSET_REFERENCE_REGEX,\n);\nexport type CaipAssetReference = Infer<typeof CaipAssetReferenceStruct>;\n\n/**\n * A CAIP-19 asset token ID, i.e., a unique identifier for an addressable asset of a given type\n */\nexport const CaipTokenIdStruct = definePattern(\n  'CaipTokenId',\n  CAIP_TOKEN_ID_REGEX,\n);\nexport type CaipTokenId = Infer<typeof CaipTokenIdStruct>;\n\n/**\n * A CAIP-19 asset type identifier, i.e., a human-readable type of asset identifier.\n */\nexport const CaipAssetTypeStruct =\n  definePattern<`${string}:${string}/${string}:${string}`>(\n    'CaipAssetType',\n    CAIP_ASSET_TYPE_REGEX,\n  );\nexport type CaipAssetType = Infer<typeof CaipAssetTypeStruct>;\n\n/**\n * A CAIP-19 asset ID identifier, i.e., a human-readable type of asset ID.\n */\nexport const CaipAssetIdStruct =\n  definePattern<`${string}:${string}/${string}:${string}/${string}`>(\n    'CaipAssetId',\n    CAIP_ASSET_ID_REGEX,\n  );\nexport type CaipAssetId = Infer<typeof CaipAssetIdStruct>;\n\n/**\n * A CAIP-19 asset type or asset ID identifier, i.e., a human-readable type of asset identifier.\n */\nexport const CaipAssetTypeOrIdStruct = definePattern<\n  CaipAssetType | CaipAssetId\n>('CaipAssetTypeOrId', CAIP_ASSET_TYPE_OR_ID_REGEX);\nexport type CaipAssetTypeOrId = Infer<typeof CaipAssetTypeOrIdStruct>;\n\n/** Known CAIP namespaces. */\nexport enum KnownCaipNamespace {\n  /** BIP-122 (Bitcoin) compatible chains. */\n  Bip122 = 'bip122',\n  /** Solana compatible chains */\n  Solana = 'solana',\n  /** Tron compatible chains */\n  Tron = 'tron',\n  /** EIP-155 compatible chains. */\n  Eip155 = 'eip155',\n  Wallet = 'wallet',\n}\n\n/**\n * A CAIP-2 chain ID that is guaranteed to have a known CAIP namespace\n * (@see {@link KnownCaipNamespace}).\n *\n * This is a narrower, more type-safe alternative to {@link CaipChainId} for use cases\n * where the chain namespace must be one of the known standards.\n *\n * @template Namespace - The namespace of the CAIP-2 chain ID. Must be a known namespace specified in {@link KnownCaipNamespace}.\n */\nexport type KnownCaipNamespacedChainId<\n  Namespace extends `${KnownCaipNamespace}` = `${KnownCaipNamespace}`,\n> = `${Namespace}:${string}`;\n\n/**\n * Check if the given value is a {@link CaipChainId}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipChainId}.\n */\nexport function isCaipChainId(value: unknown): value is CaipChainId {\n  return typeof value === 'string' && CAIP_CHAIN_ID_REGEX.test(value);\n}\n\n/**\n * Check if the given value is a {@link CaipNamespace}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipNamespace}.\n */\nexport function isCaipNamespace(value: unknown): value is CaipNamespace {\n  return typeof value === 'string' && CAIP_NAMESPACE_REGEX.test(value);\n}\n\n/**\n * Check if the given value is a {@link CaipReference}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipReference}.\n */\nexport function isCaipReference(value: unknown): value is CaipReference {\n  return typeof value === 'string' && CAIP_REFERENCE_REGEX.test(value);\n}\n\n/**\n * Check if the given value is a {@link CaipAccountId}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAccountId}.\n */\nexport function isCaipAccountId(value: unknown): value is CaipAccountId {\n  return typeof value === 'string' && CAIP_ACCOUNT_ID_REGEX.test(value);\n}\n\n/**\n * Check if a value is a {@link CaipAccountAddress}.\n *\n * @param value - The value to validate.\n * @returns True if the value is a valid {@link CaipAccountAddress}.\n */\nexport function isCaipAccountAddress(\n  value: unknown,\n): value is CaipAccountAddress {\n  return typeof value === 'string' && CAIP_ACCOUNT_ADDRESS_REGEX.test(value);\n}\n\n/**\n * Check if the given value is a {@link CaipAssetNamespace}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAssetNamespace}.\n */\nexport function isCaipAssetNamespace(\n  value: unknown,\n): value is CaipAssetNamespace {\n  return typeof value === 'string' && CAIP_ASSET_NAMESPACE_REGEX.test(value);\n}\n\n/**\n * Check if the given value is a {@link CaipAssetReference}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAssetReference}.\n */\nexport function isCaipAssetReference(\n  value: unknown,\n): value is CaipAssetReference {\n  return typeof value === 'string' && CAIP_ASSET_REFERENCE_REGEX.test(value);\n}\n\n/**\n * Check if the given value is a {@link CaipTokenId}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipTokenId}.\n */\nexport function isCaipTokenId(value: unknown): value is CaipTokenId {\n  return typeof value === 'string' && CAIP_TOKEN_ID_REGEX.test(value);\n}\n\n/**\n * Check if the given value is a {@link CaipAssetType}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAssetType}.\n */\nexport function isCaipAssetType(value: unknown): value is CaipAssetType {\n  return typeof value === 'string' && CAIP_ASSET_TYPE_REGEX.test(value);\n}\n\n/**\n * Check if the given value is a {@link CaipAssetId}.\n *\n * @param value - The value to check.\n * @returns Whether the value is a {@link CaipAssetId}.\n */\nexport function isCaipAssetId(value: unknown): value is CaipAssetId {\n  return typeof value === 'string' && CAIP_ASSET_ID_REGEX.test(value);\n}\n\n/**\n * Parse a CAIP-2 chain ID to an object containing the namespace and reference.\n * This validates the CAIP-2 chain ID before parsing it.\n *\n * @param caipChainId - The CAIP-2 chain ID to validate and parse.\n * @returns The parsed CAIP-2 chain ID.\n */\nexport function parseCaipChainId(caipChainId: CaipChainId): {\n  namespace: CaipNamespace;\n  reference: CaipReference;\n} {\n  const match = CAIP_CHAIN_ID_REGEX.exec(caipChainId);\n  if (!match?.groups) {\n    throw new Error('Invalid CAIP chain ID.');\n  }\n\n  return {\n    namespace: match.groups.namespace as CaipNamespace,\n    reference: match.groups.reference as CaipReference,\n  };\n}\n\n/**\n * Parse an CAIP-10 account ID to an object containing the chain ID, parsed chain ID, and account address.\n * This validates the CAIP-10 account ID before parsing it.\n *\n * @param caipAccountId - The CAIP-10 account ID to validate and parse.\n * @returns The parsed CAIP-10 account ID.\n */\nexport function parseCaipAccountId(caipAccountId: CaipAccountId): {\n  address: CaipAccountAddress;\n  chainId: CaipChainId;\n  chain: { namespace: CaipNamespace; reference: CaipReference };\n} {\n  const match = CAIP_ACCOUNT_ID_REGEX.exec(caipAccountId);\n  if (!match?.groups) {\n    throw new Error('Invalid CAIP account ID.');\n  }\n\n  return {\n    address: match.groups.accountAddress as CaipAccountAddress,\n    chainId: match.groups.chainId as CaipChainId,\n    chain: {\n      namespace: match.groups.namespace as CaipNamespace,\n      reference: match.groups.reference as CaipReference,\n    },\n  };\n}\n\n/**\n * Parse a CAIP-19 asset type to an object containing the chain ID, parsed chain ID,\n * asset namespace, and asset reference\n *\n * This validates the CAIP-19 asset type before parsing it.\n *\n * @param caipAssetType - The CAIP-19 asset type to validate and parse.\n * @returns The parsed CAIP-19 asset type.\n */\nexport function parseCaipAssetType(caipAssetType: CaipAssetType): {\n  assetNamespace: CaipAssetNamespace;\n  assetReference: CaipAssetReference;\n  chainId: CaipChainId;\n  chain: { namespace: CaipNamespace; reference: CaipReference };\n} {\n  const match = CAIP_ASSET_TYPE_REGEX.exec(caipAssetType);\n  if (!match?.groups) {\n    throw new Error('Invalid CAIP asset type.');\n  }\n\n  return {\n    assetNamespace: match.groups.assetNamespace as CaipAssetNamespace,\n    assetReference: match.groups.assetReference as CaipAssetReference,\n    chainId: match.groups.chainId as CaipChainId,\n    chain: {\n      namespace: match.groups.namespace as CaipNamespace,\n      reference: match.groups.reference as CaipReference,\n    },\n  };\n}\n\n/**\n * Parse a CAIP-19 asset ID to an object containing the chain ID, parsed chain ID,\n * asset namespace, asset reference, and token ID.\n *\n * This validates the CAIP-19 asset ID before parsing it.\n *\n * @param caipAssetId - The CAIP-19 asset ID to validate and parse.\n * @returns The parsed CAIP-19 asset ID.\n */\nexport function parseCaipAssetId(caipAssetId: CaipAssetId): {\n  assetNamespace: CaipAssetNamespace;\n  assetReference: CaipAssetReference;\n  tokenId: CaipTokenId;\n  chainId: CaipChainId;\n  chain: { namespace: CaipNamespace; reference: CaipReference };\n} {\n  const match = CAIP_ASSET_ID_REGEX.exec(caipAssetId);\n  if (!match?.groups) {\n    throw new Error('Invalid CAIP asset ID.');\n  }\n\n  return {\n    assetNamespace: match.groups.assetNamespace as CaipAssetNamespace,\n    assetReference: match.groups.assetReference as CaipAssetReference,\n    tokenId: match.groups.tokenId as CaipTokenId,\n    chainId: match.groups.chainId as CaipChainId,\n    chain: {\n      namespace: match.groups.namespace as CaipNamespace,\n      reference: match.groups.reference as CaipReference,\n    },\n  };\n}\n\n/**\n * Chain ID as defined per the CAIP-2\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md}.\n *\n * It defines a way to uniquely identify any blockchain in a human-readable\n * way.\n *\n * @param namespace - The standard (ecosystem) of similar blockchains.\n * @param reference - Identify of a blockchain within a given namespace.\n * @throws {@link Error}\n * This exception is thrown if the inputs does not comply with the CAIP-2\n * syntax specification\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-2.md#syntax}.\n * @returns A CAIP chain ID.\n */\nexport function toCaipChainId(\n  namespace: CaipNamespace,\n  reference: CaipReference,\n): CaipChainId {\n  if (!isCaipNamespace(namespace)) {\n    throw new Error(\n      `Invalid \"namespace\", must match: ${CAIP_NAMESPACE_REGEX.toString()}`,\n    );\n  }\n\n  if (!isCaipReference(reference)) {\n    throw new Error(\n      `Invalid \"reference\", must match: ${CAIP_REFERENCE_REGEX.toString()}`,\n    );\n  }\n\n  return `${namespace}:${reference}`;\n}\n\n/**\n * Account ID as defined per the CAIP-10\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-10.md}.\n *\n * It defines a way to uniquely identify any blockchain account in a human-readable\n * way.\n *\n * @param namespace - The standard (ecosystem) of similar blockchains.\n * @param reference - Identity of a blockchain within a given namespace.\n * @param accountAddress - The address of the blockchain account.\n * @throws {@link Error}\n * This exception is thrown if the inputs do not comply with the CAIP-10\n * syntax specification\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-10.md#syntax}.\n * @returns A CAIP account ID.\n */\nexport function toCaipAccountId(\n  namespace: CaipNamespace,\n  reference: CaipReference,\n  accountAddress: CaipAccountAddress,\n): CaipAccountId {\n  if (!isCaipNamespace(namespace)) {\n    throw new Error(\n      `Invalid \"namespace\", must match: ${CAIP_NAMESPACE_REGEX.toString()}`,\n    );\n  }\n\n  if (!isCaipReference(reference)) {\n    throw new Error(\n      `Invalid \"reference\", must match: ${CAIP_REFERENCE_REGEX.toString()}`,\n    );\n  }\n\n  if (!isCaipAccountAddress(accountAddress)) {\n    throw new Error(\n      `Invalid \"accountAddress\", must match: ${CAIP_ACCOUNT_ADDRESS_REGEX.toString()}`,\n    );\n  }\n\n  return `${namespace}:${reference}:${accountAddress}`;\n}\n\n/**\n * Asset Type as defined per the CAIP-19\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-19.md}.\n *\n * It defines a way to uniquely identify any blockchain asset in a human-readable\n * way.\n *\n * @param namespace - The standard (ecosystem) of similar blockchains.\n * @param reference - Identity of a blockchain within a given namespace.\n * @param assetNamespace - The namespace domain of an asset.\n * @param assetReference - The identity of an asset within a given namespace.\n * @throws {@link Error}\n * This exception is thrown if the inputs do not comply with the CAIP-19\n * syntax specification\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-19.md#syntax}.\n * @returns A CAIP asset type.\n */\nexport function toCaipAssetType(\n  namespace: CaipNamespace,\n  reference: CaipReference,\n  assetNamespace: CaipAssetNamespace,\n  assetReference: CaipAssetReference,\n): CaipAssetType {\n  if (!isCaipNamespace(namespace)) {\n    throw new Error(\n      `Invalid \"namespace\", must match: ${CAIP_NAMESPACE_REGEX.toString()}`,\n    );\n  }\n\n  if (!isCaipReference(reference)) {\n    throw new Error(\n      `Invalid \"reference\", must match: ${CAIP_REFERENCE_REGEX.toString()}`,\n    );\n  }\n\n  if (!isCaipAssetNamespace(assetNamespace)) {\n    throw new Error(\n      `Invalid \"assetNamespace\", must match: ${CAIP_ASSET_NAMESPACE_REGEX.toString()}`,\n    );\n  }\n\n  if (!isCaipAssetReference(assetReference)) {\n    throw new Error(\n      `Invalid \"assetReference\", must match: ${CAIP_ASSET_REFERENCE_REGEX.toString()}`,\n    );\n  }\n\n  return `${namespace}:${reference}/${assetNamespace}:${assetReference}`;\n}\n\n/**\n * Asset ID as defined per the CAIP-19\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-19.md}.\n *\n * It defines a way to uniquely identify any blockchain asset in a human-readable\n * way.\n *\n * @param namespace - The standard (ecosystem) of similar blockchains.\n * @param reference - Identity of a blockchain within a given namespace.\n * @param assetNamespace - The namespace domain of an asset.\n * @param assetReference - The identity of an asset within a given namespace.\n * @param tokenId - The unique identifier for an addressable asset of a given type.\n * @throws {@link Error}\n * This exception is thrown if the inputs do not comply with the CAIP-19\n * syntax specification\n * {@link https://github.com/ChainAgnostic/CAIPs/blob/main/CAIPs/caip-19.md#syntax}.\n * @returns A CAIP asset ID.\n */\nexport function toCaipAssetId(\n  namespace: CaipNamespace,\n  reference: CaipReference,\n  assetNamespace: CaipAssetNamespace,\n  assetReference: CaipAssetReference,\n  tokenId: CaipTokenId,\n): CaipAssetId {\n  if (!isCaipNamespace(namespace)) {\n    throw new Error(\n      `Invalid \"namespace\", must match: ${CAIP_NAMESPACE_REGEX.toString()}`,\n    );\n  }\n\n  if (!isCaipReference(reference)) {\n    throw new Error(\n      `Invalid \"reference\", must match: ${CAIP_REFERENCE_REGEX.toString()}`,\n    );\n  }\n\n  if (!isCaipAssetNamespace(assetNamespace)) {\n    throw new Error(\n      `Invalid \"assetNamespace\", must match: ${CAIP_ASSET_NAMESPACE_REGEX.toString()}`,\n    );\n  }\n\n  if (!isCaipAssetReference(assetReference)) {\n    throw new Error(\n      `Invalid \"assetReference\", must match: ${CAIP_ASSET_REFERENCE_REGEX.toString()}`,\n    );\n  }\n\n  if (!isCaipTokenId(tokenId)) {\n    throw new Error(\n      `Invalid \"tokenId\", must match: ${CAIP_TOKEN_ID_REGEX.toString()}`,\n    );\n  }\n\n  return `${namespace}:${reference}/${assetNamespace}:${assetReference}/${tokenId}`;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2020, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/checksum.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/checksum.ts"],"sourcesContent":["import { size, string } from '@metamask/superstruct';\n\nimport { base64 } from './base64';\n\nexport const ChecksumStruct = size(\n  base64(string(), { paddingRequired: true }),\n  44,\n  44,\n);\n"],"names":[],"mappings":";;;;AAAA,MAAA,iDAAqD;AAErD,MAAA,mCAAkC;AAErB,QAAA,cAAc,GAAG,CAAA,GAAA,cAAA,IAAI,EAChC,CAAA,GAAA,SAAA,MAAM,EAAC,CAAA,GAAA,cAAA,MAAM,GAAE,EAAE;IAAE,eAAe,EAAE,IAAI;AAAA,CAAE,CAAC,EAC3C,EAAE,EACF,EAAE,CACH,CAAC"}},
    {"offset": {"line": 2033, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/coercers.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/coercers.ts"],"sourcesContent":["import type { Infer } from '@metamask/superstruct';\nimport {\n  bigint,\n  coerce,\n  create,\n  instance,\n  number,\n  string,\n  StructError,\n  union,\n} from '@metamask/superstruct';\n\nimport { assert } from './assert';\nimport { bytesToHex, hexToBytes } from './bytes';\nimport type { Hex } from './hex';\nimport { StrictHexStruct } from './hex';\n\nconst NumberLikeStruct = union([number(), bigint(), string(), StrictHexStruct]);\nconst NumberCoercer = coerce(number(), NumberLikeStruct, Number);\nconst BigIntCoercer = coerce(bigint(), NumberLikeStruct, BigInt);\n\nconst BytesLikeStruct = union([StrictHexStruct, instance(Uint8Array)]);\nconst BytesCoercer = coerce(\n  instance(Uint8Array),\n  union([StrictHexStruct]),\n  hexToBytes,\n);\n\nconst HexCoercer = coerce(StrictHexStruct, instance(Uint8Array), bytesToHex);\n\nexport type NumberLike = Infer<typeof NumberLikeStruct>;\nexport type BytesLike = Infer<typeof BytesLikeStruct>;\n\n/**\n * Create a number from a number-like value.\n *\n * - If the value is a number, it is returned as-is.\n * - If the value is a `bigint`, it is converted to a number.\n * - If the value is a string, it is interpreted as a decimal number.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is\n * interpreted as a hexadecimal number.\n *\n * This validates that the value is a number-like value, and that the resulting\n * number is not `NaN` or `Infinity`.\n *\n * @example\n * ```typescript\n * const value = createNumber('0x010203');\n * console.log(value); // 66051\n *\n * const otherValue = createNumber(123n);\n * console.log(otherValue); // 123\n * ```\n * @param value - The value to create the number from.\n * @returns The created number.\n * @throws If the value is not a number-like value, or if the resulting number\n * is `NaN` or `Infinity`.\n */\nexport function createNumber(value: NumberLike): number {\n  try {\n    const result = create(value, NumberCoercer);\n\n    assert(\n      Number.isFinite(result),\n      `Expected a number-like value, got \"${value}\".`,\n    );\n\n    return result;\n  } catch (error) {\n    if (error instanceof StructError) {\n      throw new Error(`Expected a number-like value, got \"${value}\".`);\n    }\n\n    /* istanbul ignore next */\n    throw error;\n  }\n}\n\n/**\n * Create a `bigint` from a number-like value.\n *\n * - If the value is a number, it is converted to a `bigint`.\n * - If the value is a `bigint`, it is returned as-is.\n * - If the value is a string, it is interpreted as a decimal number and\n * converted to a `bigint`.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is\n * interpreted as a hexadecimal number and converted to a `bigint`.\n *\n * @example\n * ```typescript\n * const value = createBigInt('0x010203');\n * console.log(value); // 16909060n\n *\n * const otherValue = createBigInt(123);\n * console.log(otherValue); // 123n\n * ```\n * @param value - The value to create the bigint from.\n * @returns The created bigint.\n * @throws If the value is not a number-like value.\n */\nexport function createBigInt(value: NumberLike): bigint {\n  try {\n    // The `BigInt` constructor throws if the value is not a number-like value.\n    // There is no need to validate the value manually.\n    return create(value, BigIntCoercer);\n  } catch (error) {\n    if (error instanceof StructError) {\n      throw new Error(\n        `Expected a number-like value, got \"${String(error.value)}\".`,\n      );\n    }\n\n    /* istanbul ignore next */\n    throw error;\n  }\n}\n\n/**\n * Create a byte array from a bytes-like value.\n *\n * - If the value is a byte array, it is returned as-is.\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is interpreted\n * as a hexadecimal number and converted to a byte array.\n *\n * @example\n * ```typescript\n * const value = createBytes('0x010203');\n * console.log(value); // Uint8Array [ 1, 2, 3 ]\n *\n * const otherValue = createBytes('0x010203');\n * console.log(otherValue); // Uint8Array [ 1, 2, 3 ]\n * ```\n * @param value - The value to create the byte array from.\n * @returns The created byte array.\n * @throws If the value is not a bytes-like value.\n */\nexport function createBytes(value: BytesLike): Uint8Array {\n  if (typeof value === 'string' && value.toLowerCase() === '0x') {\n    return new Uint8Array();\n  }\n\n  try {\n    return create(value, BytesCoercer);\n  } catch (error) {\n    if (error instanceof StructError) {\n      throw new Error(\n        `Expected a bytes-like value, got \"${String(error.value)}\".`,\n      );\n    }\n\n    /* istanbul ignore next */\n    throw error;\n  }\n}\n\n/**\n * Create a hexadecimal string from a bytes-like value.\n *\n * - If the value is a hex string (i.e., it starts with \"0x\"), it is returned\n * as-is.\n * - If the value is a `Uint8Array`, it is converted to a hex string.\n *\n * @example\n * ```typescript\n * const value = createHex(new Uint8Array([1, 2, 3]));\n * console.log(value); // '0x010203'\n *\n * const otherValue = createHex('0x010203');\n * console.log(otherValue); // '0x010203'\n * ```\n * @param value - The value to create the hex string from.\n * @returns The created hex string.\n * @throws If the value is not a bytes-like value.\n */\nexport function createHex(value: BytesLike): Hex {\n  if (\n    (value instanceof Uint8Array && value.length === 0) ||\n    (typeof value === 'string' && value.toLowerCase() === '0x')\n  ) {\n    return '0x';\n  }\n\n  try {\n    return create(value, HexCoercer);\n  } catch (error) {\n    if (error instanceof StructError) {\n      throw new Error(\n        `Expected a bytes-like value, got \"${String(error.value)}\".`,\n      );\n    }\n\n    /* istanbul ignore next */\n    throw error;\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2196, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/collections.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/collections.ts"],"sourcesContent":["/**\n * A {@link ReadonlyMap} that cannot be modified after instantiation.\n * The implementation uses an inner map hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this map.\n */\nclass FrozenMap<Key, Value> implements ReadonlyMap<Key, Value> {\n  readonly #map: Map<Key, Value>;\n\n  public get size() {\n    return this.#map.size;\n  }\n\n  public [Symbol.iterator]() {\n    return this.#map[Symbol.iterator]();\n  }\n\n  constructor(entries?: readonly (readonly [Key, Value])[] | null) {\n    this.#map = new Map<Key, Value>(entries);\n    Object.freeze(this);\n  }\n\n  public entries() {\n    return this.#map.entries();\n  }\n\n  public forEach(\n    callbackfn: (value: Value, key: Key, map: this) => void,\n    thisArg?: any,\n  ): void {\n    // We have to wrap the specified callback in order to prevent it from\n    // receiving a reference to the inner map.\n    return this.#map.forEach((value: Value, key: Key, _map: unknown) =>\n      callbackfn.call(thisArg, value, key, this),\n    );\n  }\n\n  public get(key: Key) {\n    return this.#map.get(key);\n  }\n\n  public has(key: Key) {\n    return this.#map.has(key);\n  }\n\n  public keys() {\n    return this.#map.keys();\n  }\n\n  public values() {\n    return this.#map.values();\n  }\n\n  public toString(): string {\n    return `FrozenMap(${this.size}) {${\n      this.size > 0\n        ? ` ${[...this.entries()]\n            .map(([key, value]) => `${String(key)} => ${String(value)}`)\n            .join(', ')} `\n        : ''\n    }}`;\n  }\n}\n\n/**\n * A {@link ReadonlySet} that cannot be modified after instantiation.\n * The implementation uses an inner set hidden via a private field, and the\n * immutability guarantee relies on it being impossible to get a reference\n * to this set.\n */\nclass FrozenSet<Value> implements ReadonlySet<Value> {\n  readonly #set: Set<Value>;\n\n  public get size() {\n    return this.#set.size;\n  }\n\n  public [Symbol.iterator]() {\n    return this.#set[Symbol.iterator]();\n  }\n\n  constructor(values?: readonly Value[] | null) {\n    this.#set = new Set<Value>(values);\n    Object.freeze(this);\n  }\n\n  public entries() {\n    return this.#set.entries();\n  }\n\n  public forEach(\n    callbackfn: (value: Value, value2: Value, set: this) => void,\n    thisArg?: any,\n  ): void {\n    // We have to wrap the specified callback in order to prevent it from\n    // receiving a reference to the inner set.\n    return this.#set.forEach((value: Value, value2: Value, _set: unknown) =>\n      callbackfn.call(thisArg, value, value2, this),\n    );\n  }\n\n  public has(value: Value) {\n    return this.#set.has(value);\n  }\n\n  public keys() {\n    return this.#set.keys();\n  }\n\n  public values() {\n    return this.#set.values();\n  }\n\n  public toString(): string {\n    return `FrozenSet(${this.size}) {${\n      this.size > 0\n        ? ` ${[...this.values()].map((member) => String(member)).join(', ')} `\n        : ''\n    }}`;\n  }\n}\n\nObject.freeze(FrozenMap);\nObject.freeze(FrozenMap.prototype);\n\nObject.freeze(FrozenSet);\nObject.freeze(FrozenSet.prototype);\n\nexport { FrozenMap, FrozenSet };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2305, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/encryption-types.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/encryption-types.ts"],"sourcesContent":["export type Eip1024EncryptedData = {\n  version: string;\n  nonce: string;\n  ephemPublicKey: string;\n  ciphertext: string;\n};\n"],"names":[],"mappings":""}},
    {"offset": {"line": 2312, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/hashing.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/hashing.ts"],"sourcesContent":["import { sha256 as nobleSha256 } from '@noble/hashes/sha256';\n\n/**\n * Compute a SHA-256 digest for a given byte array.\n *\n * Uses the native crypto implementation and falls back to noble.\n *\n * @param bytes - A byte array.\n * @returns The SHA-256 hash as a byte array.\n */\nexport async function sha256(bytes: Uint8Array): Promise<Uint8Array> {\n  // Use crypto.subtle.digest whenever possible as it is faster.\n  if (\n    'crypto' in globalThis &&\n    typeof globalThis.crypto === 'object' &&\n    // eslint-disable-next-line no-restricted-globals\n    globalThis.crypto.subtle?.digest\n  ) {\n    // eslint-disable-next-line no-restricted-globals\n    return new Uint8Array(\n      await globalThis.crypto.subtle.digest('SHA-256', bytes),\n    );\n  }\n  return nobleSha256(bytes);\n}\n"],"names":[],"mappings":";;;;AAAA,MAAA,2CAA6D;AAE7D;;;;;;;GAOG,CACI,KAAK,UAAU,MAAM,CAAC,KAAiB;IAC5C,8DAA8D;IAC9D,IACE,QAAQ,IAAI,UAAU,IACtB,OAAO,UAAU,CAAC,MAAM,KAAK,QAAQ,IACrC,iDAAiD;IACjD,UAAU,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,EAChC;QACA,iDAAiD;QACjD,OAAO,IAAI,UAAU,CACnB,MAAM,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,EAAE,KAAK,CAAC,CACxD,CAAC;KACH;IACD,OAAO,CAAA,GAAA,SAAA,MAAW,EAAC,KAAK,CAAC,CAAC;AAC5B,CAAC;AAdD,QAAA,MAAA,GAAA,OAcC"}},
    {"offset": {"line": 2338, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/json.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/json.ts"],"sourcesContent":["import {\n  any,\n  array,\n  coerce,\n  create,\n  define,\n  integer,\n  is,\n  literal,\n  nullable,\n  number,\n  object as superstructObject,\n  optional,\n  record,\n  string,\n  union,\n  unknown,\n  Struct,\n  refine,\n} from '@metamask/superstruct';\nimport type {\n  Context,\n  Infer,\n  ObjectSchema,\n  Simplify,\n  Optionalize,\n} from '@metamask/superstruct';\n\nimport type { AssertionErrorConstructor } from './assert';\nimport { assertStruct } from './assert';\nimport { hasProperty } from './misc';\n\n/**\n * Any JSON-compatible value.\n */\nexport type Json =\n  | null\n  | boolean\n  | number\n  | string\n  | Json[]\n  | { [prop: string]: Json };\n\n/**\n * A helper type to make properties with `undefined` in their type optional, but\n * not `undefined` itself.\n *\n * @deprecated Use `ObjectType` and/or `ExactOptionalize` from `@metamask/superstruct@>=3.2.0` instead.\n * @example\n * ```ts\n * type Foo = ObjectOptional<{ foo: string | undefined }>;\n * // Foo is equivalent to { foo?: string }\n * ```\n */\nexport type ObjectOptional<Schema extends Record<string, unknown>> = {\n  [Key in keyof Schema as Schema[Key] extends ExactOptionalGuard\n    ? Key\n    : never]?: Schema[Key] extends ExactOptionalGuard & infer Original\n    ? Original\n    : never;\n} & {\n  [Key in keyof Schema as Schema[Key] extends ExactOptionalGuard\n    ? never\n    : Key]: Schema[Key];\n};\n\n/**\n * An object type with support for exact optionals. This is used by the `object`\n * struct. This uses the {@link ObjectOptional} helper to make properties with\n * `undefined` in their type optional, but not `undefined` itself.\n *\n * @deprecated Use `ObjectType` from `@metamask/superstruct@>=3.2.0` instead.\n */\nexport type ObjectType<Schema extends ObjectSchema> = Simplify<\n  ObjectOptional<\n    Optionalize<{\n      [Key in keyof Schema]: Infer<Schema[Key]>;\n    }>\n  >\n>;\n\n/**\n * A struct to check if the given value is a valid object, with support for\n * {@link exactOptional} types.\n *\n * @deprecated Use `exactOptional` and `object` from `@metamask/superstruct@>=3.2.0` instead.\n * @param schema - The schema of the object.\n * @returns A struct to check if the given value is an object.\n */\nexport const object = <Schema extends ObjectSchema>(\n  schema: Schema,\n): Struct<ObjectType<Schema>> =>\n  // The type is slightly different from a regular object struct, because we\n  // want to make properties with `undefined` in their type optional, but not\n  // `undefined` itself. This means that we need a type cast.\n  superstructObject(schema) as unknown as Struct<ObjectType<Schema>>;\n\ndeclare const exactOptionalSymbol: unique symbol;\ntype ExactOptionalGuard = {\n  _exactOptionalGuard?: typeof exactOptionalSymbol;\n};\n\n/**\n * Check the last field of a path is present.\n *\n * @param context - The context to check.\n * @param context.path - The path to check.\n * @param context.branch - The branch to check.\n * @returns Whether the last field of a path is present.\n */\nfunction hasOptional({ path, branch }: Context): boolean {\n  const field = path[path.length - 1];\n  return hasProperty(branch[branch.length - 2], field);\n}\n\n/**\n * A struct which allows the property of an object to be absent, or to be present\n * as long as it's valid and not set to `undefined`.\n *\n * This struct should be used in conjunction with the {@link object} from this\n * library, to get proper type inference.\n *\n * @deprecated Use `exactOptional` and `object` from `@metamask/superstruct@>=3.2.0` instead.\n * @param struct - The struct to check the value against, if present.\n * @returns A struct to check if the given value is valid, or not present.\n * @example\n * ```ts\n * const struct = object({\n *   foo: exactOptional(string()),\n *   bar: exactOptional(number()),\n *   baz: optional(boolean()),\n *   qux: unknown(),\n * });\n *\n * type Type = Infer<typeof struct>;\n * // Type is equivalent to:\n * // {\n * //   foo?: string;\n * //   bar?: number;\n * //   baz?: boolean | undefined;\n * //   qux: unknown;\n * // }\n * ```\n */\nexport function exactOptional<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<Type & ExactOptionalGuard, Schema> {\n  return new Struct<Type & ExactOptionalGuard, Schema>({\n    ...struct,\n\n    type: `optional ${struct.type}`,\n    validator: (value, context) =>\n      !hasOptional(context) || struct.validator(value, context),\n\n    refiner: (value, context) =>\n      !hasOptional(context) || struct.refiner(value as Type, context),\n  });\n}\n\n/**\n * Validate an unknown input to be valid JSON.\n *\n * Useful for constructing JSON structs.\n *\n * @param json - An unknown value.\n * @returns True if the value is valid JSON, otherwise false.\n */\nfunction validateJson(json: unknown): boolean {\n  if (json === null || typeof json === 'boolean' || typeof json === 'string') {\n    return true;\n  }\n\n  if (typeof json === 'number' && Number.isFinite(json)) {\n    return true;\n  }\n\n  if (typeof json === 'object') {\n    let every = true;\n    if (Array.isArray(json)) {\n      // Ignoring linting error since for-of is significantly slower than a normal for-loop\n      // and performance is important in this specific function.\n      // eslint-disable-next-line @typescript-eslint/prefer-for-of\n      for (let i = 0; i < json.length; i++) {\n        if (!validateJson(json[i])) {\n          every = false;\n          break;\n        }\n      }\n      return every;\n    }\n\n    const entries = Object.entries(json);\n    // Ignoring linting errors since for-of is significantly slower than a normal for-loop\n    // and performance is important in this specific function.\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < entries.length; i++) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      if (typeof entries[i]![0] !== 'string' || !validateJson(entries[i]![1])) {\n        every = false;\n        break;\n      }\n    }\n    return every;\n  }\n\n  return false;\n}\n\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * Note that this struct is unsafe. For safe validation, use {@link JsonStruct}.\n */\nexport const UnsafeJsonStruct: Struct<Json> = define('JSON', (json) =>\n  validateJson(json),\n);\n\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * This struct sanitizes the value before validating it, so that it is safe to\n * use with untrusted input.\n */\nexport const JsonStruct = coerce(\n  UnsafeJsonStruct,\n  refine(any(), 'JSON', (value) => is(value, UnsafeJsonStruct)),\n  (value) =>\n    JSON.parse(\n      JSON.stringify(value, (propKey, propValue) => {\n        // Strip __proto__ and constructor properties to prevent prototype pollution.\n        if (propKey === '__proto__' || propKey === 'constructor') {\n          return undefined;\n        }\n        return propValue;\n      }),\n    ),\n);\n\n/**\n * Check if the given value is a valid {@link Json} value, i.e., a value that is\n * serializable to JSON.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link Json} value.\n */\nexport function isValidJson(value: unknown): value is Json {\n  try {\n    getSafeJson(value);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Validate and return sanitized JSON.\n *\n * Note:\n * This function uses sanitized JsonStruct for validation\n * that applies stringify and then parse of a value provided\n * to ensure that there are no getters which can have side effects\n * that can cause security issues.\n *\n * @param value - JSON structure to be processed.\n * @returns Sanitized JSON structure.\n */\nexport function getSafeJson<Type extends Json = Json>(value: unknown): Type {\n  return create(value, JsonStruct) as Type;\n}\n\n/**\n * Get the size of a JSON value in bytes. This also validates the value.\n *\n * @param value - The JSON value to get the size of.\n * @returns The size of the JSON value in bytes.\n */\nexport function getJsonSize(value: unknown): number {\n  assertStruct(value, JsonStruct, 'Invalid JSON value');\n\n  const json = JSON.stringify(value);\n  return new TextEncoder().encode(json).byteLength;\n}\n\n/**\n * The string '2.0'.\n */\nexport const jsonrpc2 = '2.0' as const;\nexport const JsonRpcVersionStruct = literal(jsonrpc2);\n\n/**\n * A String specifying the version of the JSON-RPC protocol.\n * MUST be exactly \"2.0\".\n */\nexport type JsonRpcVersion2 = typeof jsonrpc2;\n\nexport const JsonRpcIdStruct = nullable(union([number(), string()]));\n\n/**\n * An identifier established by the Client that MUST contain a String, Number,\n * or NULL value if included. If it is not included it is assumed to be a\n * notification. The value SHOULD normally not be Null and Numbers SHOULD\n * NOT contain fractional parts.\n */\nexport type JsonRpcId = Infer<typeof JsonRpcIdStruct>;\n\nexport const JsonRpcErrorStruct = object({\n  code: integer(),\n  message: string(),\n  data: exactOptional(JsonStruct),\n  stack: exactOptional(string()),\n});\n\n/**\n * Mark a certain key of a type as optional.\n */\nexport type OptionalField<\n  Type extends Record<string, unknown>,\n  Key extends keyof Type,\n> = Omit<Type, Key> & Partial<Pick<Type, Key>>;\n\n/**\n * A JSON-RPC error object.\n *\n * Note that TypeScript infers `unknown | undefined` as `unknown`, meaning that\n * the `data` field is not optional. To make it optional, we use the\n * `OptionalField` helper, to explicitly make it optional.\n */\nexport type JsonRpcError = OptionalField<\n  Infer<typeof JsonRpcErrorStruct>,\n  'data'\n>;\n\nexport const JsonRpcParamsStruct: Struct<Json[] | Record<string, Json>, null> =\n  union([record(string(), JsonStruct), array(JsonStruct)]);\n\nexport type JsonRpcParams = Json[] | Record<string, Json>;\n\nexport const JsonRpcRequestStruct = object({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  method: string(),\n  params: exactOptional(JsonRpcParamsStruct),\n});\n\nexport type InferWithParams<\n  Type extends Struct<any>,\n  Params extends JsonRpcParams,\n> = Infer<Type> & {\n  params?: Params;\n};\n\n/**\n * A JSON-RPC request object.\n */\nexport type JsonRpcRequest<Params extends JsonRpcParams = JsonRpcParams> =\n  InferWithParams<typeof JsonRpcRequestStruct, Params>;\n\nexport const JsonRpcNotificationStruct = object({\n  jsonrpc: JsonRpcVersionStruct,\n  method: string(),\n  params: exactOptional(JsonRpcParamsStruct),\n});\n\n/**\n * A JSON-RPC notification object.\n */\nexport type JsonRpcNotification<Params extends JsonRpcParams = JsonRpcParams> =\n  InferWithParams<typeof JsonRpcNotificationStruct, Params>;\n\n/**\n * Check if the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcNotification}\n * object.\n */\nexport function isJsonRpcNotification(\n  value: unknown,\n): value is JsonRpcNotification {\n  return is(value, JsonRpcNotificationStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcNotification} object.\n */\nexport function assertIsJsonRpcNotification(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcNotification {\n  assertStruct(\n    value,\n    JsonRpcNotificationStruct,\n    'Invalid JSON-RPC notification',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Check if the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcRequest} object.\n */\nexport function isJsonRpcRequest(value: unknown): value is JsonRpcRequest {\n  return is(value, JsonRpcRequestStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The JSON-RPC request or notification to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcRequest} object.\n */\nexport function assertIsJsonRpcRequest(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcRequest {\n  assertStruct(\n    value,\n    JsonRpcRequestStruct,\n    'Invalid JSON-RPC request',\n    ErrorWrapper,\n  );\n}\n\nexport const PendingJsonRpcResponseStruct = superstructObject({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  result: optional(unknown()),\n  error: optional(JsonRpcErrorStruct),\n});\n\n/**\n * A JSON-RPC response object that has not yet been resolved.\n */\nexport type PendingJsonRpcResponse<Result extends Json = Json> = Omit<\n  Infer<typeof PendingJsonRpcResponseStruct>,\n  'result'\n> & {\n  result?: Result;\n};\n\nexport const JsonRpcSuccessStruct = object({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  result: JsonStruct,\n});\n\n/**\n * A successful JSON-RPC response object.\n */\nexport type JsonRpcSuccess<Result extends Json = Json> = Omit<\n  Infer<typeof JsonRpcSuccessStruct>,\n  'result'\n> & {\n  result: Result;\n};\n\nexport const JsonRpcFailureStruct = object({\n  id: JsonRpcIdStruct,\n  jsonrpc: JsonRpcVersionStruct,\n  error: JsonRpcErrorStruct as Struct<JsonRpcError>,\n});\n\n/**\n * A failed JSON-RPC response object.\n */\nexport type JsonRpcFailure = Infer<typeof JsonRpcFailureStruct>;\n\nexport const JsonRpcResponseStruct = union([\n  JsonRpcSuccessStruct,\n  JsonRpcFailureStruct,\n]);\n\n/**\n * A JSON-RPC response object. Must be checked to determine whether it's a\n * success or failure.\n *\n * @template Result - The type of the result.\n */\nexport type JsonRpcResponse<Result extends Json = Json> =\n  | JsonRpcSuccess<Result>\n  | JsonRpcFailure;\n\n/**\n * Type guard to check whether specified JSON-RPC response is a\n * {@link PendingJsonRpcResponse}.\n *\n * @param response - The JSON-RPC response to check.\n * @returns Whether the specified JSON-RPC response is pending.\n */\nexport function isPendingJsonRpcResponse(\n  response: unknown,\n): response is PendingJsonRpcResponse {\n  return is(response, PendingJsonRpcResponseStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.\n *\n * @param response - The JSON-RPC response to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link PendingJsonRpcResponse}\n * object.\n */\nexport function assertIsPendingJsonRpcResponse(\n  response: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts response is PendingJsonRpcResponse {\n  assertStruct(\n    response,\n    PendingJsonRpcResponseStruct,\n    'Invalid pending JSON-RPC response',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Type guard to check if a value is a {@link JsonRpcResponse}.\n *\n * @param response - The object to check.\n * @returns Whether the object is a JsonRpcResponse.\n */\nexport function isJsonRpcResponse(\n  response: unknown,\n): response is JsonRpcResponse {\n  return is(response, JsonRpcResponseStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcResponse} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcResponse} object.\n */\nexport function assertIsJsonRpcResponse(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcResponse {\n  assertStruct(\n    value,\n    JsonRpcResponseStruct,\n    'Invalid JSON-RPC response',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Check if the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.\n */\nexport function isJsonRpcSuccess(value: unknown): value is JsonRpcSuccess {\n  return is(value, JsonRpcSuccessStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcSuccess} object.\n */\nexport function assertIsJsonRpcSuccess(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcSuccess {\n  assertStruct(\n    value,\n    JsonRpcSuccessStruct,\n    'Invalid JSON-RPC success response',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Check if the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcFailure} object.\n */\nexport function isJsonRpcFailure(value: unknown): value is JsonRpcFailure {\n  return is(value, JsonRpcFailureStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcFailure} object.\n */\nexport function assertIsJsonRpcFailure(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcFailure {\n  assertStruct(\n    value,\n    JsonRpcFailureStruct,\n    'Invalid JSON-RPC failure response',\n    ErrorWrapper,\n  );\n}\n\n/**\n * Check if the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcError} object.\n */\nexport function isJsonRpcError(value: unknown): value is JsonRpcError {\n  return is(value, JsonRpcErrorStruct);\n}\n\n/**\n * Assert that the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcError} object.\n */\nexport function assertIsJsonRpcError(\n  value: unknown,\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  ErrorWrapper?: AssertionErrorConstructor,\n): asserts value is JsonRpcError {\n  assertStruct(\n    value,\n    JsonRpcErrorStruct,\n    'Invalid JSON-RPC error',\n    ErrorWrapper,\n  );\n}\n\ntype JsonRpcValidatorOptions = {\n  permitEmptyString?: boolean;\n  permitFractions?: boolean;\n  permitNull?: boolean;\n};\n\n/**\n * Gets a function for validating JSON-RPC request / response `id` values.\n *\n * By manipulating the options of this factory, you can control the behavior\n * of the resulting validator for some edge cases. This is useful because e.g.\n * `null` should sometimes but not always be permitted.\n *\n * Note that the empty string (`''`) is always permitted by the JSON-RPC\n * specification, but that kind of sucks and you may want to forbid it in some\n * instances anyway.\n *\n * For more details, see the\n * [JSON-RPC Specification](https://www.jsonrpc.org/specification).\n *\n * @param options - An options object.\n * @param options.permitEmptyString - Whether the empty string (i.e. `''`)\n * should be treated as a valid ID. Default: `true`\n * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)\n * should be treated as valid IDs. Default: `false`\n * @param options.permitNull - Whether `null` should be treated as a valid ID.\n * Default: `true`\n * @returns The JSON-RPC ID validator function.\n */\nexport function getJsonRpcIdValidator(options?: JsonRpcValidatorOptions) {\n  const { permitEmptyString, permitFractions, permitNull } = {\n    permitEmptyString: true,\n    permitFractions: false,\n    permitNull: true,\n    ...options,\n  };\n\n  /**\n   * Type guard for {@link JsonRpcId}.\n   *\n   * @param id - The JSON-RPC ID value to check.\n   * @returns Whether the given ID is valid per the options given to the\n   * factory.\n   */\n  const isValidJsonRpcId = (id: unknown): id is JsonRpcId => {\n    return Boolean(\n      (typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||\n        (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||\n        (permitNull && id === null),\n    );\n  };\n\n  return isValidJsonRpcId;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2750, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/keyring.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/keyring.ts"],"sourcesContent":["import type { TypedTransaction, TxData } from '@ethereumjs/tx';\n\nimport type { Eip1024EncryptedData } from './encryption-types';\nimport type { Hex } from './hex';\nimport type { Json } from './json';\n\n/**\n * A Keyring class.\n *\n * This type is used to validate the constructor signature and the `type`\n * static property on Keyring classes. See the {@link Keyring} type for more\n * information.\n *\n * @deprecated This type has been moved to the `@metamask/keyring-utils` package.\n * See {@link https://github.com/MetaMask/accounts/tree/main/packages/keyring-utils Keyring Utils}.\n */\nexport type KeyringClass<State extends Json> = {\n  /**\n   * The Keyring constructor. Takes a single parameter, an \"options\" object.\n   * See the documentation for the specific keyring for more information about\n   * what these options are.\n   *\n   * @param options - The constructor options. Differs between keyring\n   * implementations.\n   */\n  new (options?: Record<string, unknown>): Keyring<State>;\n\n  /**\n   * The name of this type of keyring. This must uniquely identify the\n   * keyring type.\n   */\n  type: string;\n};\n\n/**\n * A keyring is something that can sign messages. Keyrings are used to add new\n * signing strategies; each strategy is a new keyring.\n *\n * Each keyring manages a collection of key pairs, which we call \"accounts\".\n * Each account is referred to by its \"address\", which is a unique identifier\n * derived from the public key. The address is always a \"0x\"-prefixed\n * hexidecimal string.\n *\n * The keyring might store the private key for each account as well, but it's\n * not guaranteed. Some keyrings delegate signing, so they don't need the\n * private key directly. The keyring (and in particular the keyring state)\n * should be treated with care though, just in case it does contain sensitive\n * material such as a private key.\n *\n * @deprecated This type has been moved to the `@metamask/keyring-utils` package.\n * See {@link https://github.com/MetaMask/accounts/tree/main/packages/keyring-utils Keyring Utils}.\n */\nexport type Keyring<State extends Json> = {\n  /**\n   * The name of this type of keyring. This must match the `type` property of\n   * the keyring class.\n   */\n  type: string;\n\n  /**\n   * Get the addresses for all accounts in this keyring.\n   *\n   * @returns A list of the account addresses for this keyring\n   */\n  getAccounts(): Promise<Hex[]>;\n\n  /**\n   * Add an account to the keyring.\n   *\n   * @param number - The number of accounts to add. Usually defaults to 1.\n   * @returns A list of the newly added account addresses.\n   */\n  addAccounts(number: number): Promise<Hex[]>;\n\n  /**\n   * Serialize the keyring state as a JSON-serializable object.\n   *\n   * @returns A JSON-serializable representation of the keyring state.\n   */\n  serialize(): Promise<State>;\n\n  /**\n   * Deserialize the given keyring state, overwriting any existing state with\n   * the serialized state provided.\n   *\n   * @param state - A JSON-serializable representation of the keyring state.\n   */\n  deserialize(state: State): Promise<void>;\n\n  /**\n   * Method to include asynchronous configuration.\n   */\n  init?(): Promise<void>;\n\n  /**\n   * Remove an account from the keyring.\n   *\n   * @param address - The address of the account to remove.\n   */\n  removeAccount?(address: Hex): void;\n\n  /**\n   * Export the private key for one of the keyring accounts.\n   *\n   * Some keyrings accept an \"options\" parameter as well. See the documentation\n   * for the specific keyring for more information about what these options\n   * are. For some keyrings, the options parameter is used to allow exporting a\n   * private key that is derived from the given account, rather than exporting\n   * that account's private key directly.\n   *\n   * @param address - The address of the account to export.\n   * @param options - Export options; differs between keyrings.\n   * @returns The non-prefixed, hex-encoded private key that was requested.\n   */\n  exportAccount?(\n    address: Hex,\n    options?: Record<string, unknown>,\n  ): Promise<string>;\n\n  /**\n   * Get the \"app key\" address for the given account and origin. An app key is\n   * an application-specific key pair. See {@link https://eips.ethereum.org/EIPS/eip-1775|EIP-1775}\n   * for more information. The {@link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin|origin}\n   * is used as the unique identifier for the application, and it's used as\n   * part of the key derivation process.\n   *\n   * @param address - The address of the account the app key is derived from.\n   * @param origin - The origin of the application.\n   * @returns The address of the app key for the given account and origin.\n   */\n  getAppKeyAddress?(address: Hex, origin: string): Promise<Hex>;\n\n  /**\n   * Sign a transaction. This is equivalent to the `eth_signTransaction`\n   * Ethereum JSON-RPC method. See the Ethereum JSON-RPC API documentation for\n   * more details.\n   *\n   * Some keyrings accept an \"options\" parameter as well. See the documentation\n   * for the specific keyring for more information about what these options\n   * are. For some keyrings, the options parameter can even change which key is\n   * used for signing (e.g. signing with app keys).\n   *\n   * @param address - The address of the account to use for signing.\n   * @param transaction - The transaction to sign.\n   * @param options - Signing options; differs between keyrings.\n   * @returns The signed transaction.\n   */\n  signTransaction?(\n    address: Hex,\n    transaction: TypedTransaction,\n    options?: Record<string, unknown>,\n  ): Promise<TxData>;\n\n  /**\n   * Sign a message. This is equivalent to an older version of the the\n   * `eth_sign` Ethereum JSON-RPC method. The message is signed using ECDSA,\n   * using the curve secp256k1 the Keccak-256 hash function.\n   *\n   * For more information about this method and why we still support it, see\n   * the {@link https://docs.metamask.io/guide/signing-data.html|MetaMask Docs}.\n   *\n   * Some keyrings accept an \"options\" parameter as well. See the documentation\n   * for the specific keyring for more information about what these options\n   * are. For some keyrings, the options parameter can even change which key is\n   * used for signing (e.g. signing with app keys).\n   *\n   * @param address - The address of the account to use for signing.\n   * @param message - The message to sign.\n   * @param options - Signing options; differs between keyrings.\n   * @returns The signed message.\n   */\n  signMessage?(\n    address: Hex,\n    message: string,\n    options?: Record<string, unknown>,\n  ): Promise<string>;\n\n  /**\n   * Sign an EIP-7702 authorization. This is a signing method for authorizing a\n   * specific contract on a specific chain.\n   *\n   * @param address - The address of the account to use for signing.\n   * @param authorization - An array containing the chain ID, contract address,\n   * and nonce.\n   * @param options - Signing options; differs between keyrings.\n   * @returns The signed authorization as a hex string.\n   */\n  signEip7702Authorization?(\n    address: Hex,\n    authorization: [chainId: number, contractAddress: Hex, nonce: number],\n    options?: Record<string, unknown>,\n  ): Promise<string>;\n\n  /**\n   * Sign a message. This is equivalent to the `eth_sign` Ethereum JSON-RPC\n   * method, which is exposed by MetaMask as the method `personal_sign`. See\n   * the Ethereum JSON-RPC API documentation for more details.\n   *\n   * For more information about this method and why we call it `personal_sign`,\n   * see the {@link https://docs.metamask.io/guide/signing-data.html|MetaMask Docs}.\n   *\n   * Some keyrings accept an \"options\" parameter as well. See the documentation\n   * for the specific keyring for more information about what these options\n   * are. For some keyrings, the options parameter can even change which key is\n   * used for signing (e.g. signing with app keys).\n   *\n   * @param address - The address of the account to use for signing.\n   * @param message - The message to sign.\n   * @param options - Signing options; differs between keyrings.\n   * @returns The signed message.\n   */\n  signPersonalMessage?(\n    address: Hex,\n    message: Hex,\n    options?: { version?: string } & Record<string, unknown>,\n  ): Promise<string>;\n\n  /**\n   * Sign a message. This is equivalent to the `eth_signTypedData` Ethereum\n   * JSON-RPC method. See {@link https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md|EIP-712}\n   * for more details.\n   *\n   * The \"version\" option dictates which version of `eth_signTypedData` is\n   * used. The latest version reflects the specification most closely, whereas\n   * earlier versions reflect earlier drafts of the specification that are\n   * still supported for backwards-compatibility reasons. For more information\n   * about why we support multiple versions, see the {@link https://docs.metamask.io/guide/signing-data.html|MetaMask Docs}.\n   *\n   * Some keyrings accept additional options as well. See the documentation for\n   * the specific keyring for more information about what these options are.\n   * For some keyrings, the options parameter can even change which key is used\n   * for signing (e.g. signing with app keys).\n   *\n   * @param address - The address of the account to use for signing.\n   * @param typedData - The data to sign.\n   * @param options - Signing options; differs between keyrings.\n   * @returns The signed message.\n   */\n  signTypedData?(\n    address: Hex,\n    typedData: Record<string, unknown>,\n    options?: Record<string, unknown>,\n  ): Promise<string>;\n\n  /**\n   * Get a public key to use for encryption. This is equivalent to the\n   * ` eth_getEncryptionPublicKey` JSON-RPC method. See the {@link https://docs.metamask.io/guide/rpc-api.html#eth-getencryptionpublickey|MetaMask Docs}\n   * for more information.\n   *\n   * Some keyrings accept an \"options\" parameter as well. See the documentation\n   * for the specific keyring for more information about what these options\n   * are. For some keyrings, the options parameter can even change which key is\n   * used (e.g. encrypting with app keys).\n   *\n   * @param account - The address of the account you want the encryption key for.\n   * @param options - Options; differs between keyrings.\n   */\n  getEncryptionPublicKey?(\n    account: Hex,\n    options?: Record<string, unknown>,\n  ): Promise<string>;\n\n  /**\n   * Decrypt an encrypted message. This is equivalent to the `  eth_decrypt`\n   * JSON-RPC method. See the {@link https://docs.metamask.io/guide/rpc-api.html#eth-decrypt|MetaMask Docs}\n   * for more information.\n   *\n   * @param account - The address of the account you want to use to decrypt\n   * the message.\n   * @param encryptedData - The encrypted data that you want to decrypt.\n   * @returns The decrypted data.\n   */\n  decryptMessage?(\n    account: Hex,\n    encryptedData: Eip1024EncryptedData,\n  ): Promise<string>;\n\n  /**\n   * Generates the properties for the keyring based on the given\n   * BIP39-compliant mnemonic.\n   *\n   * @returns A promise resolving when the keyring has generated the properties.\n   */\n  generateRandomMnemonic?(): Promise<void>;\n\n  /**\n   * Destroy the keyring.\n   */\n  destroy?(): Promise<void>;\n};\n"],"names":[],"mappings":""}},
    {"offset": {"line": 2757, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/logging.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/logging.ts"],"sourcesContent":["import type { Debugger } from 'debug';\nimport debug from 'debug';\n\nconst globalLogger = debug('metamask');\n\n/**\n * Creates a logger via the `debug` library whose log messages will be tagged\n * using the name of your project. By default, such messages will be\n * suppressed, but you can reveal them by setting the `DEBUG` environment\n * variable to `metamask:<projectName>`. You can also set this variable to\n * `metamask:*` if you want to see log messages from all MetaMask projects that\n * are also using this function to create their loggers.\n *\n * @param projectName - The name of your project. This should be the name of\n * your NPM package if you're developing one.\n * @returns An instance of `debug`.\n */\nexport function createProjectLogger(projectName: string): Debugger {\n  return globalLogger.extend(projectName);\n}\n\n/**\n * Creates a logger via the `debug` library which is derived from the logger for\n * the whole project whose log messages will be tagged using the name of your\n * module. By default, such messages will be suppressed, but you can reveal them\n * by setting the `DEBUG` environment variable to\n * `metamask:<projectName>:<moduleName>`. You can also set this variable to\n * `metamask:<projectName>:*` if you want to see log messages from the project,\n * or `metamask:*` if you want to see log messages from all MetaMask projects.\n *\n * @param projectLogger - The logger created via {@link createProjectLogger}.\n * @param moduleName - The name of your module. You could use the name of the\n * file where you're using this logger or some other name.\n * @returns An instance of `debug`.\n */\nexport function createModuleLogger(\n  projectLogger: Debugger,\n  moduleName: string,\n): Debugger {\n  return projectLogger.extend(moduleName);\n}\n"],"names":[],"mappings":";;;;;;;;;AACA,MAAA,UAAA,kCAA0B;AAE1B,MAAM,YAAY,GAAG,CAAA,GAAA,QAAA,OAAK,EAAC,UAAU,CAAC,CAAC;AAEvC;;;;;;;;;;;GAWG,CACH,SAAgB,mBAAmB,CAAC,WAAmB;IACrD,OAAO,YAAY,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;AAC1C,CAAC;AAFD,QAAA,mBAAA,GAAA,oBAEC;AAED;;;;;;;;;;;;;GAaG,CACH,SAAgB,kBAAkB,CAChC,aAAuB,EACvB,UAAkB;IAElB,OAAO,aAAa,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;AAC1C,CAAC;AALD,QAAA,kBAAA,GAAA,mBAKC"}},
    {"offset": {"line": 2804, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/number.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/number.ts"],"sourcesContent":["import { assert } from './assert';\nimport type { Hex } from './hex';\nimport { add0x, assertIsHexString } from './hex';\n\n/**\n * Convert a number to a hexadecimal string. This verifies that the number is a\n * non-negative safe integer.\n *\n * To convert a `bigint` to a hexadecimal string instead, use\n * {@link bigIntToHex}.\n *\n * @example\n * ```typescript\n * numberToHex(0); // '0x0'\n * numberToHex(1); // '0x1'\n * numberToHex(16); // '0x10'\n * ```\n * @param value - The number to convert to a hexadecimal string.\n * @returns The hexadecimal string, with the \"0x\"-prefix.\n * @throws If the number is not a non-negative safe integer.\n */\nexport const numberToHex = (value: number): Hex => {\n  assert(typeof value === 'number', 'Value must be a number.');\n  assert(value >= 0, 'Value must be a non-negative number.');\n  assert(\n    Number.isSafeInteger(value),\n    'Value is not a safe integer. Use `bigIntToHex` instead.',\n  );\n\n  return add0x(value.toString(16));\n};\n\n/**\n * Convert a `bigint` to a hexadecimal string. This verifies that the `bigint`\n * is a non-negative integer.\n *\n * To convert a number to a hexadecimal string instead, use {@link numberToHex}.\n *\n * @example\n * ```typescript\n * bigIntToHex(0n); // '0x0'\n * bigIntToHex(1n); // '0x1'\n * bigIntToHex(16n); // '0x10'\n * ```\n * @param value - The `bigint` to convert to a hexadecimal string.\n * @returns The hexadecimal string, with the \"0x\"-prefix.\n * @throws If the `bigint` is not a non-negative integer.\n */\nexport const bigIntToHex = (value: bigint): Hex => {\n  assert(typeof value === 'bigint', 'Value must be a bigint.');\n  assert(value >= 0, 'Value must be a non-negative bigint.');\n\n  return add0x(value.toString(16));\n};\n\n/**\n * Convert a hexadecimal string to a number. This verifies that the string is a\n * valid hex string, and that the resulting number is a safe integer. Both\n * \"0x\"-prefixed and unprefixed strings are supported.\n *\n * To convert a hexadecimal string to a `bigint` instead, use\n * {@link hexToBigInt}.\n *\n * @example\n * ```typescript\n * hexToNumber('0x0'); // 0\n * hexToNumber('0x1'); // 1\n * hexToNumber('0x10'); // 16\n * ```\n * @param value - The hexadecimal string to convert to a number.\n * @returns The number.\n * @throws If the value is not a valid hexadecimal string, or if the resulting\n * number is not a safe integer.\n */\nexport const hexToNumber = (value: string): number => {\n  assertIsHexString(value);\n\n  // `parseInt` accepts values without the \"0x\"-prefix, whereas `Number` does\n  // not. Using this is slightly faster than `Number(add0x(value))`.\n  const numberValue = parseInt(value, 16);\n\n  assert(\n    Number.isSafeInteger(numberValue),\n    'Value is not a safe integer. Use `hexToBigInt` instead.',\n  );\n\n  return numberValue;\n};\n\n/**\n * Convert a hexadecimal string to a `bigint`. This verifies that the string is\n * a valid hex string. Both \"0x\"-prefixed and unprefixed strings are supported.\n *\n * To convert a hexadecimal string to a number instead, use {@link hexToNumber}.\n *\n * @example\n * ```typescript\n * hexToBigInt('0x0'); // 0n\n * hexToBigInt('0x1'); // 1n\n * hexToBigInt('0x10'); // 16n\n * ```\n * @param value - The hexadecimal string to convert to a `bigint`.\n * @returns The `bigint`.\n * @throws If the value is not a valid hexadecimal string.\n */\nexport const hexToBigInt = (value: string): bigint => {\n  assertIsHexString(value);\n\n  // The `BigInt` constructor requires the \"0x\"-prefix to parse a hex string.\n  return BigInt(add0x(value));\n};\n"],"names":[],"mappings":";;;;AAAA,MAAA,mCAAkC;AAElC,MAAA,6BAAiD;AAEjD;;;;;;;;;;;;;;;;GAgBG,CACI,MAAM,WAAW,GAAG,CAAC,KAAa,EAAO,EAAE;IAChD,CAAA,GAAA,SAAA,MAAM,EAAC,OAAO,KAAK,KAAK,QAAQ,EAAE,yBAAyB,CAAC,CAAC;IAC7D,CAAA,GAAA,SAAA,MAAM,EAAC,KAAK,IAAI,CAAC,EAAE,sCAAsC,CAAC,CAAC;IAC3D,CAAA,GAAA,SAAA,MAAM,EACJ,MAAM,CAAC,aAAa,CAAC,KAAK,CAAC,EAC3B,yDAAyD,CAC1D,CAAC;IAEF,OAAO,CAAA,GAAA,MAAA,KAAK,EAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC;AATW,QAAA,WAAW,GAAA,YAStB;AAEF;;;;;;;;;;;;;;;GAeG,CACI,MAAM,WAAW,GAAG,CAAC,KAAa,EAAO,EAAE;IAChD,CAAA,GAAA,SAAA,MAAM,EAAC,OAAO,KAAK,KAAK,QAAQ,EAAE,yBAAyB,CAAC,CAAC;IAC7D,CAAA,GAAA,SAAA,MAAM,EAAC,KAAK,IAAI,CAAC,EAAE,sCAAsC,CAAC,CAAC;IAE3D,OAAO,CAAA,GAAA,MAAA,KAAK,EAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;AACnC,CAAC,CAAC;AALW,QAAA,WAAW,GAAA,YAKtB;AAEF;;;;;;;;;;;;;;;;;;GAkBG,CACI,MAAM,WAAW,GAAG,CAAC,KAAa,EAAU,EAAE;IACnD,CAAA,GAAA,MAAA,iBAAiB,EAAC,KAAK,CAAC,CAAC;IAEzB,2EAA2E;IAC3E,kEAAkE;IAClE,MAAM,WAAW,GAAG,QAAQ,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;IAExC,CAAA,GAAA,SAAA,MAAM,EACJ,MAAM,CAAC,aAAa,CAAC,WAAW,CAAC,EACjC,yDAAyD,CAC1D,CAAC;IAEF,OAAO,WAAW,CAAC;AACrB,CAAC,CAAC;AAbW,QAAA,WAAW,GAAA,YAatB;AAEF;;;;;;;;;;;;;;;GAeG,CACI,MAAM,WAAW,GAAG,CAAC,KAAa,EAAU,EAAE;IACnD,CAAA,GAAA,MAAA,iBAAiB,EAAC,KAAK,CAAC,CAAC;IAEzB,2EAA2E;IAC3E,OAAO,MAAM,CAAC,CAAA,GAAA,MAAA,KAAK,EAAC,KAAK,CAAC,CAAC,CAAC;AAC9B,CAAC,CAAC;AALW,QAAA,WAAW,GAAA,YAKtB"}},
    {"offset": {"line": 2906, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/opaque.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/opaque.ts"],"sourcesContent":["// We use a symbol property name instead of { _type: Brand }, because that would show up in IDE suggestions,\n// while internal symbols do not.\ndeclare const brand: unique symbol;\nexport type Opaque<Base, Brand extends symbol> = Base & { [brand]: Brand };\n"],"names":[],"mappings":""}},
    {"offset": {"line": 2913, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/promise.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/promise.ts"],"sourcesContent":["/**\n * A deferred Promise.\n *\n * A deferred Promise is one that can be resolved or rejected independently of\n * the Promise construction.\n * @template Result - The result type of the Promise.\n */\nexport type DeferredPromise<Result = void> = {\n  /**\n   * The Promise that has been deferred.\n   */\n  promise: Promise<Result>;\n  /**\n   * A function that resolves the Promise.\n   */\n  resolve: (result: Result) => void;\n  /**\n   * A function that rejects the Promise.\n   */\n  reject: (error: unknown) => void;\n};\n\n/**\n * Create a defered Promise.\n *\n * If the Promise is rejected prior to a handler being added, this can result in an\n * `UnhandledPromiseRejection` error. Optionally this can be suppressed with the\n * `suppressUnhandledRejection` flag, as it's common to belatedly handle deferred Promises, or to\n * ignore them if they're no longer relevant (e.g. related to a cancelled request).\n *\n * However, be very careful that you have handled the Promise if you do this. Suppressing these\n * errors is dangerous, they exist for good reason. An unhandled rejection can hide errors, making\n * debugging extremely difficult. They should only be suppressed if you're confident that the\n * Promise is always handled correctly, in both the success and failure cases.\n *\n * @param args - The arguments.\n * @param args.suppressUnhandledRejection - This option adds an empty error handler\n * to the Promise to suppress the UnhandledPromiseRejection error. This can be\n * useful if the deferred Promise is sometimes intentionally not used.\n * @returns A deferred Promise.\n * @template Result - The result type of the Promise.\n */\nexport function createDeferredPromise<Result = void>({\n  suppressUnhandledRejection = false,\n}: {\n  suppressUnhandledRejection?: boolean;\n} = {}): DeferredPromise<Result> {\n  let resolve: DeferredPromise<Result>['resolve'];\n  let reject: DeferredPromise<Result>['reject'];\n  const promise = new Promise<Result>(\n    (\n      innerResolve: DeferredPromise<Result>['resolve'],\n      innerReject: DeferredPromise<Result>['reject'],\n    ) => {\n      resolve = innerResolve;\n      reject = innerReject;\n    },\n  );\n\n  if (suppressUnhandledRejection) {\n    promise.catch((_error) => {\n      // This handler is used to suppress the UnhandledPromiseRejection error\n    });\n  }\n\n  // @ts-expect-error We know that these are assigned, but TypeScript doesn't\n  return { promise, resolve, reject };\n}\n"],"names":[],"mappings":";;;;AAsBA;;;;;;;;;;;;;;;;;;;GAmBG,CACH,SAAgB,qBAAqB,CAAgB,EACnD,0BAA0B,GAAG,KAAK,EAAA,GAGhC,CAAA,CAAE;IACJ,IAAI,OAA2C,CAAC;IAChD,IAAI,MAAyC,CAAC;IAC9C,MAAM,OAAO,GAAG,IAAI,OAAO,CACzB,CACE,YAAgD,EAChD,WAA8C,EAC9C,EAAE;QACF,OAAO,GAAG,YAAY,CAAC;QACvB,MAAM,GAAG,WAAW,CAAC;IACvB,CAAC,CACF,CAAC;IAEF,IAAI,0BAA0B,EAAE;QAC9B,OAAO,CAAC,KAAK,CAAC,CAAC,MAAM,EAAE,EAAE;QACvB,uEAAuE;QACzE,CAAC,CAAC,CAAC;KACJ;IAED,2EAA2E;IAC3E,OAAO;QAAE,OAAO;QAAE,OAAO;QAAE,MAAM;IAAA,CAAE,CAAC;AACtC,CAAC;AAzBD,QAAA,qBAAA,GAAA,sBAyBC"}},
    {"offset": {"line": 2960, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/time.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/time.ts"],"sourcesContent":["/**\n * Common duration constants, in milliseconds.\n */\nexport enum Duration {\n  /**\n   * A millisecond.\n   */\n  Millisecond = 1,\n\n  /**\n   * A second, in milliseconds.\n   */\n  Second = 1000, // Millisecond * 1000\n\n  /**\n   * A minute, in milliseconds.\n   */\n  Minute = 60_000, // Second * 60\n\n  /**\n   * An hour, in milliseconds.\n   */\n  Hour = 3_600_000, // Minute * 60\n\n  /**\n   * A day, in milliseconds.\n   */\n  Day = 86_400_000, // Hour * 24\n\n  /**\n   * A week, in milliseconds.\n   */\n  Week = 604_800_000, // Day * 7\n\n  /**\n   * A year, in milliseconds.\n   */\n  Year = 31_536_000_000, // Day * 365\n}\n\nconst isNonNegativeInteger = (number: number) =>\n  Number.isInteger(number) && number >= 0;\n\nconst assertIsNonNegativeInteger = (number: number, name: string) => {\n  if (!isNonNegativeInteger(number)) {\n    throw new Error(\n      `\"${name}\" must be a non-negative integer. Received: \"${number}\".`,\n    );\n  }\n};\n\n/**\n * Calculates the millisecond value of the specified number of units of time.\n *\n * @param count - The number of units of time.\n * @param duration - The unit of time to count.\n * @returns The count multiplied by the specified duration.\n */\nexport function inMilliseconds(count: number, duration: Duration): number {\n  assertIsNonNegativeInteger(count, 'count');\n  return count * duration;\n}\n\n/**\n * Gets the milliseconds since a particular Unix epoch timestamp.\n *\n * @param timestamp - A Unix millisecond timestamp.\n * @returns The number of milliseconds elapsed since the specified timestamp.\n */\nexport function timeSince(timestamp: number): number {\n  assertIsNonNegativeInteger(timestamp, 'timestamp');\n  return Date.now() - timestamp;\n}\n"],"names":[],"mappings":";;;;AAAA;;GAEG,CACH,IAAY,QAmCX;AAnCD,CAAA,SAAY,QAAQ;IAClB;;OAEG,CACH,QAAA,CAAA,QAAA,CAAA,cAAA,GAAA,EAAA,GAAA,aAAe,CAAA;IAEf;;OAEG,CACH,QAAA,CAAA,QAAA,CAAA,SAAA,GAAA,KAAA,GAAA,QAAa,CAAA;IAEb;;OAEG,CACH,QAAA,CAAA,QAAA,CAAA,SAAA,GAAA,MAAA,GAAA,QAAe,CAAA;IAEf;;OAEG,CACH,QAAA,CAAA,QAAA,CAAA,OAAA,GAAA,QAAA,GAAA,MAAgB,CAAA;IAEhB;;OAEG,CACH,QAAA,CAAA,QAAA,CAAA,MAAA,GAAA,SAAA,GAAA,KAAgB,CAAA;IAEhB;;OAEG,CACH,QAAA,CAAA,QAAA,CAAA,OAAA,GAAA,UAAA,GAAA,MAAkB,CAAA;IAElB;;OAEG,CACH,QAAA,CAAA,QAAA,CAAA,OAAA,GAAA,YAAA,GAAA,MAAqB,CAAA;AACvB,CAAC,EAnCW,QAAQ,GAAR,QAAA,QAAQ,IAAA,CAAR,QAAA,QAAQ,GAAA,CAAA,CAAA,GAmCnB;AAED,MAAM,oBAAoB,GAAG,CAAC,MAAc,EAAE,CAC5C,CAD8C,KACxC,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,MAAM,IAAI,CAAC,CAAC;AAE1C,MAAM,0BAA0B,GAAG,CAAC,MAAc,EAAE,IAAY,EAAE,EAAE;IAClE,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,EAAE;QACjC,MAAM,IAAI,KAAK,CACb,CAAA,CAAA,EAAI,IAAI,CAAA,6CAAA,EAAgD,MAAM,CAAA,EAAA,CAAI,CACnE,CAAC;KACH;AACH,CAAC,CAAC;AAEF;;;;;;GAMG,CACH,SAAgB,cAAc,CAAC,KAAa,EAAE,QAAkB;IAC9D,0BAA0B,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;IAC3C,OAAO,KAAK,GAAG,QAAQ,CAAC;AAC1B,CAAC;AAHD,QAAA,cAAA,GAAA,eAGC;AAED;;;;;GAKG,CACH,SAAgB,SAAS,CAAC,SAAiB;IACzC,0BAA0B,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;IACnD,OAAO,IAAI,CAAC,GAAG,EAAE,GAAG,SAAS,CAAC;AAChC,CAAC;AAHD,QAAA,SAAA,GAAA,UAGC"}},
    {"offset": {"line": 3021, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/transaction-types.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/transaction-types.ts"],"sourcesContent":["import type { Bytes } from './bytes';\nimport type { Hex } from './hex';\n\nexport type Transaction =\n  | LegacyTransaction\n  | EIP2930Transaction\n  | EIP1559Transaction;\n\nexport type SignedTransaction = Transaction & Signature;\n\nexport type Signature = {\n  /**\n   * EC signature parameter\n   * 32 bytes long sequence.\n   */\n  r: Bytes;\n\n  /**\n   * EC signature parameter\n   * Signature proof.\n   * 32 bytes long sequence\n   */\n  s: Bytes;\n\n  /**\n   * Recovery identifier. It can be either 0x1b or 0x1c\n   * 1 byte long sequence\n   */\n  yParity: Bytes;\n};\n\n/**\n * Base Ethereum Transaction\n */\nexport type BaseTransaction = {\n  /**\n   * Sequentially incrementing counter which indicates the transaction\n   * number from the account\n   */\n  nonce: Bytes;\n\n  /**\n   * The address of the sender, that will be signing the transaction\n   */\n  from: Hex | Uint8Array;\n\n  /**\n   * The receiving address.\n   * If an externally-owned account, the transaction will transfer value.\n   * If a contract account, the transaction will execute the contract code.\n   */\n  to: Hex | Uint8Array;\n\n  /**\n   * The amount of Ether sent.\n   */\n  value: Bytes;\n\n  /**\n   * Maximum amount of gas units that this transaction can consume.\n   */\n  gasLimit: Bytes;\n\n  /**\n   * Arbitrary data.\n   */\n  data?: Bytes;\n};\n\n/**\n * Typed Ethereum Transaction\n */\nexport type TypedTransaction = BaseTransaction & {\n  /**\n   * Transaction type.\n   */\n  type: number;\n};\n\n/**\n * Ethereum Legacy Transaction\n * Reference: https://ethereum.org/en/developers/docs/transactions/\n */\nexport type LegacyTransaction = BaseTransaction & {\n  /**\n   * Transaction's gas price.\n   */\n  gasPrice: Bytes | null;\n};\n\n/**\n * EIP-2930 Transaction: Optional Access Lists\n * Reference: https://eips.ethereum.org/EIPS/eip-2930\n */\nexport type EIP2930Transaction = TypedTransaction & {\n  /**\n   * Transaction type.\n   */\n  type: 1;\n\n  /**\n   * Transaction chain ID\n   */\n  chainId: Bytes;\n\n  /**\n   * List of addresses and storage keys that the transaction plans to access\n   */\n  accessList:\n    | { address: Hex; storageKeys: Hex[] }[]\n    | { address: Uint8Array; storageKeys: Uint8Array[] }[];\n};\n\n/**\n * EIP-1559 Transaction: Fee market change for ETH 1.0 chain (Type-2)\n *\n * Reference: https://eips.ethereum.org/EIPS/eip-1559\n */\nexport type EIP1559Transaction = TypedTransaction & {\n  /**\n   * Transaction type.\n   */\n  type: 2;\n\n  /**\n   * Maximum fee to give to the miner\n   */\n  maxPriorityFeePerGas: Bytes;\n\n  /**\n   * Maximum total fee\n   */\n  maxFeePerGas: Bytes;\n};\n"],"names":[],"mappings":""}},
    {"offset": {"line": 3028, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/versions.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/versions.ts"],"sourcesContent":["import type { Struct } from '@metamask/superstruct';\nimport { is, refine, string } from '@metamask/superstruct';\nimport {\n  gt as gtSemver,\n  gtr as gtrSemver,\n  satisfies as satisfiesSemver,\n  valid as validSemVerVersion,\n  validRange as validSemVerRange,\n} from 'semver';\n\nimport { assertStruct } from './assert';\nimport type { Opaque } from './opaque';\n\n/**\n * {@link https://codemix.com/opaque-types-in-javascript/ Opaque} type for SemVer ranges.\n *\n * @example Use {@link assertIsSemVerRange} and {@link isValidSemVerRange} to cast to proper type.\n * ```typescript\n * const unsafeRange: string = dataFromUser();\n * assertIsSemVerRange(unsafeRange);\n * unsafeRange\n * // ^? SemVerRange\n * ```\n * @example If you know what you're doing and want to side-step type safety, casting from a string works correctly.\n * ```typescript\n * const unsafeRange: string = dataFromUser();\n * unsafeRange as SemVerRange;\n * // ^? SemVerRange\n * ```\n * @see {@link assertIsSemVerRange}\n * @see {@link isValidSemVerRange}\n */\nexport type SemVerRange = Opaque<string, typeof semVerRange>;\ndeclare const semVerRange: unique symbol;\n\n/**\n * {@link https://codemix.com/opaque-types-in-javascript/ Opaque} type for singular SemVer version.\n *\n * @example Use {@link assertIsSemVerVersion} and {@link isValidSemVerVersion} to cast to proper type.\n * ```typescript\n * const unsafeVersion: string = dataFromUser();\n * assertIsSemVerVersion(unsafeRange);\n * unsafeVersion\n * // ^? SemVerVersion\n * ```\n * @example If you know what you're doing and want to side-step type safety, casting from a string works correctly.\n * ```typescript\n * const unsafeVersion: string = dataFromUser();\n * unsafeRange as SemVerVersion;\n * // ^? SemVerVersion\n * ```\n * @see {@link assertIsSemVerVersion}\n * @see {@link isValidSemVerVersion}\n */\nexport type SemVerVersion = Opaque<string, typeof semVerVersion>;\ndeclare const semVerVersion: unique symbol;\n\n/**\n * A struct for validating a version string.\n */\nexport const VersionStruct = refine<SemVerVersion, null>(\n  string() as unknown as Struct<SemVerVersion, null>,\n  'Version',\n  (value) => {\n    if (validSemVerVersion(value) === null) {\n      return `Expected SemVer version, got \"${value}\"`;\n    }\n    return true;\n  },\n);\n\nexport const VersionRangeStruct = refine<SemVerRange, null>(\n  string() as unknown as Struct<SemVerRange, null>,\n  'Version range',\n  (value) => {\n    if (validSemVerRange(value) === null) {\n      return `Expected SemVer range, got \"${value}\"`;\n    }\n    return true;\n  },\n);\n\n/**\n * Checks whether a SemVer version is valid.\n *\n * @param version - A potential version.\n * @returns `true` if the version is valid, and `false` otherwise.\n */\nexport function isValidSemVerVersion(\n  version: unknown,\n): version is SemVerVersion {\n  return is(version, VersionStruct);\n}\n\n/**\n * Checks whether a SemVer version range is valid.\n *\n * @param versionRange - A potential version range.\n * @returns `true` if the version range is valid, and `false` otherwise.\n */\nexport function isValidSemVerRange(\n  versionRange: unknown,\n): versionRange is SemVerRange {\n  return is(versionRange, VersionRangeStruct);\n}\n\n/**\n * Asserts that a value is a valid concrete SemVer version.\n *\n * @param version - A potential SemVer concrete version.\n */\nexport function assertIsSemVerVersion(\n  version: unknown,\n): asserts version is SemVerVersion {\n  assertStruct(version, VersionStruct);\n}\n\n/**\n * Asserts that a value is a valid SemVer range.\n *\n * @param range - A potential SemVer range.\n */\nexport function assertIsSemVerRange(\n  range: unknown,\n): asserts range is SemVerRange {\n  assertStruct(range, VersionRangeStruct);\n}\n\n/**\n * Checks whether a SemVer version is greater than another.\n *\n * @param version1 - The left-hand version.\n * @param version2 - The right-hand version.\n * @returns `version1 > version2`.\n */\nexport function gtVersion(\n  version1: SemVerVersion,\n  version2: SemVerVersion,\n): boolean {\n  return gtSemver(version1, version2);\n}\n\n/**\n * Checks whether a SemVer version is greater than all possibilities in a range.\n *\n * @param version - A SemvVer version.\n * @param range - The range to check against.\n * @returns `version > range`.\n */\nexport function gtRange(version: SemVerVersion, range: SemVerRange): boolean {\n  return gtrSemver(version, range);\n}\n\n/**\n * Returns whether a SemVer version satisfies a SemVer range.\n *\n * @param version - The SemVer version to check.\n * @param versionRange - The SemVer version range to check against.\n * @returns Whether the version satisfied the version range.\n */\nexport function satisfiesVersionRange(\n  version: SemVerVersion,\n  versionRange: SemVerRange,\n): boolean {\n  return satisfiesSemver(version, versionRange, {\n    includePrerelease: true,\n  });\n}\n"],"names":[],"mappings":";;;;AACA,MAAA,iDAA2D;AAC3D,MAAA,6BAMgB;AAEhB,MAAA,mCAAwC;AA+CxC;;GAEG,CACU,QAAA,aAAa,GAAG,CAAA,GAAA,cAAA,MAAM,EACjC,CAAA,GAAA,cAAA,MAAM,GAA4C,EAClD,SAAS,EACT,CAAC,KAAK,EAAE,EAAE;IACR,IAAI,CAAA,GAAA,SAAA,KAAkB,EAAC,KAAK,CAAC,KAAK,IAAI,EAAE;QACtC,OAAO,CAAA,8BAAA,EAAiC,KAAK,CAAA,CAAA,CAAG,CAAC;KAClD;IACD,OAAO,IAAI,CAAC;AACd,CAAC,CACF,CAAC;AAEW,QAAA,kBAAkB,GAAG,CAAA,GAAA,cAAA,MAAM,EACtC,CAAA,GAAA,cAAA,MAAM,GAA0C,EAChD,eAAe,EACf,CAAC,KAAK,EAAE,EAAE;IACR,IAAI,CAAA,GAAA,SAAA,UAAgB,EAAC,KAAK,CAAC,KAAK,IAAI,EAAE;QACpC,OAAO,CAAA,4BAAA,EAA+B,KAAK,CAAA,CAAA,CAAG,CAAC;KAChD;IACD,OAAO,IAAI,CAAC;AACd,CAAC,CACF,CAAC;AAEF;;;;;GAKG,CACH,SAAgB,oBAAoB,CAClC,OAAgB;IAEhB,OAAO,CAAA,GAAA,cAAA,EAAE,EAAC,OAAO,EAAE,QAAA,aAAa,CAAC,CAAC;AACpC,CAAC;AAJD,QAAA,oBAAA,GAAA,qBAIC;AAED;;;;;GAKG,CACH,SAAgB,kBAAkB,CAChC,YAAqB;IAErB,OAAO,CAAA,GAAA,cAAA,EAAE,EAAC,YAAY,EAAE,QAAA,kBAAkB,CAAC,CAAC;AAC9C,CAAC;AAJD,QAAA,kBAAA,GAAA,mBAIC;AAED;;;;GAIG,CACH,SAAgB,qBAAqB,CACnC,OAAgB;IAEhB,CAAA,GAAA,SAAA,YAAY,EAAC,OAAO,EAAE,QAAA,aAAa,CAAC,CAAC;AACvC,CAAC;AAJD,QAAA,qBAAA,GAAA,sBAIC;AAED;;;;GAIG,CACH,SAAgB,mBAAmB,CACjC,KAAc;IAEd,CAAA,GAAA,SAAA,YAAY,EAAC,KAAK,EAAE,QAAA,kBAAkB,CAAC,CAAC;AAC1C,CAAC;AAJD,QAAA,mBAAA,GAAA,oBAIC;AAED;;;;;;GAMG,CACH,SAAgB,SAAS,CACvB,QAAuB,EACvB,QAAuB;IAEvB,OAAO,CAAA,GAAA,SAAA,EAAQ,EAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;AACtC,CAAC;AALD,QAAA,SAAA,GAAA,UAKC;AAED;;;;;;GAMG,CACH,SAAgB,OAAO,CAAC,OAAsB,EAAE,KAAkB;IAChE,OAAO,CAAA,GAAA,SAAA,GAAS,EAAC,OAAO,EAAE,KAAK,CAAC,CAAC;AACnC,CAAC;AAFD,QAAA,OAAA,GAAA,QAEC;AAED;;;;;;GAMG,CACH,SAAgB,qBAAqB,CACnC,OAAsB,EACtB,YAAyB;IAEzB,OAAO,CAAA,GAAA,SAAA,SAAe,EAAC,OAAO,EAAE,YAAY,EAAE;QAC5C,iBAAiB,EAAE,IAAI;KACxB,CAAC,CAAC;AACL,CAAC;AAPD,QAAA,qBAAA,GAAA,sBAOC"}},
    {"offset": {"line": 3119, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/unitsConversion.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/unitsConversion.ts"],"sourcesContent":["/* eslint-disable operator-assignment */\n/*\nPrimary Attribution\nRichard Moore <ricmoo@me.com>\nhttps://github.com/ethers-io\n\nNote, Richard is a god of ether gods. Follow and respect him, and use Ethers.io!\n*/\n\nconst zero = BigInt(0);\nconst negative1 = BigInt(-1);\n\n/**\n * Converts a string, number, or bigint to a bigint.\n *\n * @param arg - The value to convert to bigint.\n * @returns The bigint representation of the input.\n * @throws Error if the input type cannot be converted to bigint.\n */\nexport function numericToBigInt(arg: string | number | bigint): bigint {\n  if (typeof arg === 'string') {\n    return BigInt(arg);\n  }\n  if (typeof arg === 'number') {\n    return BigInt(arg);\n  }\n  if (typeof arg === 'bigint') {\n    return arg;\n  }\n\n  throw new Error(`Cannot convert ${typeof arg} to BigInt`);\n}\n\n// complete ethereum unit map\nexport const unitMap = {\n  noether: '0',\n  wei: '1',\n  kwei: '1000',\n  Kwei: '1000',\n  babbage: '1000',\n  femtoether: '1000',\n  mwei: '1000000',\n  Mwei: '1000000',\n  lovelace: '1000000',\n  picoether: '1000000',\n  gwei: '1000000000',\n  Gwei: '1000000000',\n  shannon: '1000000000',\n  nanoether: '1000000000',\n  nano: '1000000000',\n  szabo: '1000000000000',\n  microether: '1000000000000',\n  micro: '1000000000000',\n  finney: '1000000000000000',\n  milliether: '1000000000000000',\n  milli: '1000000000000000',\n  ether: '1000000000000000000',\n  kether: '1000000000000000000000',\n  grand: '1000000000000000000000',\n  mether: '1000000000000000000000000',\n  gether: '1000000000000000000000000000',\n  tether: '1000000000000000000000000000000',\n} as const;\n\n// Pre-computed unit values as BigInt for performance\nconst unitMapBigInt = Object.fromEntries(\n  Object.entries(unitMap).map(([key, value]) => [key, BigInt(value)]),\n) as Record<EthereumUnit, bigint>;\n\nconst unitLengths = Object.fromEntries(\n  Object.entries(unitMap).map(([key, value]) => [key, value.length - 1 || 1]),\n) as Record<EthereumUnit, number>;\n\nconst NUMBER_REGEX = /^-?[0-9.]+$/u;\nconst FRACTION_REGEX = /^([0-9]*[1-9]|0)(0*)/u;\nconst COMMIFY_REGEX = /\\B(?=(\\d{3})+(?!\\d))/gu;\n\ntype EthereumUnit = keyof typeof unitMap;\n\n/**\n * Returns value of unit in Wei.\n *\n * @param unitInput - The unit to convert to, default ether.\n * @returns Value of the unit (in Wei).\n * @throws Error if the unit is not correct.\n */\nexport function getValueOfUnit(unitInput: EthereumUnit = 'ether'): bigint {\n  const unit = unitInput.toLowerCase() as EthereumUnit;\n  const unitValue = unitMapBigInt[unit];\n\n  if (unitValue === undefined) {\n    throw new Error(\n      `The unit provided ${unitInput} doesn't exist, please use the one of the following units ${JSON.stringify(\n        unitMap,\n        null,\n        2,\n      )}`,\n    );\n  }\n\n  return unitValue;\n}\n\n/**\n * Converts a number to a string.\n *\n * @param arg - The number to convert to a string.\n * @returns The string representation of the number.\n * @throws Error if the number is invalid.\n */\nexport function numberToString(arg: string | number | bigint) {\n  if (typeof arg === 'string') {\n    if (!NUMBER_REGEX.test(arg)) {\n      throw new Error(\n        `while converting number to string, invalid number value '${arg}', should be a number matching (^-?[0-9.]+).`,\n      );\n    }\n    return arg;\n  }\n  if (typeof arg === 'number') {\n    return String(arg);\n  }\n  if (typeof arg === 'bigint') {\n    return arg.toString();\n  }\n  throw new Error(\n    `while converting number to string, invalid number value '${String(\n      arg,\n    )}' type ${typeof arg}.`,\n  );\n}\n\n/**\n * Converts a number from Wei to a string.\n *\n * @param weiInput - The number to convert from Wei.\n * @param unit - The unit to convert to, default ether.\n * @param optionsInput - The options to use for the conversion.\n * @param optionsInput.pad - Whether to pad the fractional part with zeros.\n * @param optionsInput.commify - Whether to add commas to separate thousands.\n * @returns The string representation of the number.\n * @throws Error if the number is invalid.\n */\nexport function fromWei(\n  weiInput: string | number | bigint,\n  unit: EthereumUnit,\n  optionsInput?: { pad?: boolean; commify?: boolean },\n) {\n  let wei = numericToBigInt(weiInput);\n  const negative = wei < zero;\n  const unitLower = unit.toLowerCase() as EthereumUnit;\n  const base = unitMapBigInt[unitLower];\n  const baseLength = unitLengths[unitLower];\n  const options = optionsInput ?? {};\n\n  if (base === undefined) {\n    throw new Error(\n      `The unit provided ${unit} doesn't exist, please use the one of the following units ${JSON.stringify(\n        unitMap,\n        null,\n        2,\n      )}`,\n    );\n  }\n\n  // Handle special case of noether (base = 0)\n  if (base === zero) {\n    return negative ? '-0' : '0';\n  }\n\n  if (negative) {\n    wei = wei * negative1;\n  }\n\n  let fraction = (wei % base).toString();\n\n  fraction = fraction.padStart(baseLength, '0');\n\n  if (!options.pad) {\n    const fractionMatch = fraction.match(FRACTION_REGEX);\n    // istanbul ignore next: defensive fallback that's never reachable but necessary to satisfy TS\n    fraction = fractionMatch?.[1] ?? '0';\n  }\n\n  let whole = (wei / base).toString();\n\n  if (options.commify) {\n    whole = whole.replace(COMMIFY_REGEX, ',');\n  }\n\n  let value = `${whole}${fraction === '0' ? '' : `.${fraction}`}`;\n\n  if (negative) {\n    value = `-${value}`;\n  }\n\n  return value;\n}\n\n/**\n * Converts a number to Wei.\n *\n * @param etherInput - The number to convert to Wei.\n * @param unit - The unit to convert to, default ether.\n * @returns The number in Wei.\n * @throws Error if the number is invalid.\n */\nexport function toWei(\n  etherInput: string | number | bigint,\n  unit: EthereumUnit,\n): bigint {\n  const unitLower = unit.toLowerCase() as EthereumUnit;\n  const base = unitMapBigInt[unitLower];\n  const baseLength = unitLengths[unitLower];\n\n  if (base === undefined) {\n    throw new Error(\n      `The unit provided ${unit} doesn't exist, please use the one of the following units ${JSON.stringify(\n        unitMap,\n        null,\n        2,\n      )}`,\n    );\n  }\n\n  // Handle special case of noether (base = 0)\n  if (base === zero) {\n    return zero;\n  }\n\n  // Fast path for bigint inputs when unit is wei (no conversion needed)\n  if (typeof etherInput === 'bigint' && unitLower === 'wei') {\n    return etherInput;\n  }\n\n  // Fast path for bigint inputs with whole units (no fractional part)\n  if (typeof etherInput === 'bigint') {\n    return etherInput * base;\n  }\n\n  let ether = numberToString(etherInput);\n\n  // Is it negative?\n  const negative = ether.startsWith('-');\n  if (negative) {\n    ether = ether.substring(1);\n  }\n\n  if (ether === '.') {\n    throw new Error(\n      `While converting number ${etherInput} to wei, invalid value`,\n    );\n  }\n\n  // Split it into a whole and fractional part\n  const comps = ether.split('.');\n  if (comps.length > 2) {\n    throw new Error(\n      `While converting number ${etherInput} to wei,  too many decimal points`,\n    );\n  }\n\n  let whole = comps[0];\n  let fraction = comps[1];\n\n  if (!whole) {\n    whole = '0';\n  }\n  if (!fraction) {\n    fraction = '0';\n  }\n  if (fraction.length > baseLength) {\n    throw new Error(\n      `While converting number ${etherInput} to wei, too many decimal places`,\n    );\n  }\n\n  fraction = fraction.padEnd(baseLength, '0');\n\n  const wholeBigInt = BigInt(whole);\n  const fractionBigInt = BigInt(fraction);\n  let wei = wholeBigInt * base + fractionBigInt;\n\n  if (negative) {\n    wei = wei * negative1;\n  }\n\n  return wei;\n}\n"],"names":[],"mappings":"AAAA,sCAAA,EAAwC,CACxC;;;;;;EAME;;;;AAEF,MAAM,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;AACvB,MAAM,SAAS,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;AAE7B;;;;;;GAMG,CACH,SAAgB,eAAe,CAAC,GAA6B;IAC3D,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;QAC3B,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;KACpB;IACD,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;QAC3B,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;KACpB;IACD,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;QAC3B,OAAO,GAAG,CAAC;KACZ;IAED,MAAM,IAAI,KAAK,CAAC,CAAA,eAAA,EAAkB,OAAO,GAAG,CAAA,UAAA,CAAY,CAAC,CAAC;AAC5D,CAAC;AAZD,QAAA,eAAA,GAAA,gBAYC;AAED,6BAA6B;AAChB,QAAA,OAAO,GAAG;IACrB,OAAO,EAAE,GAAG;IACZ,GAAG,EAAE,GAAG;IACR,IAAI,EAAE,MAAM;IACZ,IAAI,EAAE,MAAM;IACZ,OAAO,EAAE,MAAM;IACf,UAAU,EAAE,MAAM;IAClB,IAAI,EAAE,SAAS;IACf,IAAI,EAAE,SAAS;IACf,QAAQ,EAAE,SAAS;IACnB,SAAS,EAAE,SAAS;IACpB,IAAI,EAAE,YAAY;IAClB,IAAI,EAAE,YAAY;IAClB,OAAO,EAAE,YAAY;IACrB,SAAS,EAAE,YAAY;IACvB,IAAI,EAAE,YAAY;IAClB,KAAK,EAAE,eAAe;IACtB,UAAU,EAAE,eAAe;IAC3B,KAAK,EAAE,eAAe;IACtB,MAAM,EAAE,kBAAkB;IAC1B,UAAU,EAAE,kBAAkB;IAC9B,KAAK,EAAE,kBAAkB;IACzB,KAAK,EAAE,qBAAqB;IAC5B,MAAM,EAAE,wBAAwB;IAChC,KAAK,EAAE,wBAAwB;IAC/B,MAAM,EAAE,2BAA2B;IACnC,MAAM,EAAE,8BAA8B;IACtC,MAAM,EAAE,iCAAiC;CACjC,CAAC;AAEX,qDAAqD;AACrD,MAAM,aAAa,GAAG,MAAM,CAAC,WAAW,CACtC,MAAM,CAAC,OAAO,CAAC,QAAA,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,CAAG,CAAD;QAAE,GAAG;QAAE,MAAM,CAAC,KAAK,CAAC;KAAC,CAAC,CACpC,CAAC;AAElC,MAAM,WAAW,GAAG,MAAM,CAAC,WAAW,CACpC,MAAM,CAAC,OAAO,CAAC,QAAA,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,CAAG,CAAD;QAAE,GAAG;QAAE,KAAK,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC;KAAC,CAAC,CAC5C,CAAC;AAElC,MAAM,YAAY,GAAG,cAAc,CAAC;AACpC,MAAM,cAAc,GAAG,uBAAuB,CAAC;AAC/C,MAAM,aAAa,GAAG,wBAAwB,CAAC;AAI/C;;;;;;GAMG,CACH,SAAgB,cAAc,CAAC,YAA0B,OAAO;IAC9D,MAAM,IAAI,GAAG,SAAS,CAAC,WAAW,EAAkB,CAAC;IACrD,MAAM,SAAS,GAAG,aAAa,CAAC,IAAI,CAAC,CAAC;IAEtC,IAAI,SAAS,KAAK,SAAS,EAAE;QAC3B,MAAM,IAAI,KAAK,CACb,CAAA,kBAAA,EAAqB,SAAS,CAAA,0DAAA,EAA6D,IAAI,CAAC,SAAS,CACvG,QAAA,OAAO,EACP,IAAI,EACJ,CAAC,CACF,EAAE,CACJ,CAAC;KACH;IAED,OAAO,SAAS,CAAC;AACnB,CAAC;AAfD,QAAA,cAAA,GAAA,eAeC;AAED;;;;;;GAMG,CACH,SAAgB,cAAc,CAAC,GAA6B;IAC1D,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;QAC3B,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE;YAC3B,MAAM,IAAI,KAAK,CACb,CAAA,yDAAA,EAA4D,GAAG,CAAA,4CAAA,CAA8C,CAC9G,CAAC;SACH;QACD,OAAO,GAAG,CAAC;KACZ;IACD,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;QAC3B,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;KACpB;IACD,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;QAC3B,OAAO,GAAG,CAAC,QAAQ,EAAE,CAAC;KACvB;IACD,MAAM,IAAI,KAAK,CACb,CAAA,yDAAA,EAA4D,MAAM,CAChE,GAAG,CACJ,CAAA,OAAA,EAAU,OAAO,GAAG,CAAA,CAAA,CAAG,CACzB,CAAC;AACJ,CAAC;AApBD,QAAA,cAAA,GAAA,eAoBC;AAED;;;;;;;;;;GAUG,CACH,SAAgB,OAAO,CACrB,QAAkC,EAClC,IAAkB,EAClB,YAAmD;IAEnD,IAAI,GAAG,GAAG,eAAe,CAAC,QAAQ,CAAC,CAAC;IACpC,MAAM,QAAQ,GAAG,GAAG,GAAG,IAAI,CAAC;IAC5B,MAAM,SAAS,GAAG,IAAI,CAAC,WAAW,EAAkB,CAAC;IACrD,MAAM,IAAI,GAAG,aAAa,CAAC,SAAS,CAAC,CAAC;IACtC,MAAM,UAAU,GAAG,WAAW,CAAC,SAAS,CAAC,CAAC;IAC1C,MAAM,OAAO,GAAG,YAAY,IAAI,CAAA,CAAE,CAAC;IAEnC,IAAI,IAAI,KAAK,SAAS,EAAE;QACtB,MAAM,IAAI,KAAK,CACb,CAAA,kBAAA,EAAqB,IAAI,CAAA,0DAAA,EAA6D,IAAI,CAAC,SAAS,CAClG,QAAA,OAAO,EACP,IAAI,EACJ,CAAC,CACF,EAAE,CACJ,CAAC;KACH;IAED,4CAA4C;IAC5C,IAAI,IAAI,KAAK,IAAI,EAAE;QACjB,OAAO,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC;KAC9B;IAED,IAAI,QAAQ,EAAE;QACZ,GAAG,GAAG,GAAG,GAAG,SAAS,CAAC;KACvB;IAED,IAAI,QAAQ,GAAG,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC,QAAQ,EAAE,CAAC;IAEvC,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC;IAE9C,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE;QAChB,MAAM,aAAa,GAAG,QAAQ,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC;QACrD,8FAA8F;QAC9F,QAAQ,GAAG,aAAa,EAAE,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC;KACtC;IAED,IAAI,KAAK,GAAG,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC,QAAQ,EAAE,CAAC;IAEpC,IAAI,OAAO,CAAC,OAAO,EAAE;QACnB,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,aAAa,EAAE,GAAG,CAAC,CAAC;KAC3C;IAED,IAAI,KAAK,GAAG,GAAG,KAAK,GAAG,QAAQ,KAAK,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAA,CAAA,EAAI,QAAQ,EAAE,EAAE,CAAC;IAEhE,IAAI,QAAQ,EAAE;QACZ,KAAK,GAAG,CAAA,CAAA,EAAI,KAAK,EAAE,CAAC;KACrB;IAED,OAAO,KAAK,CAAC;AACf,CAAC;AAtDD,QAAA,OAAA,GAAA,QAsDC;AAED;;;;;;;GAOG,CACH,SAAgB,KAAK,CACnB,UAAoC,EACpC,IAAkB;IAElB,MAAM,SAAS,GAAG,IAAI,CAAC,WAAW,EAAkB,CAAC;IACrD,MAAM,IAAI,GAAG,aAAa,CAAC,SAAS,CAAC,CAAC;IACtC,MAAM,UAAU,GAAG,WAAW,CAAC,SAAS,CAAC,CAAC;IAE1C,IAAI,IAAI,KAAK,SAAS,EAAE;QACtB,MAAM,IAAI,KAAK,CACb,CAAA,kBAAA,EAAqB,IAAI,CAAA,0DAAA,EAA6D,IAAI,CAAC,SAAS,CAClG,QAAA,OAAO,EACP,IAAI,EACJ,CAAC,CACF,EAAE,CACJ,CAAC;KACH;IAED,4CAA4C;IAC5C,IAAI,IAAI,KAAK,IAAI,EAAE;QACjB,OAAO,IAAI,CAAC;KACb;IAED,sEAAsE;IACtE,IAAI,OAAO,UAAU,KAAK,QAAQ,IAAI,SAAS,KAAK,KAAK,EAAE;QACzD,OAAO,UAAU,CAAC;KACnB;IAED,oEAAoE;IACpE,IAAI,OAAO,UAAU,KAAK,QAAQ,EAAE;QAClC,OAAO,UAAU,GAAG,IAAI,CAAC;KAC1B;IAED,IAAI,KAAK,GAAG,cAAc,CAAC,UAAU,CAAC,CAAC;IAEvC,kBAAkB;IAClB,MAAM,QAAQ,GAAG,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;IACvC,IAAI,QAAQ,EAAE;QACZ,KAAK,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;KAC5B;IAED,IAAI,KAAK,KAAK,GAAG,EAAE;QACjB,MAAM,IAAI,KAAK,CACb,CAAA,wBAAA,EAA2B,UAAU,CAAA,sBAAA,CAAwB,CAC9D,CAAC;KACH;IAED,4CAA4C;IAC5C,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAC/B,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;QACpB,MAAM,IAAI,KAAK,CACb,CAAA,wBAAA,EAA2B,UAAU,CAAA,iCAAA,CAAmC,CACzE,CAAC;KACH;IAED,IAAI,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IACrB,IAAI,QAAQ,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IAExB,IAAI,CAAC,KAAK,EAAE;QACV,KAAK,GAAG,GAAG,CAAC;KACb;IACD,IAAI,CAAC,QAAQ,EAAE;QACb,QAAQ,GAAG,GAAG,CAAC;KAChB;IACD,IAAI,QAAQ,CAAC,MAAM,GAAG,UAAU,EAAE;QAChC,MAAM,IAAI,KAAK,CACb,CAAA,wBAAA,EAA2B,UAAU,CAAA,gCAAA,CAAkC,CACxE,CAAC;KACH;IAED,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC;IAE5C,MAAM,WAAW,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC;IAClC,MAAM,cAAc,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;IACxC,IAAI,GAAG,GAAG,WAAW,GAAG,IAAI,GAAG,cAAc,CAAC;IAE9C,IAAI,QAAQ,EAAE;QACZ,GAAG,GAAG,GAAG,GAAG,SAAS,CAAC;KACvB;IAED,OAAO,GAAG,CAAC;AACb,CAAC;AAjFD,QAAA,KAAA,GAAA,MAiFC"}},
    {"offset": {"line": 3339, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40metamask/abi-utils/node_modules/%40metamask/utils/src/index.ts"],"sourcesContent":["export * from './assert';\nexport * from './base64';\nexport * from './bytes';\nexport * from './caip-types';\nexport * from './checksum';\nexport * from './coercers';\nexport * from './collections';\nexport * from './encryption-types';\nexport * from './errors';\nexport * from './hashing';\nexport type { Hex } from './hex';\nexport {\n  HexStruct,\n  StrictHexStruct,\n  HexAddressStruct,\n  HexChecksumAddressStruct,\n  isHexString,\n  isStrictHexString,\n  isHexAddress,\n  isHexChecksumAddress,\n  assertIsHexString,\n  assertIsStrictHexString,\n  isValidHexAddress,\n  getChecksumAddress,\n  isValidChecksumAddress,\n  add0x,\n  remove0x,\n} from './hex';\nexport * from './json';\nexport * from './keyring';\nexport * from './logging';\nexport * from './misc';\nexport * from './number';\nexport * from './opaque';\nexport * from './promise';\nexport * from './superstruct';\nexport * from './time';\nexport * from './transaction-types';\nexport * from './versions';\nexport {\n  toWei,\n  fromWei,\n  numberToString,\n  getValueOfUnit,\n  unitMap,\n} from './unitsConversion';\n"],"names":[],"mappings":"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"}}]
}