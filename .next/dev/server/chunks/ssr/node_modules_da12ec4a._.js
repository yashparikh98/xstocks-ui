module.exports = [
"[project]/node_modules/@web3auth/no-modal/dist/lib.esm/providers/account-abstraction-provider/index.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
;
}),
"[project]/node_modules/@web3auth/no-modal/dist/lib.esm/providers/account-abstraction-provider/rpc/ethRpcMiddlewares.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createAaMiddleware",
    ()=>createAaMiddleware,
    "createEoaMiddleware",
    ()=>createEoaMiddleware,
    "providerAsMiddleware",
    ()=>providerAsMiddleware
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/utils/constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$jrpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3auth/no-modal/node_modules/@web3auth/auth/dist/lib.esm/jrpc/jrpc.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$errors$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3auth/no-modal/node_modules/@web3auth/auth/dist/lib.esm/jrpc/errors/errors.js [app-ssr] (ecmascript)");
;
;
;
async function createAaMiddleware({ eoaProvider, handlers }) {
    const [eoaAddress] = await eoaProvider.request({
        method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["METHOD_TYPES"].GET_ACCOUNTS
    });
    /**
   * Validates the keyholder address, and returns a normalized (i.e. lowercase)
   * copy of it.
   *
   * an error
   */ async function validateAndNormalizeKeyholder(address, req) {
        if (typeof address === "string" && address.length > 0) {
            // ensure address is included in provided accounts
            const accounts = await handlers.getAccounts(req);
            const normalizedAccounts = accounts.map((_address)=>_address.toLowerCase());
            const normalizedAddress = address.toLowerCase();
            if (normalizedAccounts.includes(normalizedAddress)) {
                return normalizedAddress;
            }
        }
        throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$errors$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpcErrors"].invalidParams({
            message: `Invalid parameters: must provide an Ethereum address.`
        });
    }
    async function normalizeSignSenderAddress(address, req) {
        // sender is EOA address
        if (address.toLowerCase() === eoaAddress.toLowerCase()) {
            return eoaAddress;
        }
        const [smartAccountAddress] = await handlers.getAccounts(req);
        // sender is smart account address
        if (address.toLowerCase() === smartAccountAddress.toLowerCase()) {
            // use EOA address as sender for signing
            return eoaAddress;
        }
        throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$errors$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpcErrors"].invalidParams({
            message: `Invalid parameters: must provide valid sender address.`
        });
    }
    async function lookupAccounts(req, res) {
        res.result = await handlers.getAccounts(req);
    }
    async function fetchPrivateKey(req, res) {
        if (!handlers.getPrivateKey) {
            throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$errors$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpcErrors"].methodNotSupported();
        }
        res.result = await handlers.getPrivateKey(req);
    }
    async function sendTransaction(req, res) {
        if (!handlers.processTransaction) {
            throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$errors$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpcErrors"].methodNotSupported();
        }
        const txParams = req.params[0] || {
            from: ""
        };
        txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
        res.result = handlers.processTransaction(txParams, req);
    }
    async function signTransaction(req, res) {
        const txParams = req.params[0] || {
            from: ""
        };
        // normalize sender address
        if (txParams.from) {
            txParams.from = await normalizeSignSenderAddress(txParams.from, req);
        }
        res.result = await handlers.processSignTransaction(txParams, req);
    }
    async function ethSign(req, res) {
        let msgParams = req.params;
        const extraParams = req.params[2] || {};
        if (Array.isArray(req.params)) {
            if (!(req.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${req.method} method. expected [address, message]`);
            const params = req.params;
            const address = params[0];
            const message = params[1];
            msgParams = {
                from: address,
                data: message
            };
        }
        msgParams = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, extraParams), msgParams);
        res.result = await handlers.processEthSignMessage(msgParams, req);
    }
    async function signTypedDataV4(req, res) {
        if (!(req !== null && req !== void 0 && req.params)) throw new Error("WalletMiddleware - missing params");
        let msgParams = req.params;
        if (Array.isArray(req.params)) {
            if (!(req.params.length === 2)) throw new Error(`WalletMiddleware - incorrect params for ${req.method} method. expected [address, typedData]`);
            const params = req.params;
            const address = params[0];
            const message = params[1];
            msgParams = {
                from: address,
                data: message
            };
        }
        res.result = await handlers.processTypedMessageV4(msgParams, req);
    }
    async function personalSign(req, res) {
        let msgParams = req.params;
        const extraParams = req.params[2] || {};
        if (Array.isArray(req.params)) {
            if (!(req.params.length >= 2)) throw new Error(`WalletMiddleware - incorrect params for ${req.method} method. expected [message, address]`);
            const params = req.params;
            if (typeof params[0] === "object") {
                const { challenge, address } = params[0];
                msgParams = {
                    from: address,
                    data: challenge
                };
            } else {
                const message = params[0];
                const address = params[1];
                msgParams = {
                    from: address,
                    data: message
                };
            }
        }
        msgParams = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, extraParams), msgParams);
        res.result = await handlers.processPersonalMessage(msgParams, req);
    }
    async function fetchPublicKey(req, res) {
        if (!handlers.getPublicKey) {
            throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$errors$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rpcErrors"].methodNotSupported();
        }
        res.result = await handlers.getPublicKey(req);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$jrpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createScaffoldMiddleware"])({
        // account lookups
        eth_accounts: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$jrpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createAsyncMiddleware"])(lookupAccounts),
        eth_requestAccounts: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$jrpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createAsyncMiddleware"])(lookupAccounts),
        eth_private_key: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$jrpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createAsyncMiddleware"])(fetchPrivateKey),
        private_key: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$jrpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createAsyncMiddleware"])(fetchPrivateKey),
        eth_public_key: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$jrpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createAsyncMiddleware"])(fetchPublicKey),
        public_key: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$jrpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createAsyncMiddleware"])(fetchPublicKey),
        // tx signatures
        eth_sendTransaction: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$jrpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createAsyncMiddleware"])(sendTransaction),
        eth_signTransaction: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$jrpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createAsyncMiddleware"])(signTransaction),
        // message signatures
        eth_sign: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$jrpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createAsyncMiddleware"])(ethSign),
        eth_signTypedData_v4: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$jrpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createAsyncMiddleware"])(signTypedDataV4),
        personal_sign: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$jrpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createAsyncMiddleware"])(personalSign)
    });
}
async function createEoaMiddleware({ aaProvider }) {
    async function getAccounts(_req, res) {
        const [, eoaAddress] = await aaProvider.request({
            method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["METHOD_TYPES"].GET_ACCOUNTS
        });
        res.result = [
            eoaAddress
        ];
    }
    async function requestAccounts(_req, res) {
        const [, eoaAddress] = await aaProvider.request({
            method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["METHOD_TYPES"].ETH_REQUEST_ACCOUNTS
        });
        res.result = [
            eoaAddress
        ];
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$jrpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createScaffoldMiddleware"])({
        eth_accounts: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$jrpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createAsyncMiddleware"])(getAccounts),
        eth_requestAccounts: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$jrpc$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createAsyncMiddleware"])(requestAccounts)
    });
}
function providerAsMiddleware(provider) {
    return async (req, res, _next, end)=>{
        // send request to provider
        try {
            const providerRes = await provider.request(req);
            res.result = providerRes;
            return end();
        } catch (error) {
            return end(error);
        }
    };
}
;
}),
"[project]/node_modules/@web3auth/no-modal/dist/lib.esm/providers/account-abstraction-provider/providers/utils.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getProviderHandlers",
    ()=>getProviderHandlers
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$internal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/internal.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/bytes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$errors$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3auth/no-modal/node_modules/@web3auth/auth/dist/lib.esm/jrpc/errors/errors.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createWalletClient$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/createWalletClient.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$http$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/transports/http.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$dist$2f$lib$2e$esm$2f$base$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3auth/no-modal/dist/lib.esm/base/loglevel.js [app-ssr] (ecmascript)");
;
;
;
;
;
function getProviderHandlers({ bundlerClient, smartAccount, chain, eoaProvider }) {
    const walletClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createWalletClient$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createWalletClient"])({
        account: smartAccount,
        chain,
        transport: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$http$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["http"])()
    });
    return {
        getAccounts: async (_)=>{
            const [smartAccounts, eoaAccounts] = await Promise.all([
                smartAccount.getAddress(),
                eoaProvider.request({
                    method: "eth_accounts"
                })
            ]);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$dist$2f$lib$2e$esm$2f$base$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["log"].info("smartAccounts", smartAccounts);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$dist$2f$lib$2e$esm$2f$base$2f$loglevel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["log"].info("eoaAccounts", eoaAccounts);
            return [
                smartAccounts,
                ...eoaAccounts
            ];
        },
        getPrivateKey: async (_)=>{
            throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$errors$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["providerErrors"].custom({
                message: "Smart accounts do not have private key",
                code: 4903
            });
        },
        getPublicKey: async (_)=>{
            throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$errors$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["providerErrors"].custom({
                message: "Smart accounts do not have a public key. Use address instead.",
                code: 4903
            });
        },
        processTransaction: async (txParams)=>{
            if (txParams.input && !txParams.data) txParams.data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addHexPrefix"])(txParams.input);
            const { to, value, data } = txParams;
            // @ts-expect-error viem types are too deep
            const userOperationParams = {
                account: smartAccount,
                calls: [
                    {
                        to,
                        // Explicit conversation required to avoid value being passed as hex
                        value: BigInt(value),
                        data
                    }
                ]
            };
            const userOpHash = await bundlerClient.sendUserOperation(userOperationParams);
            const txReceipt = await bundlerClient.waitForUserOperationReceipt({
                hash: userOpHash
            });
            if (!txReceipt.success) {
                throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$errors$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["providerErrors"].custom({
                    message: txReceipt.reason,
                    code: 4905
                });
            }
            return txReceipt.receipt.transactionHash;
        },
        processSignTransaction: async (txParams)=>{
            const { to, value, data } = txParams;
            const request = await bundlerClient.prepareUserOperation({
                account: smartAccount,
                calls: [
                    {
                        to,
                        value: BigInt(value),
                        data
                    }
                ]
            });
            const signature = await smartAccount.signUserOperation({
                callData: request.callData,
                callGasLimit: request.callGasLimit,
                maxFeePerGas: request.maxFeePerGas,
                maxPriorityFeePerGas: request.maxPriorityFeePerGas,
                nonce: request.nonce,
                preVerificationGas: request.preVerificationGas,
                verificationGasLimit: request.verificationGasLimit,
                signature: request.signature
            });
            return signature;
        },
        processEthSignMessage: async (_, req)=>{
            return eoaProvider.request(req);
        },
        processPersonalMessage: async (msgParams, _)=>{
            const message = msgParams.data;
            return walletClient.signMessage({
                account: smartAccount,
                message: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$internal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isHexString"])(message) ? {
                    raw: message
                } : message
            });
        },
        processTypedMessageV4: async (msgParams, _)=>{
            try {
                const data = typeof msgParams.data === "string" ? JSON.parse(msgParams.data) : msgParams.data;
                const signature = await walletClient.signTypedData({
                    account: smartAccount,
                    domain: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, data.domain), {}, {
                        verifyingContract: data.domain.verifyingContract,
                        salt: data.domain.salt,
                        chainId: Number(data.domain.chainId)
                    }),
                    primaryType: data.primaryType,
                    types: data.types,
                    message: data.message
                });
                return signature;
            } catch (error) {
                throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$errors$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["providerErrors"].custom({
                    message: error instanceof Error ? error.message : "Failed to sign typed data",
                    code: 4905
                });
            }
        }
    };
}
;
}),
"[project]/node_modules/@web3auth/no-modal/dist/lib.esm/providers/account-abstraction-provider/providers/AccountAbstractionProvider.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "accountAbstractionProvider",
    ()=>accountAbstractionProvider,
    "toEoaProvider",
    ()=>toEoaProvider
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/utils/constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$jrpcEngine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3auth/no-modal/node_modules/@web3auth/auth/dist/lib.esm/jrpc/jrpcEngine.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$errors$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3auth/no-modal/node_modules/@web3auth/auth/dist/lib.esm/jrpc/errors/errors.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/utils/chain/defineChain.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createPublicClient$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/createPublicClient.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$http$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/transports/http.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createWalletClient$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/createWalletClient.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$custom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/clients/transports/custom.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$account$2d$abstraction$2f$clients$2f$createPaymasterClient$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/account-abstraction/clients/createPaymasterClient.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$account$2d$abstraction$2f$clients$2f$createBundlerClient$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/account-abstraction/clients/createBundlerClient.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$dist$2f$lib$2e$esm$2f$providers$2f$account$2d$abstraction$2d$provider$2f$rpc$2f$ethRpcMiddlewares$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3auth/no-modal/dist/lib.esm/providers/account-abstraction-provider/rpc/ethRpcMiddlewares.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$dist$2f$lib$2e$esm$2f$providers$2f$account$2d$abstraction$2d$provider$2f$providers$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3auth/no-modal/dist/lib.esm/providers/account-abstraction-provider/providers/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$dist$2f$lib$2e$esm$2f$providers$2f$base$2d$provider$2f$baseProvider$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3auth/no-modal/dist/lib.esm/providers/base-provider/baseProvider.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3auth/no-modal/node_modules/@toruslabs/base-controllers/dist/lib.esm/Network/INetworkController.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$dist$2f$lib$2e$esm$2f$base$2f$errors$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3auth/no-modal/dist/lib.esm/base/errors/index.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
var _AccountAbstractionProvider;
class AccountAbstractionProvider extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$dist$2f$lib$2e$esm$2f$providers$2f$base$2d$provider$2f$baseProvider$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseProvider"] {
    constructor({ config, state }){
        super({
            config,
            state
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "PROVIDER_CHAIN_NAMESPACE", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CHAIN_NAMESPACES"].EIP155);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "_smartAccount", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "_publicClient", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "_bundlerClient", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "_paymasterClient", void 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "_useProviderAsTransport", void 0);
        this.update({
            chainId: config.chain.chainId
        });
    }
    get smartAccount() {
        return this._smartAccount;
    }
    get bundlerClient() {
        return this._bundlerClient;
    }
    get paymasterClient() {
        return this._paymasterClient;
    }
    get publicClient() {
        return this._publicClient;
    }
    async enable() {
        if (!this.state.eoaProvider) throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$errors$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["providerErrors"].custom({
            message: "eoaProvider is not found in state, please pass it",
            code: 4902
        });
        await this.setupProvider(this.state.eoaProvider);
        return this._providerEngineProxy.request({
            method: "eth_accounts"
        });
    }
    async setupProvider(eoaProvider) {
        var _bundlerConfig$transp;
        const { currentChain } = this;
        const { chainNamespace } = currentChain;
        if (chainNamespace !== this.PROVIDER_CHAIN_NAMESPACE) throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$dist$2f$lib$2e$esm$2f$base$2f$errors$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WalletInitializationError"].incompatibleChainNameSpace("Invalid chain namespace");
        const bundlerAndPaymasterConfig = this.config.smartAccountChainsConfig.find((config)=>config.chainId === currentChain.chainId);
        if (!bundlerAndPaymasterConfig) throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$dist$2f$lib$2e$esm$2f$base$2f$errors$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WalletInitializationError"].invalidProviderConfigError(`Bundler and paymaster config not found for chain ${currentChain.chainId}`);
        const { bundlerConfig, paymasterConfig } = bundlerAndPaymasterConfig;
        const chain = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["defineChain"])({
            id: Number.parseInt(currentChain.chainId, 16),
            // id in number form
            name: currentChain.displayName,
            rpcUrls: {
                default: {
                    http: [
                        currentChain.rpcTarget
                    ],
                    webSocket: [
                        currentChain.wsTarget
                    ]
                }
            },
            blockExplorers: currentChain.blockExplorerUrl ? {
                default: {
                    name: "explorer",
                    // TODO: correct name if chain config has it
                    url: currentChain.blockExplorerUrl
                }
            } : undefined,
            nativeCurrency: {
                name: currentChain.tickerName,
                symbol: currentChain.ticker,
                decimals: currentChain.decimals || 18
            }
        });
        // setup public client for viem smart account
        this._publicClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createPublicClient$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createPublicClient"])({
            chain,
            transport: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$http$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["http"])(currentChain.rpcTarget)
        });
        const [eoaAddress] = await eoaProvider.request({
            method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["METHOD_TYPES"].ETH_REQUEST_ACCOUNTS
        });
        const walletClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createWalletClient$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createWalletClient"])({
            account: eoaAddress,
            chain,
            transport: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$custom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["custom"])(eoaProvider)
        });
        this._smartAccount = await this.config.smartAccountInit.getSmartAccount({
            walletClient,
            client: this._publicClient
        });
        // setup bundler and paymaster
        if (paymasterConfig) {
            var _paymasterConfig$tran;
            this._paymasterClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$account$2d$abstraction$2f$clients$2f$createPaymasterClient$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createPaymasterClient"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, paymasterConfig), {}, {
                transport: this._useProviderAsTransport ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$custom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["custom"])(eoaProvider) : (_paymasterConfig$tran = paymasterConfig.transport) !== null && _paymasterConfig$tran !== void 0 ? _paymasterConfig$tran : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$http$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["http"])(paymasterConfig.url)
            }));
        }
        this._bundlerClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$account$2d$abstraction$2f$clients$2f$createBundlerClient$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBundlerClient"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, bundlerConfig), {}, {
            account: this.smartAccount,
            client: this._publicClient,
            transport: this._useProviderAsTransport ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$custom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["custom"])(eoaProvider) : (_bundlerConfig$transp = bundlerConfig.transport) !== null && _bundlerConfig$transp !== void 0 ? _bundlerConfig$transp : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$http$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["http"])(bundlerConfig.url),
            paymaster: this._paymasterClient
        }));
        const providerHandlers = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$dist$2f$lib$2e$esm$2f$providers$2f$account$2d$abstraction$2d$provider$2f$providers$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getProviderHandlers"])({
            bundlerClient: this._bundlerClient,
            smartAccount: this._smartAccount,
            chain,
            eoaProvider
        });
        // setup rpc engine and AA middleware
        const engine = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$jrpcEngine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["JRPCEngine"]();
        const aaMiddleware = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$dist$2f$lib$2e$esm$2f$providers$2f$account$2d$abstraction$2d$provider$2f$rpc$2f$ethRpcMiddlewares$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createAaMiddleware"])({
            eoaProvider,
            handlers: providerHandlers
        });
        engine.push(aaMiddleware);
        const eoaMiddleware = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$dist$2f$lib$2e$esm$2f$providers$2f$account$2d$abstraction$2d$provider$2f$rpc$2f$ethRpcMiddlewares$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["providerAsMiddleware"])(eoaProvider);
        engine.push(eoaMiddleware);
        const provider = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$jrpcEngine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["providerFromEngine"])(engine);
        this.updateProviderEngineProxy(provider);
        eoaProvider.once("chainChanged", (chainId)=>{
            this.update({
                chainId
            });
            this.setupChainSwitchMiddleware();
            this.emit("chainChanged", chainId);
        });
    }
    async updateAccount(_params) {
        throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$errors$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["providerErrors"].unsupportedMethod("updateAccount. Please call it on eoaProvider");
    }
    async switchChain(_params) {
        throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$errors$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["providerErrors"].unsupportedMethod("switchChain. Please call it on eoaProvider");
    }
    async lookupNetwork() {
        throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$errors$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["providerErrors"].unsupportedMethod("lookupNetwork. Please call it on eoaProvider");
    }
    async setupChainSwitchMiddleware() {
        return this.setupProvider(this.state.eoaProvider);
    }
}
_AccountAbstractionProvider = AccountAbstractionProvider;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(AccountAbstractionProvider, "getProviderInstance", async (params)=>{
    const providerInstance = new _AccountAbstractionProvider({
        config: params
    });
    providerInstance._useProviderAsTransport = params.useProviderAsTransport;
    await providerInstance.setupProvider(params.eoaProvider);
    providerInstance.update({
        eoaProvider: params.eoaProvider
    });
    return providerInstance;
});
const accountAbstractionProvider = async ({ accountAbstractionConfig, chain, chains, provider, useProviderAsTransport })=>{
    let smartAccountInit;
    const { smartAccountType, chains: smartAccountChainsConfig } = accountAbstractionConfig;
    const { smartAccountConfig } = smartAccountChainsConfig.find((config)=>config.chainId === chain.chainId) || {};
    switch(smartAccountType){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SMART_ACCOUNT"].BICONOMY:
            {
                const { BiconomySmartAccount } = await __turbopack_context__.A("[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/index.js [app-ssr] (ecmascript, async loader)");
                smartAccountInit = new BiconomySmartAccount(smartAccountConfig);
                break;
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SMART_ACCOUNT"].KERNEL:
            {
                const { KernelSmartAccount } = await __turbopack_context__.A("[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/index.js [app-ssr] (ecmascript, async loader)");
                smartAccountInit = new KernelSmartAccount(smartAccountConfig);
                break;
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SMART_ACCOUNT"].NEXUS:
            {
                const { NexusSmartAccount } = await __turbopack_context__.A("[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/index.js [app-ssr] (ecmascript, async loader)");
                smartAccountInit = new NexusSmartAccount(smartAccountConfig);
                break;
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SMART_ACCOUNT"].SAFE:
            {
                const { SafeSmartAccount } = await __turbopack_context__.A("[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/index.js [app-ssr] (ecmascript, async loader)");
                smartAccountInit = new SafeSmartAccount(smartAccountConfig);
                break;
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SMART_ACCOUNT"].TRUST:
            {
                const { TrustSmartAccount } = await __turbopack_context__.A("[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/index.js [app-ssr] (ecmascript, async loader)");
                smartAccountInit = new TrustSmartAccount(smartAccountConfig);
                break;
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SMART_ACCOUNT"].METAMASK:
            {
                const { MetamaskSmartAccount } = await __turbopack_context__.A("[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/index.js [app-ssr] (ecmascript, async loader)");
                smartAccountInit = new MetamaskSmartAccount(smartAccountConfig);
                break;
            }
        default:
            throw new Error("Smart account type not supported");
    }
    return AccountAbstractionProvider.getProviderInstance({
        eoaProvider: provider,
        smartAccountInit,
        chain,
        chains,
        smartAccountChainsConfig,
        useProviderAsTransport
    });
};
const toEoaProvider = async (aaProvider)=>{
    // derive EOA provider from AA provider
    const engine = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$jrpcEngine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["JRPCEngine"]();
    const eoaMiddleware = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$dist$2f$lib$2e$esm$2f$providers$2f$account$2d$abstraction$2d$provider$2f$rpc$2f$ethRpcMiddlewares$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createEoaMiddleware"])({
        aaProvider
    });
    engine.push(eoaMiddleware);
    engine.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$dist$2f$lib$2e$esm$2f$providers$2f$account$2d$abstraction$2d$provider$2f$rpc$2f$ethRpcMiddlewares$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["providerAsMiddleware"])(aaProvider));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$jrpc$2f$jrpcEngine$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["providerFromEngine"])(engine);
};
;
}),
"[project]/node_modules/@web3auth/no-modal/dist/lib.esm/providers/account-abstraction-provider/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BiconomySmartAccount",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$AccountAbstraction$2f$smartAccounts$2f$BiconomySmartAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BiconomySmartAccount"],
    "KernelSmartAccount",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$AccountAbstraction$2f$smartAccounts$2f$KernelSmartAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["KernelSmartAccount"],
    "MetamaskSmartAccount",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$AccountAbstraction$2f$smartAccounts$2f$MetamaskSmartAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MetamaskSmartAccount"],
    "NexusSmartAccount",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$AccountAbstraction$2f$smartAccounts$2f$NexusSmartAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NexusSmartAccount"],
    "SMART_ACCOUNT",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SMART_ACCOUNT"],
    "SafeSmartAccount",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$AccountAbstraction$2f$smartAccounts$2f$SafeSmartAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SafeSmartAccount"],
    "TrustSmartAccount",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$AccountAbstraction$2f$smartAccounts$2f$TrustSmartAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TrustSmartAccount"],
    "accountAbstractionProvider",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$dist$2f$lib$2e$esm$2f$providers$2f$account$2d$abstraction$2d$provider$2f$providers$2f$AccountAbstractionProvider$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["accountAbstractionProvider"],
    "toEoaProvider",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$dist$2f$lib$2e$esm$2f$providers$2f$account$2d$abstraction$2d$provider$2f$providers$2f$AccountAbstractionProvider$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toEoaProvider"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$dist$2f$lib$2e$esm$2f$providers$2f$account$2d$abstraction$2d$provider$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3auth/no-modal/dist/lib.esm/providers/account-abstraction-provider/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3auth$2f$no$2d$modal$2f$dist$2f$lib$2e$esm$2f$providers$2f$account$2d$abstraction$2d$provider$2f$providers$2f$AccountAbstractionProvider$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3auth/no-modal/dist/lib.esm/providers/account-abstraction-provider/providers/AccountAbstractionProvider.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$AccountAbstraction$2f$smartAccounts$2f$BiconomySmartAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/AccountAbstraction/smartAccounts/BiconomySmartAccount.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$AccountAbstraction$2f$smartAccounts$2f$KernelSmartAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/AccountAbstraction/smartAccounts/KernelSmartAccount.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$AccountAbstraction$2f$smartAccounts$2f$MetamaskSmartAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/AccountAbstraction/smartAccounts/MetamaskSmartAccount.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$AccountAbstraction$2f$smartAccounts$2f$NexusSmartAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/AccountAbstraction/smartAccounts/NexusSmartAccount.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/utils/constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$AccountAbstraction$2f$smartAccounts$2f$SafeSmartAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/AccountAbstraction/smartAccounts/SafeSmartAccount.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$AccountAbstraction$2f$smartAccounts$2f$TrustSmartAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/AccountAbstraction/smartAccounts/TrustSmartAccount.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/@toruslabs/base-controllers/dist/lib.esm/Network/INetworkController.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CHAIN_NAMESPACES",
    ()=>CHAIN_NAMESPACES,
    "createRandomId",
    ()=>createRandomId
]);
const createRandomId = ()=>Math.random().toString(36).substring(2);
const CHAIN_NAMESPACES = {
    EIP155: "eip155",
    SOLANA: "solana",
    CASPER: "casper",
    XRPL: "xrpl",
    OTHER: "other"
};
;
}),
"[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/@toruslabs/base-controllers/dist/lib.esm/Network/constants.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ANALYTICS_EVENTS",
    ()=>ANALYTICS_EVENTS,
    "ANALYTICS_JRPC_REQUEST_TYPES",
    ()=>ANALYTICS_JRPC_REQUEST_TYPES,
    "ANALYTICS_TRACKED_INTERNAL_JPRC_METHODS",
    ()=>ANALYTICS_TRACKED_INTERNAL_JPRC_METHODS,
    "ANALYTICS_TRACKED_NETWORK_JPRC_METHODS",
    ()=>ANALYTICS_TRACKED_NETWORK_JPRC_METHODS,
    "SOLANA_CAIP_CHAIN_MAP",
    ()=>SOLANA_CAIP_CHAIN_MAP
]);
// Methods that are tracked for JRPC requests that are handled internally and not through network fetch
const ANALYTICS_TRACKED_INTERNAL_JPRC_METHODS = {
    // Ethereum methods
    ETH_TRANSACTION: "eth_sendTransaction",
    ETH_SIGN_TRANSACTION: "eth_signTransaction",
    ETH_SIGN: "eth_sign",
    PERSONAL_SIGN: "personal_sign",
    ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
    // Solana methods
    SIGN_TRANSACTION: "solana_signTransaction",
    SIGN_ALL_TRANSACTIONS: "solana_signAllTransactions",
    SIGN_MESSAGE: "solana_signMessage"
};
// Methods that are tracked for network fetch requests
const ANALYTICS_TRACKED_NETWORK_JPRC_METHODS = {
    // Ethereum methods
    ETH_SEND_RAW_TRANSACTION: "eth_sendRawTransaction",
    ETH_SEND_USER_OPERATION: "eth_sendUserOperation",
    ETH_SPONSOR_USER_OPERATION: "pm_sponsorUserOperation",
    // Solana methods
    SEND_TRANSACTION: "solana_sendTransaction"
};
const ANALYTICS_EVENTS = {
    JRPC_REQUEST_COMPLETED: "JRPC Request Completed",
    JRPC_REQUEST_FAILED: "JRPC Request Failed"
};
const ANALYTICS_JRPC_REQUEST_TYPES = {
    INTERNAL: "internal",
    NETWORK: "network"
};
const SOLANA_CAIP_CHAIN_MAP = {
    "0x65": "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
    "0x66": "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
    "0x67": "EtWTRABZaYq6iMfeYKouRu166VU2xqa1"
};
;
}),
"[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/@toruslabs/base-controllers/dist/lib.esm/utils/utils.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "UserError",
    ()=>UserError,
    "addressSlicer",
    ()=>addressSlicer,
    "broadcastChannelOptions",
    ()=>broadcastChannelOptions,
    "concatSig",
    ()=>concatSig,
    "ecsignature",
    ()=>ecsignature,
    "formatDate",
    ()=>formatDate,
    "formatSmallNumbers",
    ()=>formatSmallNumbers,
    "formatTime",
    ()=>formatTime,
    "getCaipChainId",
    ()=>getCaipChainId,
    "getCustomDeviceInfo",
    ()=>getCustomDeviceInfo,
    "getEnvVariable",
    ()=>getEnvVariable,
    "getErrorAnalyticsProperties",
    ()=>getErrorAnalyticsProperties,
    "getHeaders",
    ()=>getHeaders,
    "getHostname",
    ()=>getHostname,
    "getPopupFeatures",
    ()=>getPopupFeatures,
    "handleRedirectParameters",
    ()=>handleRedirectParameters,
    "hashMessage",
    ()=>hashMessage,
    "intToHex",
    ()=>intToHex,
    "isUnauthorizedError",
    ()=>isUnauthorizedError,
    "padWithZeroes",
    ()=>padWithZeroes,
    "randomId",
    ()=>randomId,
    "signMessage",
    ()=>signMessage,
    "significantDigits",
    ()=>significantDigits,
    "sleep",
    ()=>sleep,
    "timeout",
    ()=>timeout,
    "transactionMatchesNetwork",
    ()=>transactionMatchesNetwork
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/util/dist/esm/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/util/dist/esm/bytes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$internal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/util/dist/esm/internal.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/util/dist/esm/signature.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$utils$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/@web3auth/auth/dist/lib.esm/utils/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bignumber.js/bignumber.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f$ethereum$2d$cryptography$2f$esm$2f$secp256k1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/ethereum-cryptography/esm/secp256k1.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$secp256k1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/@noble/curves/esm/secp256k1.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/@toruslabs/base-controllers/dist/lib.esm/Network/constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/@toruslabs/base-controllers/dist/lib.esm/Network/INetworkController.js [app-ssr] (ecmascript)");
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/@toruslabs/ethereum-controllers/node_modules/@toruslabs/base-controllers/dist/lib.esm/utils/utils.js")}`;
    }
};
;
;
;
;
;
;
/**
 * General utility functions
 */ function intToHex(i) {
    const hex = i.toString(16);
    return `0x${hex}`;
}
/**
 * Returns a random number. Don't use for cryptographic purposes.
 * @returns a random number
 */ const randomId = ()=>Math.random().toString(36).slice(2);
/**
 * Pads the front of the given hex string with zeroes until it reaches the
 * target length. If the input string is already longer than or equal to the
 * target length, it is returned unmodified.
 *
 * If the input string is "0x"-prefixed or not a hex string, an error will be
 * thrown.
 *
 * @param hexString - The hexadecimal string to pad with zeroes.
 * @param targetLength - The target length of the hexadecimal string.
 * @returns The input string front-padded with zeroes, or the original string
 * if it was already greater than or equal to to the target length.
 */ function padWithZeroes(hexString, targetLength) {
    if (hexString !== "" && !/^[a-f0-9]+$/iu.test(hexString)) {
        throw new Error(`Expected an unprefixed hex string. Received: ${hexString}`);
    }
    if (targetLength < 0) {
        throw new Error(`Expected a non-negative integer target length. Received: ${targetLength}`);
    }
    return String.prototype.padStart.call(hexString, targetLength, "0");
}
/**
 * Concatenate an extended ECDSA signature into a hex string.
 *
 * @param v - The 'v' portion of the signature.
 * @param r - The 'r' portion of the signature.
 * @param s - The 's' portion of the signature.
 * @returns The concatenated ECDSA signature.
 */ function concatSig(v, r, s) {
    const rSig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromSigned"])(r);
    const sSig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromSigned"])(s);
    const vSig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToBigInt"])(v);
    const rStr = padWithZeroes(Buffer.from((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toUnsigned"])(rSig)).toString("hex"), 64);
    const sStr = padWithZeroes(Buffer.from((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toUnsigned"])(sSig)).toString("hex"), 64);
    const vStr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$internal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stripHexPrefix"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bigIntToHex"])(vSig));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addHexPrefix"])(rStr.concat(sStr, vStr));
}
function timeout(duration) {
    return new Promise((resolve)=>{
        const timeoutRef = window.setTimeout(()=>{
            resolve();
            window.clearTimeout(timeoutRef);
        }, duration);
    });
}
const getHeaders = (jwt, publicAddress)=>{
    return {
        headers: {
            Authorization: `Bearer ${jwt}`,
            "Content-Type": "application/json; charset=utf-8",
            "public-address": publicAddress
        }
    };
};
/**
 * Text/number formatting utilities
 */ const formatSmallNumbers = (number, currency = "usd", noTilde = false)=>{
    const finalNumber = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].isBigNumber(number) ? number.toNumber() : number;
    if (!Number.isFinite(finalNumber)) return "";
    const value = currency.toLowerCase() === "usd" ? parseFloat(Number(finalNumber).toFixed(2)) : parseFloat(Number(finalNumber).toFixed(5));
    const tilde = value > 0 ? "~ " : "";
    return `${currency.toLowerCase() === "usd" || noTilde ? "" : tilde}${Number(value)} ${currency.toUpperCase()}`;
};
const addressSlicer = (address, sliceLength = 5)=>{
    if (!address) return "";
    if (address.length < 11) {
        return address;
    }
    if (typeof address !== "string") return "";
    return `${address.slice(0, sliceLength)}...${address.slice(-sliceLength)}`;
};
const significantDigits = (number, perc = false, length_ = 2)=>{
    let input = !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].isBigNumber(number) ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](number) : number;
    if (input.isZero()) return input;
    if (perc) {
        input = input.times(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](100));
    }
    let depth;
    if (input.gte(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](1))) {
        depth = length_;
    } else {
        depth = length_ - 1 + Math.ceil(Math.log10(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]("1").div(input).toNumber()));
    }
    const shift = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](10).pow(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bignumber$2e$js$2f$bignumber$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](depth));
    const roundedNumber = Math.round(shift.times(input).toNumber()) / shift.toNumber();
    return roundedNumber;
};
const formatDate = (inputDate)=>{
    const monthList = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
    ];
    const date = new Date(inputDate);
    const day = date.getDate();
    const month = monthList[date.getMonth()];
    const year = date.getFullYear();
    return `${day} ${month} ${year}`;
};
const formatTime = (time)=>{
    return new Date(time).toTimeString().slice(0, 8);
};
/**
 * Network utilities
 */ const transactionMatchesNetwork = (transaction, chainId)=>{
    if (typeof transaction.chainId !== "undefined") {
        return transaction.chainId === chainId;
    }
    return false;
};
/**
 * Signing utils
 */ const hashMessage = (message)=>{
    const bufferedMessage = Buffer.from(message, "utf8");
    const el = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hashPersonalMessage"])(bufferedMessage);
    return Buffer.from(el);
};
function ecsignature(msgHash, privateKey, chainId) {
    const sig = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$secp256k1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["secp256k1"].sign(msgHash, privateKey);
    const buf = sig.toCompactRawBytes();
    const r = buf.slice(0, 32);
    const s = buf.slice(32, 64);
    const v = chainId === undefined ? BigInt(sig.recovery + 27) : BigInt(sig.recovery + 35) + BigInt(chainId) * BigInt(2);
    return {
        r,
        s,
        v
    };
}
const signMessage = async (privateKey, data)=>{
    const privKey = Buffer.from(privateKey, "hex");
    const message = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$internal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stripHexPrefix"])(data);
    const msgSig = ecsignature(Buffer.from(message, "hex"), privKey);
    const rawMsgSig = concatSig(Buffer.from((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$util$2f$dist$2f$esm$2f$bytes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bigIntToBytes"])(msgSig.v)), Buffer.from(msgSig.r), Buffer.from(msgSig.s));
    return rawMsgSig;
};
/**
 * popup handler utils
 */ function getPopupFeatures({ width: w, height: h }) {
    // Fixes dual-screen position                             Most browsers      Firefox
    const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;
    const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;
    const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;
    const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;
    const systemZoom = 1; // No reliable estimate
    const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);
    const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);
    const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;
    return features;
}
const broadcastChannelOptions = {
    type: "server",
    // type: 'localstorage', // (optional) enforce a type, oneOf['native', 'idb', 'localstorage', 'node']
    webWorkerSupport: false // (optional) set this to false if you know that your channel will never be used in a WebWorker (increases performance)
};
function getCustomDeviceInfo() {
    var _navigator;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if ((_navigator = navigator) !== null && _navigator !== void 0 && _navigator.brave) {
        return {
            browser: "Brave"
        };
    }
}
class UserError extends Error {
}
const handleRedirectParameters = (hash, queryParameters)=>{
    const hashParameters = {};
    const hashUrl = new URL(`${window.location.origin}/?${hash.slice(1)}`);
    hashUrl.searchParams.forEach((value, key)=>{
        hashParameters[key] = value;
    });
    let instanceParameters = {};
    let error = "";
    if (!queryParameters.windowId) {
        if (Object.keys(hashParameters).length > 0 && hashParameters.state) {
            instanceParameters = JSON.parse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$utils$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["safeatob"])(decodeURIComponent(decodeURIComponent(hashParameters.state)))) || {};
            error = hashParameters.error_description || hashParameters.error || error;
        } else if (Object.keys(queryParameters).length > 0 && queryParameters.state) {
            instanceParameters = JSON.parse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$web3auth$2f$auth$2f$dist$2f$lib$2e$esm$2f$utils$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["safeatob"])(decodeURIComponent(decodeURIComponent(queryParameters.state)))) || {};
            if (queryParameters.error) error = queryParameters.error;
        }
    }
    return {
        error,
        instanceParameters,
        hashParameters
    };
};
function sleep(ms) {
    return new Promise((resolve)=>{
        setTimeout(resolve, ms);
    });
}
const isUnauthorizedError = (error)=>{
    return error instanceof Response && error.status === 401;
};
const getErrorAnalyticsProperties = (error)=>{
    try {
        const code = error === null || error === void 0 ? void 0 : error.code;
        const message = error instanceof Error ? error.message : (error === null || error === void 0 ? void 0 : error.message) || (error === null || error === void 0 ? void 0 : error.toString());
        return {
            error_message: message,
            error_code: code
        };
    } catch  {
        return {
            error_message: "Unknown error",
            error_code: undefined
        };
    }
};
const getHostname = (url)=>{
    try {
        return new URL(url).hostname;
    } catch  {
        return "";
    }
};
const getCaipChainId = (chain)=>{
    if (!chain) return undefined;
    if (chain.chainNamespace === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CHAIN_NAMESPACES"].EIP155) {
        return `${chain.chainNamespace}:${parseInt(chain.chainId, 16)}`;
    }
    if (chain.chainNamespace === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CHAIN_NAMESPACES"].SOLANA) {
        return `${chain.chainNamespace}:${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SOLANA_CAIP_CHAIN_MAP"][chain.chainId]}`;
    }
    // for other chain namespaces, we just return the chainId as is
    return `${chain.chainNamespace}:${chain.chainId}`;
};
const getEnvVariable = (variable)=>{
    var _import$meta$env, _process$env;
    // Check for Vite/browser environment (import.meta.env)
    if (("TURBOPACK compile-time value", "object") !== "undefined" && (_import$meta$env = __TURBOPACK__import$2e$meta__.env) !== null && _import$meta$env !== void 0 && _import$meta$env[variable]) {
        var _import$meta$env2;
        return (_import$meta$env2 = __TURBOPACK__import$2e$meta__.env) === null || _import$meta$env2 === void 0 ? void 0 : _import$meta$env2[variable];
    }
    // Check for Node.js environment (process.env)
    if (typeof process !== "undefined" && (_process$env = process.env) !== null && _process$env !== void 0 && _process$env[variable]) {
        var _process$env2;
        return (_process$env2 = process.env) === null || _process$env2 === void 0 ? void 0 : _process$env2[variable];
    }
    return undefined;
};
;
}),
"[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/ethereum-cryptography/esm/secp256k1.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
}),
"[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/ethereum-cryptography/esm/utils.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bytesToUtf8",
    ()=>bytesToUtf8,
    "equalsBytes",
    ()=>equalsBytes,
    "hexToBytes",
    ()=>hexToBytes,
    "wrapHash",
    ()=>wrapHash
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/@noble/curves/esm/abstract/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_assert$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/_assert.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/utils.js [app-ssr] (ecmascript)");
;
;
;
;
;
function bytesToUtf8(data) {
    if (!(data instanceof Uint8Array)) {
        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
    }
    return new TextDecoder().decode(data);
}
function hexToBytes(data) {
    const sliced = data.startsWith("0x") ? data.substring(2) : data;
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(sliced);
}
function equalsBytes(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for(let i = 0; i < a.length; i++){
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
function wrapHash(hash) {
    return (msg)=>{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_assert$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["abytes"])(msg);
        return hash(msg);
    };
}
}),
"[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/ethereum-cryptography/esm/sha256.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "sha256",
    ()=>sha256
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/sha2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f$ethereum$2d$cryptography$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/ethereum-cryptography/esm/utils.js [app-ssr] (ecmascript) <locals>");
;
;
const sha256 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f$ethereum$2d$cryptography$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["wrapHash"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sha256"]);
}),
"[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/ethereum-cryptography/esm/random.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getRandomBytes",
    ()=>getRandomBytes,
    "getRandomBytesSync",
    ()=>getRandomBytesSync
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/utils.js [app-ssr] (ecmascript)");
;
function getRandomBytesSync(bytes) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomBytes"])(bytes);
}
async function getRandomBytes(bytes) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomBytes"])(bytes);
}
}),
"[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/ethereum-cryptography/esm/keccak.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "keccak224",
    ()=>keccak224,
    "keccak256",
    ()=>keccak256,
    "keccak384",
    ()=>keccak384,
    "keccak512",
    ()=>keccak512
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/sha3.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f$ethereum$2d$cryptography$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/ethereum-cryptography/esm/utils.js [app-ssr] (ecmascript) <locals>");
;
;
const keccak224 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f$ethereum$2d$cryptography$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["wrapHash"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["keccak_224"]);
const keccak256 = (()=>{
    const k = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f$ethereum$2d$cryptography$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["wrapHash"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["keccak_256"]);
    k.create = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["keccak_256"].create;
    return k;
})();
const keccak384 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f$ethereum$2d$cryptography$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["wrapHash"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["keccak_384"]);
const keccak512 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f$ethereum$2d$cryptography$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["wrapHash"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["keccak_512"]);
}),
"[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/rlp/dist/esm/errors.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// In order to update all our errors to use `EthereumJSError`, temporarily include the
// unset error code. All errors throwing this code should be updated to use the relevant
// error code.
__turbopack_context__.s([
    "DEFAULT_ERROR_CODE",
    ()=>DEFAULT_ERROR_CODE,
    "EthereumJSError",
    ()=>EthereumJSError,
    "EthereumJSErrorWithoutCode",
    ()=>EthereumJSErrorWithoutCode
]);
const DEFAULT_ERROR_CODE = 'ETHEREUMJS_DEFAULT_ERROR_CODE';
class EthereumJSError extends Error {
    constructor(type, message, stack){
        super(message ?? type.code);
        this.type = type;
        if (stack !== undefined) this.stack = stack;
    }
    getMetadata() {
        return this.type;
    }
    /**
     * Get the metadata and the stacktrace for the error.
     */ toObject() {
        return {
            type: this.getMetadata(),
            message: this.message ?? '',
            stack: this.stack ?? '',
            className: this.constructor.name
        };
    }
}
function EthereumJSErrorWithoutCode(message, stack) {
    return new EthereumJSError({
        code: DEFAULT_ERROR_CODE
    }, message, stack);
} //# sourceMappingURL=errors.js.map
}),
"[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/rlp/dist/esm/index.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RLP",
    ()=>RLP,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "hexToBytes",
    ()=>hexToBytes,
    "utils",
    ()=>utils
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$rlp$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/@ethereumjs/rlp/dist/esm/errors.js [app-ssr] (ecmascript)");
;
;
/**
 * Parse integers. Check if there is no leading zeros
 * @param v The value to parse
 */ function decodeLength(v) {
    if (v[0] === 0) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$rlp$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EthereumJSErrorWithoutCode"])('invalid RLP: extra zeros');
    }
    return parseHexByte(bytesToHex(v));
}
function encodeLength(len, offset) {
    if (len < 56) {
        return Uint8Array.from([
            len + offset
        ]);
    }
    const hexLength = numberToHex(len);
    const lLength = hexLength.length / 2;
    const firstByte = numberToHex(offset + 55 + lLength);
    return Uint8Array.from(hexToBytes(firstByte + hexLength));
}
/**
 * Slices a Uint8Array, throws if the slice goes out-of-bounds of the Uint8Array.
 * E.g. `safeSlice(hexToBytes('aa'), 1, 2)` will throw.
 * @param input
 * @param start
 * @param end
 */ function safeSlice(input, start, end) {
    if (end > input.length) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$rlp$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EthereumJSErrorWithoutCode"])('invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds');
    }
    return input.slice(start, end);
}
/** Decode an input with RLP */ function _decode(input) {
    let length, lLength, data, innerRemainder, d;
    const decoded = [];
    const firstByte = input[0];
    if (firstByte <= 0x7f) {
        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
        return {
            data: input.slice(0, 1),
            remainder: input.subarray(1)
        };
    } else if (firstByte <= 0xb7) {
        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
        // The range of the first byte is [0x80, 0xb7]
        length = firstByte - 0x7f;
        // set 0x80 null to 0
        if (firstByte === 0x80) {
            data = Uint8Array.from([]);
        } else {
            data = safeSlice(input, 1, length);
        }
        if (length === 2 && data[0] < 0x80) {
            throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$rlp$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EthereumJSErrorWithoutCode"])('invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed');
        }
        return {
            data,
            remainder: input.subarray(length)
        };
    } else if (firstByte <= 0xbf) {
        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),
        // followed by the length, followed by the string
        lLength = firstByte - 0xb6;
        if (input.length - 1 < lLength) {
            throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$rlp$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EthereumJSErrorWithoutCode"])('invalid RLP: not enough bytes for string length');
        }
        length = decodeLength(safeSlice(input, 1, lLength));
        if (length <= 55) {
            throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$rlp$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EthereumJSErrorWithoutCode"])('invalid RLP: expected string length to be greater than 55');
        }
        data = safeSlice(input, lLength, length + lLength);
        return {
            data,
            remainder: input.subarray(length + lLength)
        };
    } else if (firstByte <= 0xf7) {
        // a list between 0-55 bytes long
        length = firstByte - 0xbf;
        innerRemainder = safeSlice(input, 1, length);
        while(innerRemainder.length){
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.subarray(length)
        };
    } else {
        // a list over 55 bytes long
        lLength = firstByte - 0xf6;
        length = decodeLength(safeSlice(input, 1, lLength));
        if (length < 56) {
            throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$rlp$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EthereumJSErrorWithoutCode"])('invalid RLP: encoded list too short');
        }
        const totalLength = lLength + length;
        if (totalLength > input.length) {
            throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$rlp$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EthereumJSErrorWithoutCode"])('invalid RLP: total length is larger than the data');
        }
        innerRemainder = safeSlice(input, lLength, totalLength);
        while(innerRemainder.length){
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.subarray(totalLength)
        };
    }
}
const cachedHexes = Array.from({
    length: 256
}, (_v, i)=>i.toString(16).padStart(2, '0'));
function bytesToHex(uint8a) {
    // Pre-caching chars with `cachedHexes` speeds this up 6x
    let hex = '';
    for(let i = 0; i < uint8a.length; i++){
        hex += cachedHexes[uint8a[i]];
    }
    return hex;
}
function parseHexByte(hexByte) {
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte)) throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$rlp$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EthereumJSErrorWithoutCode"])('Invalid byte sequence');
    return byte;
}
// Borrowed from @noble/curves to avoid dependency
// Original code here - https://github.com/paulmillr/noble-curves/blob/d0a8d2134c5737d9d0aa81be13581cd416ebdeb4/src/abstract/utils.ts#L63-L91
const asciis = {
    _0: 48,
    _9: 57,
    _A: 65,
    _F: 70,
    _a: 97,
    _f: 102
};
function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);
    return;
}
function hexToBytes(hex) {
    if (hex.slice(0, 2) === '0x') hex = hex.slice(0, 2);
    if (typeof hex !== 'string') throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$rlp$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EthereumJSErrorWithoutCode"])('hex string expected, got ' + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$rlp$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EthereumJSErrorWithoutCode"])('padded hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$rlp$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EthereumJSErrorWithoutCode"])('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
/** Concatenates two Uint8Arrays into one. */ function concatBytes(...arrays) {
    if (arrays.length === 1) return arrays[0];
    const length = arrays.reduce((a, arr)=>a + arr.length, 0);
    const result = new Uint8Array(length);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
function utf8ToBytes(utf) {
    return new TextEncoder().encode(utf);
}
/** Transform an integer into its hexadecimal value */ function numberToHex(integer) {
    if (integer < 0) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$rlp$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EthereumJSErrorWithoutCode"])('Invalid integer as argument, must be unsigned!');
    }
    const hex = integer.toString(16);
    return hex.length % 2 ? `0${hex}` : hex;
}
/** Pad a string to be even */ function padToEven(a) {
    return a.length % 2 ? `0${a}` : a;
}
/** Check if a string is prefixed by 0x */ function isHexString(str) {
    return str.length >= 2 && str[0] === '0' && str[1] === 'x';
}
/** Removes 0x from a given String */ function stripHexPrefix(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return isHexString(str) ? str.slice(2) : str;
}
/** Transform anything into a Uint8Array */ function toBytes(v) {
    if (v instanceof Uint8Array) {
        return v;
    }
    if (typeof v === 'string') {
        if (isHexString(v)) {
            return hexToBytes(padToEven(stripHexPrefix(v)));
        }
        return utf8ToBytes(v);
    }
    if (typeof v === 'number' || typeof v === 'bigint') {
        if (!v) {
            return Uint8Array.from([]);
        }
        return hexToBytes(numberToHex(v));
    }
    if (v === null || v === undefined) {
        return Uint8Array.from([]);
    }
    throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$rlp$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EthereumJSErrorWithoutCode"])('toBytes: received unsupported type ' + typeof v);
}
function encode(input) {
    if (Array.isArray(input)) {
        const output = [];
        let outputLength = 0;
        for(let i = 0; i < input.length; i++){
            const encoded = encode(input[i]);
            output.push(encoded);
            outputLength += encoded.length;
        }
        return concatBytes(encodeLength(outputLength, 192), ...output);
    }
    const inputBuf = toBytes(input);
    if (inputBuf.length === 1 && inputBuf[0] < 128) {
        return inputBuf;
    }
    return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);
}
function decode(input, stream = false) {
    if (typeof input === 'undefined' || input === null || input.length === 0) {
        return Uint8Array.from([]);
    }
    const inputBytes = toBytes(input);
    const decoded = _decode(inputBytes);
    if (stream) {
        return {
            data: decoded.data,
            remainder: decoded.remainder.slice()
        };
    }
    if (decoded.remainder.length !== 0) {
        throw (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$ethereumjs$2f$rlp$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EthereumJSErrorWithoutCode"])('invalid RLP: remainder must be zero');
    }
    return decoded.data;
}
const utils = {
    bytesToHex,
    concatBytes,
    hexToBytes,
    utf8ToBytes
};
const RLP = {
    encode,
    decode
}; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/@web3auth/auth/dist/lib.esm/utils/utils.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "base64toJSON",
    ()=>base64toJSON,
    "base64url",
    ()=>base64url,
    "cloneDeep",
    ()=>cloneDeep,
    "htmlToElement",
    ()=>htmlToElement,
    "jsonToBase64",
    ()=>jsonToBase64,
    "safeatob",
    ()=>safeatob,
    "safebtoa",
    ()=>safebtoa
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$base64url$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/base64url/index.js [app-ssr] (ecmascript)");
;
const base64url = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$base64url$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"];
function safebtoa(str) {
    return base64url.encode(str);
}
function safeatob(str) {
    // Going backwards: from bytestream, to percent-encoding, to original string.
    return base64url.decode(str);
}
function base64toJSON(b64str) {
    return JSON.parse(base64url.decode(b64str));
}
function jsonToBase64(json) {
    return base64url.encode(JSON.stringify(json));
}
const htmlToElement = (html)=>{
    const template = window.document.createElement("template");
    const trimmedHtml = html.trim(); // Never return a text node of whitespace as the result
    template.innerHTML = trimmedHtml;
    return template.content.firstChild;
};
function cloneDeep(object) {
    try {
        return structuredClone(object);
    } catch  {
        return JSON.parse(JSON.stringify(object));
    }
}
;
}),
"[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/utils/constants.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ARBITRUM_MAINNET_CHAIN_ID",
    ()=>ARBITRUM_MAINNET_CHAIN_ID,
    "ARBITRUM_TESTNET_CHAIN_ID",
    ()=>ARBITRUM_TESTNET_CHAIN_ID,
    "AVALANCHE_MAINNET_CHAIN_ID",
    ()=>AVALANCHE_MAINNET_CHAIN_ID,
    "AVALANCHE_TESTNET_CHAIN_ID",
    ()=>AVALANCHE_TESTNET_CHAIN_ID,
    "BASE_CHAIN_ID",
    ()=>BASE_CHAIN_ID,
    "BASE_TESTNET_CHAIN_ID",
    ()=>BASE_TESTNET_CHAIN_ID,
    "BSC_MAINNET_CHAIN_ID",
    ()=>BSC_MAINNET_CHAIN_ID,
    "BSC_TESTNET_CHAIN_ID",
    ()=>BSC_TESTNET_CHAIN_ID,
    "BUNDLER_METHOD_TYPES",
    ()=>BUNDLER_METHOD_TYPES,
    "CELO_MAINNET_CHAIN_ID",
    ()=>CELO_MAINNET_CHAIN_ID,
    "CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP",
    ()=>CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP,
    "COINGECKO_PLATFORMS_CHAIN_CODE_MAP",
    ()=>COINGECKO_PLATFORMS_CHAIN_CODE_MAP,
    "COINGECKO_SUPPORTED_CURRENCIES",
    ()=>COINGECKO_SUPPORTED_CURRENCIES,
    "CONTRACT_TYPE_ERC1155",
    ()=>CONTRACT_TYPE_ERC1155,
    "CONTRACT_TYPE_ERC20",
    ()=>CONTRACT_TYPE_ERC20,
    "CONTRACT_TYPE_ERC721",
    ()=>CONTRACT_TYPE_ERC721,
    "CONTRACT_TYPE_ETH",
    ()=>CONTRACT_TYPE_ETH,
    "ERC1155_INTERFACE_ID",
    ()=>ERC1155_INTERFACE_ID,
    "ERC721_ENUMERABLE_INTERFACE_ID",
    ()=>ERC721_ENUMERABLE_INTERFACE_ID,
    "ERC721_INTERFACE_ID",
    ()=>ERC721_INTERFACE_ID,
    "ERC721_METADATA_INTERFACE_ID",
    ()=>ERC721_METADATA_INTERFACE_ID,
    "GAS_ESTIMATE_TYPES",
    ()=>GAS_ESTIMATE_TYPES,
    "LINEA_CHAIN_ID",
    ()=>LINEA_CHAIN_ID,
    "LINEA_SEPOLIA_CHAIN_ID",
    ()=>LINEA_SEPOLIA_CHAIN_ID,
    "LOCALHOST",
    ()=>LOCALHOST,
    "MAINNET_CHAIN_ID",
    ()=>MAINNET_CHAIN_ID,
    "METHOD_TYPES",
    ()=>METHOD_TYPES,
    "MM_NFT_API_SUPPORTED_CHAINS",
    ()=>MM_NFT_API_SUPPORTED_CHAINS,
    "MM_TOKEN_API_SUPPORTED_CHAINS",
    ()=>MM_TOKEN_API_SUPPORTED_CHAINS,
    "OLD_ERC721_LIST",
    ()=>OLD_ERC721_LIST,
    "OPTIMISM_MAINNET_CHAIN_ID",
    ()=>OPTIMISM_MAINNET_CHAIN_ID,
    "OPTIMISM_TESTNET_CHAIN_ID",
    ()=>OPTIMISM_TESTNET_CHAIN_ID,
    "PAYMASTER_METHOD_TYPES",
    ()=>PAYMASTER_METHOD_TYPES,
    "POLYGON_AMOY_CHAIN_ID",
    ()=>POLYGON_AMOY_CHAIN_ID,
    "POLYGON_CHAIN_ID",
    ()=>POLYGON_CHAIN_ID,
    "SEPOLIA_CHAIN_ID",
    ()=>SEPOLIA_CHAIN_ID,
    "SMART_ACCOUNT",
    ()=>SMART_ACCOUNT,
    "SUPPORTED_NETWORKS",
    ()=>SUPPORTED_NETWORKS,
    "TEST_CHAINS",
    ()=>TEST_CHAINS,
    "TRANSACTION_ENVELOPE_TYPES",
    ()=>TRANSACTION_ENVELOPE_TYPES,
    "XDAI_CHAIN_ID",
    ()=>XDAI_CHAIN_ID
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/@toruslabs/base-controllers/dist/lib.esm/Network/INetworkController.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/node_modules/@toruslabs/base-controllers/dist/lib.esm/utils/utils.js [app-ssr] (ecmascript)");
;
const LOCALHOST = "localhost";
const CONTRACT_TYPE_ETH = "eth";
const CONTRACT_TYPE_ERC20 = "erc20";
const CONTRACT_TYPE_ERC721 = "erc721";
const CONTRACT_TYPE_ERC1155 = "erc1155";
const ERC1155_INTERFACE_ID = "0xd9b67a26";
const ERC721_INTERFACE_ID = "0x80ac58cd";
const ERC721_METADATA_INTERFACE_ID = "0x5b5e139f";
const ERC721_ENUMERABLE_INTERFACE_ID = "0x780e9d63";
const MAINNET_CHAIN_ID = "0x1";
const POLYGON_CHAIN_ID = "0x89";
const BSC_MAINNET_CHAIN_ID = "0x38";
const AVALANCHE_MAINNET_CHAIN_ID = "0xa86a";
const XDAI_CHAIN_ID = "0x64";
const ARBITRUM_MAINNET_CHAIN_ID = "0xa4b1";
const OPTIMISM_MAINNET_CHAIN_ID = "0xa";
const CELO_MAINNET_CHAIN_ID = "0xa4ec";
const BASE_CHAIN_ID = "0x2105";
const LINEA_CHAIN_ID = "0xe708";
const SEPOLIA_CHAIN_ID = "0xaa36a7";
const POLYGON_AMOY_CHAIN_ID = "0x13882";
const BSC_TESTNET_CHAIN_ID = "0x61";
const AVALANCHE_TESTNET_CHAIN_ID = "0xa869";
const ARBITRUM_TESTNET_CHAIN_ID = "0x66eee";
const OPTIMISM_TESTNET_CHAIN_ID = "0xaa37dc";
const BASE_TESTNET_CHAIN_ID = "0x14a34";
const LINEA_SEPOLIA_CHAIN_ID = "0xe705";
// Don't change this. It will break production builds.
// We use this syntax because if both injections fail, we replace the "process.env.VITE_APP_INFURA_PROJECT_KEY" using define replacement
const INFURA_KEY = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getEnvVariable"])("VITE_APP_INFURA_PROJECT_KEY") || process.env.VITE_APP_INFURA_PROJECT_KEY;
const SUPPORTED_NETWORKS = {
    [MAINNET_CHAIN_ID]: {
        chainNamespace: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CHAIN_NAMESPACES"].EIP155,
        decimals: 18,
        blockExplorerUrl: "https://etherscan.io",
        chainId: MAINNET_CHAIN_ID,
        displayName: "Ethereum",
        logo: "eth.svg",
        rpcTarget: `https://mainnet.infura.io/v3/${INFURA_KEY}`,
        ticker: "ETH",
        tickerName: "Ethereum"
    },
    [POLYGON_CHAIN_ID]: {
        chainNamespace: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CHAIN_NAMESPACES"].EIP155,
        decimals: 18,
        blockExplorerUrl: "https://polygonscan.com",
        chainId: POLYGON_CHAIN_ID,
        displayName: "Polygon",
        logo: "polygon.svg",
        rpcTarget: `https://polygon-mainnet.infura.io/v3/${INFURA_KEY}`,
        ticker: "POL",
        tickerName: "Polygon Ecosystem Token"
    },
    [BSC_MAINNET_CHAIN_ID]: {
        chainNamespace: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CHAIN_NAMESPACES"].EIP155,
        decimals: 18,
        blockExplorerUrl: "https://bscscan.com",
        chainId: BSC_MAINNET_CHAIN_ID,
        displayName: "Binance Smart Chain (BSC)",
        logo: "bnb_logo.svg",
        rpcTarget: `https://bsc-dataseed.binance.org`,
        ticker: "BNB",
        tickerName: "Binance Coin"
    },
    [AVALANCHE_MAINNET_CHAIN_ID]: {
        chainNamespace: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CHAIN_NAMESPACES"].EIP155,
        decimals: 18,
        blockExplorerUrl: "https://snowtrace.io",
        chainId: AVALANCHE_MAINNET_CHAIN_ID,
        displayName: "Avalanche",
        logo: "avax.svg",
        rpcTarget: `https://api.avax.network/ext/bc/C/rpc`,
        ticker: "AVAX",
        tickerName: "Avalanche"
    },
    [OPTIMISM_MAINNET_CHAIN_ID]: {
        chainNamespace: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CHAIN_NAMESPACES"].EIP155,
        decimals: 18,
        blockExplorerUrl: "https://optimistic.etherscan.io",
        chainId: OPTIMISM_MAINNET_CHAIN_ID,
        displayName: "Optimism",
        logo: "optimism.svg",
        rpcTarget: `https://optimism-mainnet.infura.io/v3/${INFURA_KEY}`,
        ticker: "ETH",
        tickerName: "Ethereum"
    },
    [CELO_MAINNET_CHAIN_ID]: {
        chainNamespace: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CHAIN_NAMESPACES"].EIP155,
        decimals: 18,
        blockExplorerUrl: "https://explorer.celo.org",
        chainId: CELO_MAINNET_CHAIN_ID,
        displayName: "Celo Mainnet",
        logo: "celo.svg",
        rpcTarget: `https://celo-mainnet.infura.io/v3/${INFURA_KEY}`,
        ticker: "CELO",
        tickerName: "Celo"
    },
    [ARBITRUM_MAINNET_CHAIN_ID]: {
        chainNamespace: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CHAIN_NAMESPACES"].EIP155,
        decimals: 18,
        blockExplorerUrl: "https://arbiscan.io",
        chainId: ARBITRUM_MAINNET_CHAIN_ID,
        displayName: "Arbitrum One",
        logo: "arbitrum.svg",
        rpcTarget: `https://arbitrum-mainnet.infura.io/v3/${INFURA_KEY}`,
        ticker: "ETH",
        tickerName: "Ethereum"
    },
    [BASE_CHAIN_ID]: {
        chainNamespace: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CHAIN_NAMESPACES"].EIP155,
        decimals: 18,
        blockExplorerUrl: "https://basescan.org",
        chainId: BASE_CHAIN_ID,
        displayName: "Base",
        logo: "base.svg",
        rpcTarget: `https://mainnet.base.org`,
        ticker: "ETH",
        tickerName: "Ethereum"
    },
    [LINEA_CHAIN_ID]: {
        chainNamespace: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CHAIN_NAMESPACES"].EIP155,
        decimals: 18,
        blockExplorerUrl: "https://lineascan.build",
        chainId: LINEA_CHAIN_ID,
        displayName: "Linea",
        logo: "linea.svg",
        rpcTarget: `https://linea-mainnet.infura.io/v3/${INFURA_KEY}`,
        ticker: "ETH",
        tickerName: "Ethereum"
    },
    [SEPOLIA_CHAIN_ID]: {
        chainNamespace: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CHAIN_NAMESPACES"].EIP155,
        decimals: 18,
        blockExplorerUrl: "https://sepolia.etherscan.io",
        chainId: SEPOLIA_CHAIN_ID,
        displayName: "Sepolia Test Network",
        logo: "eth.svg",
        rpcTarget: `https://sepolia.infura.io/v3/${INFURA_KEY}`,
        ticker: "ETH",
        tickerName: "Ethereum",
        isTestnet: true
    },
    [LINEA_SEPOLIA_CHAIN_ID]: {
        chainNamespace: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CHAIN_NAMESPACES"].EIP155,
        decimals: 18,
        blockExplorerUrl: "https://sepolia.lineascan.build",
        chainId: LINEA_SEPOLIA_CHAIN_ID,
        displayName: "Linea Sepolia Testnet",
        logo: "linea.svg",
        rpcTarget: `https://linea-sepolia.infura.io/v3/${INFURA_KEY}`,
        ticker: "ETH",
        tickerName: "Ethereum",
        isTestnet: true
    },
    [POLYGON_AMOY_CHAIN_ID]: {
        chainNamespace: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CHAIN_NAMESPACES"].EIP155,
        decimals: 18,
        blockExplorerUrl: "https://amoy.polygonscan.com",
        chainId: POLYGON_AMOY_CHAIN_ID,
        displayName: "Polygon Amoy",
        logo: "polygon.svg",
        rpcTarget: `https://polygon-amoy.infura.io/v3/${INFURA_KEY}`,
        ticker: "POL",
        tickerName: "Polygon Ecosystem Token",
        isTestnet: true
    },
    [BSC_TESTNET_CHAIN_ID]: {
        chainNamespace: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CHAIN_NAMESPACES"].EIP155,
        decimals: 18,
        blockExplorerUrl: "https://testnet.bscscan.com",
        chainId: BSC_TESTNET_CHAIN_ID,
        displayName: "Binance Smart Chain Testnet",
        logo: "bnb_logo.svg",
        rpcTarget: `https://data-seed-prebsc-1-s1.binance.org:8545`,
        ticker: "BNB",
        tickerName: "Binance Coin",
        isTestnet: true
    },
    [AVALANCHE_TESTNET_CHAIN_ID]: {
        chainNamespace: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CHAIN_NAMESPACES"].EIP155,
        decimals: 18,
        blockExplorerUrl: "https://testnet.snowtrace.io",
        chainId: AVALANCHE_TESTNET_CHAIN_ID,
        displayName: "Avalanche Testnet C-Chain",
        logo: "avax.svg",
        rpcTarget: `https://api.avax-test.network/ext/bc/C/rpc`,
        ticker: "AVAX",
        tickerName: "Avalanche",
        isTestnet: true
    },
    [ARBITRUM_TESTNET_CHAIN_ID]: {
        chainNamespace: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CHAIN_NAMESPACES"].EIP155,
        decimals: 18,
        blockExplorerUrl: "https://sepolia.arbiscan.io",
        chainId: ARBITRUM_TESTNET_CHAIN_ID,
        displayName: "Arbitrum Sepolia",
        logo: "arbitrum.svg",
        rpcTarget: `https://arbitrum-sepolia.infura.io/v3/${INFURA_KEY}`,
        ticker: "ETH",
        tickerName: "Ethereum",
        isTestnet: true
    },
    [OPTIMISM_TESTNET_CHAIN_ID]: {
        chainNamespace: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CHAIN_NAMESPACES"].EIP155,
        decimals: 18,
        blockExplorerUrl: "https://sepolia-optimistic.etherscan.io",
        chainId: OPTIMISM_TESTNET_CHAIN_ID,
        displayName: "Optimism Sepolia",
        logo: "optimism.svg",
        rpcTarget: `https://optimism-sepolia.infura.io/v3/${INFURA_KEY}`,
        ticker: "ETH",
        tickerName: "Ethereum",
        isTestnet: true
    },
    [BASE_TESTNET_CHAIN_ID]: {
        chainNamespace: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$node_modules$2f40$toruslabs$2f$base$2d$controllers$2f$dist$2f$lib$2e$esm$2f$Network$2f$INetworkController$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CHAIN_NAMESPACES"].EIP155,
        decimals: 18,
        blockExplorerUrl: "https://sepolia.basescan.org",
        chainId: BASE_TESTNET_CHAIN_ID,
        displayName: "Base Sepolia",
        logo: "base.svg",
        rpcTarget: `https://sepolia.base.org`,
        ticker: "ETH",
        tickerName: "Ethereum",
        isTestnet: true
    }
};
const METHOD_TYPES = {
    GET_ACCOUNTS: "eth_accounts",
    ETH_TRANSACTION: "eth_sendTransaction",
    ETH_SIGN_TRANSACTION: "eth_signTransaction",
    // In TransferToken UI of WS, we call this method via JRPC provider to get gas estimation for a user op. Renamed to avoid conflict with bundler's gas estimation method
    ETH_ESTIMATE_AA_TRANSACTION_GAS: "eth_estimateAATransactionGas",
    // start bundler methods
    ETH_ESTIMATE_USER_OPERATION_GAS: "eth_estimateUserOperationGas",
    ETH_GET_SUPPORTED_ENTRY_POINTS: "eth_supportedEntryPoints",
    ETH_GET_USER_OPERATION: "eth_getUserOperationByHash",
    ETH_GET_USER_OPERATION_RECEIPT: "eth_getUserOperationReceipt",
    ETH_SEND_USER_OPERATION: "eth_sendUserOperation",
    PIMLICO_GET_USER_OPERATION_GAS_PRICE: "pimlico_getUserOperationGasPrice",
    PIMLICO_GET_USER_OPERATION_STATUS: "pimlico_getUserOperationStatus",
    PIMLICO_SIMULATE_ASSET_CHANGES: "pimlico_simulateAssetChanges",
    BICONOMY_GET_GAS_FEE_VALUES: "biconomy_getGasFeeValues",
    BICONOMY_GET_USER_OPERATION_STATUS: "biconomy_getUserOperationStatus",
    // end bundler methods
    // start paymaster methods
    ETH_GET_PAYMASTER_DATA: "pm_getPaymasterData",
    ETH_GET_PAYMASTER_STUB_DATA: "pm_getPaymasterStubData",
    ETH_SPONSOR_USER_OPERATION: "pm_sponsorUserOperation",
    ETH_GET_FEE_QUOTE_OR_DATA: "pm_getFeeQuoteOrData",
    PIMLICO_GET_TOKEN_QUOTES: "pimlico_getTokenQuotes",
    // end paymaster methods
    ETH_REQUEST_ACCOUNTS: "eth_requestAccounts",
    ETH_SEND_RAW_TRANSACTION: "eth_sendRawTransaction",
    ETH_SIGN: "eth_sign",
    ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
    PERSONAL_SIGN: "personal_sign",
    ETH_GET_TRANSACTION_COUNT: "eth_getTransactionCount",
    ETH_GET_TRANSACTION_BY_HASH: "eth_getTransactionByHash",
    ETH_GET_TRANSACTION_RECEIPT: "eth_getTransactionReceipt",
    WATCH_ASSET: "wallet_watchAsset",
    ETH_GET_BLOCK_BY_HASH: "eth_getBlockByHash",
    ETH_GET_CODE: "eth_getCode",
    ETH_GET_GAS_PRICE: "eth_gasPrice",
    ETH_PRIVATE_KEY: "eth_privateKey",
    PRIVATE_KEY: "private_key",
    ETH_PUBLIC_KEY: "eth_publicKey",
    PUBLIC_KEY: "public_key",
    SWITCH_CHAIN: "wallet_switchEthereumChain",
    ADD_CHAIN: "wallet_addEthereumChain"
};
const BUNDLER_METHOD_TYPES = [
    METHOD_TYPES.ETH_ESTIMATE_USER_OPERATION_GAS,
    METHOD_TYPES.ETH_GET_SUPPORTED_ENTRY_POINTS,
    METHOD_TYPES.ETH_GET_USER_OPERATION,
    METHOD_TYPES.ETH_GET_USER_OPERATION_RECEIPT,
    METHOD_TYPES.ETH_SEND_USER_OPERATION,
    METHOD_TYPES.PIMLICO_GET_USER_OPERATION_GAS_PRICE,
    METHOD_TYPES.PIMLICO_GET_USER_OPERATION_STATUS,
    METHOD_TYPES.PIMLICO_SIMULATE_ASSET_CHANGES,
    METHOD_TYPES.BICONOMY_GET_GAS_FEE_VALUES,
    METHOD_TYPES.BICONOMY_GET_USER_OPERATION_STATUS
];
const PAYMASTER_METHOD_TYPES = [
    METHOD_TYPES.ETH_GET_PAYMASTER_DATA,
    METHOD_TYPES.ETH_GET_PAYMASTER_STUB_DATA,
    METHOD_TYPES.ETH_SPONSOR_USER_OPERATION,
    METHOD_TYPES.PIMLICO_GET_TOKEN_QUOTES,
    METHOD_TYPES.ETH_GET_FEE_QUOTE_OR_DATA
];
const TRANSACTION_ENVELOPE_TYPES = {
    LEGACY: "0x0",
    ACCESS_LIST: "0x1",
    FEE_MARKET: "0x2"
};
const GAS_ESTIMATE_TYPES = {
    // Fee Market describes the way gas is set after the london hardfork, and was
    // defined by EIP-1559.
    FEE_MARKET: "fee-market",
    // Legacy describes gasPrice estimates from before london hardfork, when the
    // user is connected to mainnet and are presented with fast/average/slow
    // estimate levels to choose from.
    LEGACY: "legacy",
    // EthGasPrice describes a gasPrice estimate received from eth_gasPrice. Post
    // london this value should only be used for legacy type transactions when on
    // networks that support EIP-1559. This type of estimate is the most accurate
    // to display on custom networks that don't support EIP-1559.
    ETH_GASPRICE: "eth_gasPrice",
    // NoEstimate describes the state of the controller before receiving its first
    // estimate.
    NONE: "none"
};
// https://help.optimism.io/hc/en-us/articles/4411895794715-Transaction-fees
const CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP = {
    [OPTIMISM_MAINNET_CHAIN_ID]: 1,
    [OPTIMISM_TESTNET_CHAIN_ID]: 1
};
const OLD_ERC721_LIST = {
    "0x06012c8cf97bead5deae237070f9587f8e7a266d": {
        name: "Cryptokitties",
        logo: "dapp-cryptokitty.svg",
        erc20: true,
        symbol: "CK",
        decimals: 0
    }
};
const TEST_CHAINS = [
    SEPOLIA_CHAIN_ID
];
const MM_TOKEN_API_SUPPORTED_CHAINS = [
    MAINNET_CHAIN_ID,
    SEPOLIA_CHAIN_ID,
    BSC_MAINNET_CHAIN_ID,
    BSC_TESTNET_CHAIN_ID,
    OPTIMISM_MAINNET_CHAIN_ID,
    OPTIMISM_TESTNET_CHAIN_ID,
    AVALANCHE_MAINNET_CHAIN_ID,
    AVALANCHE_TESTNET_CHAIN_ID,
    ARBITRUM_MAINNET_CHAIN_ID,
    ARBITRUM_TESTNET_CHAIN_ID,
    POLYGON_CHAIN_ID,
    POLYGON_AMOY_CHAIN_ID,
    CELO_MAINNET_CHAIN_ID,
    BASE_CHAIN_ID,
    BASE_TESTNET_CHAIN_ID,
    LINEA_CHAIN_ID,
    LINEA_SEPOLIA_CHAIN_ID
];
const MM_NFT_API_SUPPORTED_CHAINS = [
    MAINNET_CHAIN_ID,
    POLYGON_CHAIN_ID,
    BSC_MAINNET_CHAIN_ID,
    AVALANCHE_MAINNET_CHAIN_ID,
    LINEA_CHAIN_ID,
    BASE_CHAIN_ID
];
const COINGECKO_SUPPORTED_CURRENCIES = new Set([
    "btc",
    "eth",
    "ltc",
    "bch",
    "bnb",
    "eos",
    "xrp",
    "xlm",
    "link",
    "dot",
    "yfi",
    "usd",
    "aed",
    "ars",
    "aud",
    "bdt",
    "bhd",
    "bmd",
    "brl",
    "cad",
    "chf",
    "clp",
    "cny",
    "czk",
    "dkk",
    "eur",
    "gbp",
    "hkd",
    "huf",
    "idr",
    "ils",
    "inr",
    "jpy",
    "krw",
    "kwd",
    "lkr",
    "mmk",
    "mxn",
    "myr",
    "ngn",
    "nok",
    "nzd",
    "php",
    "pkr",
    "pln",
    "rub",
    "sar",
    "sek",
    "sgd",
    "thb",
    "try",
    "twd",
    "uah",
    "vef",
    "vnd",
    "zar",
    "xdr",
    "xag",
    "xau",
    "bits",
    "sats"
]);
const COINGECKO_PLATFORMS_CHAIN_CODE_MAP = {
    [POLYGON_CHAIN_ID]: {
        platform: "polygon-pos",
        currency: "pol"
    },
    [BSC_MAINNET_CHAIN_ID]: {
        platform: "binance-smart-chain",
        currency: "bnb"
    },
    [MAINNET_CHAIN_ID]: {
        platform: "ethereum",
        currency: "eth"
    },
    [ARBITRUM_MAINNET_CHAIN_ID]: {
        platform: "arbitrum-one",
        currency: "eth"
    },
    [OPTIMISM_MAINNET_CHAIN_ID]: {
        platform: "optimistic-ethereum",
        currency: "eth"
    },
    [CELO_MAINNET_CHAIN_ID]: {
        platform: "celo",
        currency: "celo"
    },
    [XDAI_CHAIN_ID]: {
        platform: "xdai",
        currency: "xDAI"
    },
    [AVALANCHE_MAINNET_CHAIN_ID]: {
        platform: "avalanche",
        currency: "avax"
    },
    [BASE_CHAIN_ID]: {
        platform: "base",
        currency: "eth"
    }
};
const SMART_ACCOUNT = {
    BICONOMY: "biconomy",
    KERNEL: "kernel",
    SAFE: "safe",
    TRUST: "trust",
    // TODO: disabled because of pimlico issues
    LIGHT: "light",
    SIMPLE: "simple",
    NEXUS: "nexus",
    METAMASK: "metamask"
};
;
}),
"[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/AccountAbstraction/smartAccounts/BiconomySmartAccount.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BiconomySmartAccount",
    ()=>BiconomySmartAccount
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$permissionless$2f$_esm$2f$accounts$2f$biconomy$2f$toBiconomySmartAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/permissionless/_esm/accounts/biconomy/toBiconomySmartAccount.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$account$2d$abstraction$2f$constants$2f$address$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/account-abstraction/constants/address.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/utils/constants.js [app-ssr] (ecmascript)");
;
;
;
;
;
class BiconomySmartAccount {
    constructor(options){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "name", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SMART_ACCOUNT"].BICONOMY);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "options", void 0);
        this.options = options;
    }
    async getSmartAccount(params) {
        var _this$options, _this$options2;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$permissionless$2f$_esm$2f$accounts$2f$biconomy$2f$toBiconomySmartAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toBiconomySmartAccount"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, this.options || {}), {}, {
            entryPoint: {
                address: ((_this$options = this.options) === null || _this$options === void 0 || (_this$options = _this$options.entryPoint) === null || _this$options === void 0 ? void 0 : _this$options.address) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$account$2d$abstraction$2f$constants$2f$address$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["entryPoint06Address"],
                version: ((_this$options2 = this.options) === null || _this$options2 === void 0 || (_this$options2 = _this$options2.entryPoint) === null || _this$options2 === void 0 ? void 0 : _this$options2.version) || "0.6"
            }
        }, params), {}, {
            owners: [
                params.walletClient
            ],
            client: params.client
        }));
    }
}
;
}),
"[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/AccountAbstraction/smartAccounts/KernelSmartAccount.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "KernelSmartAccount",
    ()=>KernelSmartAccount
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$permissionless$2f$_esm$2f$accounts$2f$kernel$2f$toEcdsaKernelSmartAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/permissionless/_esm/accounts/kernel/toEcdsaKernelSmartAccount.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/utils/constants.js [app-ssr] (ecmascript)");
;
;
;
;
class KernelSmartAccount {
    constructor(options){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "name", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SMART_ACCOUNT"].KERNEL);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "options", void 0);
        this.options = options;
    }
    async getSmartAccount(params) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$permissionless$2f$_esm$2f$accounts$2f$kernel$2f$toEcdsaKernelSmartAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toEcdsaKernelSmartAccount"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, this.options || {}), params), {}, {
            owners: [
                params.walletClient
            ],
            client: params.client
        }));
    }
}
;
}),
"[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/AccountAbstraction/smartAccounts/MetamaskSmartAccount.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MetamaskSmartAccount",
    ()=>MetamaskSmartAccount
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$delegation$2d$toolkit$2f$dist$2f$chunk$2d$NV2Z25GV$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/delegation-toolkit/dist/chunk-NV2Z25GV.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$delegation$2d$toolkit$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@metamask/delegation-toolkit/dist/index.mjs [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/utils/constants.js [app-ssr] (ecmascript)");
;
;
;
;
class MetamaskSmartAccount {
    constructor(options){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "name", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SMART_ACCOUNT"].METAMASK);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "options", void 0);
        this.options = options;
    }
    async getSmartAccount(input) {
        var _this$options, _this$options2, _this$options3, _this$options4, _this$options5, _this$options6, _this$options7, _this$options$multiSi, _this$options8, _this$options9, _this$options$deployS, _this$options0, _this$options$impleme, _this$options1;
        const hybridSignatory = {
            walletClient: input.walletClient,
            webAuthnAccount: (_this$options = this.options) === null || _this$options === void 0 || (_this$options = _this$options.hybridParams) === null || _this$options === void 0 ? void 0 : _this$options.webAuthnAccount,
            keyId: (_this$options2 = this.options) === null || _this$options2 === void 0 || (_this$options2 = _this$options2.hybridParams) === null || _this$options2 === void 0 ? void 0 : _this$options2.keyId
        };
        const multiSigSignatory = [
            {
                walletClient: input.walletClient
            },
            ...((_this$options3 = this.options) === null || _this$options3 === void 0 || (_this$options3 = _this$options3.multiSigParams) === null || _this$options3 === void 0 ? void 0 : _this$options3.additionalSignerWalletClients) || []
        ];
        const [eoaAddress] = await input.walletClient.getAddresses();
        const hybridDeployParams = [
            eoaAddress,
            [
                ...((_this$options4 = this.options) === null || _this$options4 === void 0 || (_this$options4 = _this$options4.hybridParams) === null || _this$options4 === void 0 ? void 0 : _this$options4.p256KeyIds) || []
            ],
            [
                ...((_this$options5 = this.options) === null || _this$options5 === void 0 || (_this$options5 = _this$options5.hybridParams) === null || _this$options5 === void 0 ? void 0 : _this$options5.p256XValues) || []
            ],
            [
                ...((_this$options6 = this.options) === null || _this$options6 === void 0 || (_this$options6 = _this$options6.hybridParams) === null || _this$options6 === void 0 ? void 0 : _this$options6.p256YValues) || []
            ]
        ];
        const multiSigDeployParams = [
            [
                eoaAddress,
                ...((_this$options7 = this.options) === null || _this$options7 === void 0 || (_this$options7 = _this$options7.multiSigParams) === null || _this$options7 === void 0 ? void 0 : _this$options7.additionalSignerAddresses) || []
            ],
            (_this$options$multiSi = (_this$options8 = this.options) === null || _this$options8 === void 0 || (_this$options8 = _this$options8.multiSigParams) === null || _this$options8 === void 0 ? void 0 : _this$options8.threshold) !== null && _this$options$multiSi !== void 0 ? _this$options$multiSi : BigInt(1 + (((_this$options9 = this.options) === null || _this$options9 === void 0 || (_this$options9 = _this$options9.multiSigParams) === null || _this$options9 === void 0 || (_this$options9 = _this$options9.additionalSignerWalletClients) === null || _this$options9 === void 0 ? void 0 : _this$options9.length) || 0))
        ];
        const baseParams = {
            client: input.client,
            deploySalt: (_this$options$deployS = (_this$options0 = this.options) === null || _this$options0 === void 0 ? void 0 : _this$options0.deploySalt) !== null && _this$options$deployS !== void 0 ? _this$options$deployS : "0x0"
        };
        const implementation = (_this$options$impleme = (_this$options1 = this.options) === null || _this$options1 === void 0 ? void 0 : _this$options1.implementation) !== null && _this$options$impleme !== void 0 ? _this$options$impleme : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$delegation$2d$toolkit$2f$dist$2f$chunk$2d$NV2Z25GV$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Implementation"].Hybrid;
        if (implementation === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$delegation$2d$toolkit$2f$dist$2f$chunk$2d$NV2Z25GV$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Implementation"].Hybrid) {
            const params = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, baseParams), {}, {
                implementation,
                deployParams: hybridDeployParams,
                signer: hybridSignatory
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$delegation$2d$toolkit$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toMetaMaskSmartAccount"])(params);
        } else if (implementation === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$delegation$2d$toolkit$2f$dist$2f$chunk$2d$NV2Z25GV$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Implementation"].MultiSig) {
            const params = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, baseParams), {}, {
                implementation,
                deployParams: multiSigDeployParams,
                signer: multiSigSignatory
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$delegation$2d$toolkit$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toMetaMaskSmartAccount"])(params);
        } else {
            throw new Error(`MetamaskSmartAccount - unsupported implementation: ${implementation}`);
        }
    }
}
;
}),
"[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/AccountAbstraction/smartAccounts/NexusSmartAccount.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "NexusSmartAccount",
    ()=>NexusSmartAccount
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$permissionless$2f$_esm$2f$accounts$2f$nexus$2f$toNexusSmartAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/permissionless/_esm/accounts/nexus/toNexusSmartAccount.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$account$2d$abstraction$2f$constants$2f$address$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/account-abstraction/constants/address.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/utils/constants.js [app-ssr] (ecmascript)");
;
;
;
;
;
class NexusSmartAccount {
    constructor(options){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "name", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SMART_ACCOUNT"].NEXUS);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "options", void 0);
        this.options = options;
    }
    async getSmartAccount(params) {
        var _this$options, _this$options2, _this$options3;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$permissionless$2f$_esm$2f$accounts$2f$nexus$2f$toNexusSmartAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toNexusSmartAccount"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, this.options || {}), {}, {
            entryPoint: {
                address: ((_this$options = this.options) === null || _this$options === void 0 || (_this$options = _this$options.entryPoint) === null || _this$options === void 0 ? void 0 : _this$options.address) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$account$2d$abstraction$2f$constants$2f$address$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["entryPoint07Address"],
                version: ((_this$options2 = this.options) === null || _this$options2 === void 0 || (_this$options2 = _this$options2.entryPoint) === null || _this$options2 === void 0 ? void 0 : _this$options2.version) || "0.7"
            },
            version: ((_this$options3 = this.options) === null || _this$options3 === void 0 ? void 0 : _this$options3.version) || "1.0.0"
        }, params), {}, {
            owners: [
                params.walletClient
            ],
            client: params.client
        }));
    }
}
;
}),
"[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/AccountAbstraction/smartAccounts/SafeSmartAccount.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SafeSmartAccount",
    ()=>SafeSmartAccount
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$permissionless$2f$_esm$2f$accounts$2f$safe$2f$toSafeSmartAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/permissionless/_esm/accounts/safe/toSafeSmartAccount.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$account$2d$abstraction$2f$constants$2f$address$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/account-abstraction/constants/address.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/utils/constants.js [app-ssr] (ecmascript)");
;
;
;
;
;
class SafeSmartAccount {
    constructor(options){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "name", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SMART_ACCOUNT"].SAFE);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "options", void 0);
        this.options = options;
    }
    async getSmartAccount(params) {
        var _this$options, _this$options2, _this$options3;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$permissionless$2f$_esm$2f$accounts$2f$safe$2f$toSafeSmartAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toSafeSmartAccount"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, this.options || {}), {}, {
            entryPoint: {
                address: ((_this$options = this.options) === null || _this$options === void 0 || (_this$options = _this$options.entryPoint) === null || _this$options === void 0 ? void 0 : _this$options.address) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$account$2d$abstraction$2f$constants$2f$address$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["entryPoint07Address"],
                version: ((_this$options2 = this.options) === null || _this$options2 === void 0 || (_this$options2 = _this$options2.entryPoint) === null || _this$options2 === void 0 ? void 0 : _this$options2.version) || "0.7"
            },
            version: ((_this$options3 = this.options) === null || _this$options3 === void 0 ? void 0 : _this$options3.version) || "1.4.1"
        }, params), {}, {
            owners: [
                params.walletClient
            ],
            client: params.client
        }));
    }
}
;
}),
"[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/AccountAbstraction/smartAccounts/TrustSmartAccount.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TrustSmartAccount",
    ()=>TrustSmartAccount
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/objectSpread2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/defineProperty.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$permissionless$2f$_esm$2f$accounts$2f$trust$2f$toTrustSmartAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/permissionless/_esm/accounts/trust/toTrustSmartAccount.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$account$2d$abstraction$2f$constants$2f$address$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/viem/_esm/account-abstraction/constants/address.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@toruslabs/ethereum-controllers/dist/lib.esm/utils/constants.js [app-ssr] (ecmascript)");
;
;
;
;
;
class TrustSmartAccount {
    constructor(options){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "name", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$toruslabs$2f$ethereum$2d$controllers$2f$dist$2f$lib$2e$esm$2f$utils$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SMART_ACCOUNT"].TRUST);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$defineProperty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this, "options", void 0);
        this.options = options;
    }
    async getSmartAccount(params) {
        var _this$options, _this$options2;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$permissionless$2f$_esm$2f$accounts$2f$trust$2f$toTrustSmartAccount$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toTrustSmartAccount"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$objectSpread2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({}, this.options || {}), {}, {
            entryPoint: {
                address: ((_this$options = this.options) === null || _this$options === void 0 || (_this$options = _this$options.entryPoint) === null || _this$options === void 0 ? void 0 : _this$options.address) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$account$2d$abstraction$2f$constants$2f$address$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["entryPoint06Address"],
                version: ((_this$options2 = this.options) === null || _this$options2 === void 0 || (_this$options2 = _this$options2.entryPoint) === null || _this$options2 === void 0 ? void 0 : _this$options2.version) || "0.6"
            }
        }, params), {}, {
            owner: params.walletClient,
            client: params.client
        }));
    }
}
;
}),
"[project]/node_modules/abitype/dist/esm/regex.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.
// https://twitter.com/GabrielVergnaud/status/1622906834343366657
__turbopack_context__.s([
    "bytesRegex",
    ()=>bytesRegex,
    "execTyped",
    ()=>execTyped,
    "integerRegex",
    ()=>integerRegex,
    "isTupleRegex",
    ()=>isTupleRegex
]);
function execTyped(regex, string) {
    const match = regex.exec(string);
    return match?.groups;
}
const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
const integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
const isTupleRegex = /^\(.+?\).*?$/; //# sourceMappingURL=regex.js.map
}),
"[project]/node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "formatAbiParameter",
    ()=>formatAbiParameter
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/regex.js [app-ssr] (ecmascript)");
;
// https://regexr.com/7f7rv
const tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
function formatAbiParameter(abiParameter) {
    let type = abiParameter.type;
    if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {
        type = '(';
        const length = abiParameter.components.length;
        for(let i = 0; i < length; i++){
            const component = abiParameter.components[i];
            type += formatAbiParameter(component);
            if (i < length - 1) type += ', ';
        }
        const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["execTyped"])(tupleRegex, abiParameter.type);
        type += `)${result?.array || ''}`;
        return formatAbiParameter({
            ...abiParameter,
            type
        });
    }
    // Add `indexed` to type if in `abiParameter`
    if ('indexed' in abiParameter && abiParameter.indexed) type = `${type} indexed`;
    // Return human-readable ABI parameter
    if (abiParameter.name) return `${type} ${abiParameter.name}`;
    return type;
} //# sourceMappingURL=formatAbiParameter.js.map
}),
"[project]/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "formatAbiParameters",
    ()=>formatAbiParameters
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/formatAbiParameter.js [app-ssr] (ecmascript)");
;
function formatAbiParameters(abiParameters) {
    let params = '';
    const length = abiParameters.length;
    for(let i = 0; i < length; i++){
        const abiParameter = abiParameters[i];
        params += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formatAbiParameter"])(abiParameter);
        if (i !== length - 1) params += ', ';
    }
    return params;
} //# sourceMappingURL=formatAbiParameters.js.map
}),
"[project]/node_modules/abitype/dist/esm/human-readable/formatAbiItem.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "formatAbiItem",
    ()=>formatAbiItem
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js [app-ssr] (ecmascript)");
;
function formatAbiItem(abiItem) {
    if (abiItem.type === 'function') return `function ${abiItem.name}(${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formatAbiParameters"])(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable' ? ` ${abiItem.stateMutability}` : ''}${abiItem.outputs?.length ? ` returns (${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formatAbiParameters"])(abiItem.outputs)})` : ''}`;
    if (abiItem.type === 'event') return `event ${abiItem.name}(${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formatAbiParameters"])(abiItem.inputs)})`;
    if (abiItem.type === 'error') return `error ${abiItem.name}(${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formatAbiParameters"])(abiItem.inputs)})`;
    if (abiItem.type === 'constructor') return `constructor(${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$formatAbiParameters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formatAbiParameters"])(abiItem.inputs)})${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;
    if (abiItem.type === 'fallback') return `fallback() external${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;
    return 'receive() external payable';
} //# sourceMappingURL=formatAbiItem.js.map
}),
"[project]/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "eventModifiers",
    ()=>eventModifiers,
    "execConstructorSignature",
    ()=>execConstructorSignature,
    "execErrorSignature",
    ()=>execErrorSignature,
    "execEventSignature",
    ()=>execEventSignature,
    "execFallbackSignature",
    ()=>execFallbackSignature,
    "execFunctionSignature",
    ()=>execFunctionSignature,
    "execStructSignature",
    ()=>execStructSignature,
    "functionModifiers",
    ()=>functionModifiers,
    "isConstructorSignature",
    ()=>isConstructorSignature,
    "isErrorSignature",
    ()=>isErrorSignature,
    "isEventSignature",
    ()=>isEventSignature,
    "isFallbackSignature",
    ()=>isFallbackSignature,
    "isFunctionSignature",
    ()=>isFunctionSignature,
    "isReceiveSignature",
    ()=>isReceiveSignature,
    "isStructSignature",
    ()=>isStructSignature,
    "modifiers",
    ()=>modifiers
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/regex.js [app-ssr] (ecmascript)");
;
// https://regexr.com/7gmok
const errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isErrorSignature(signature) {
    return errorSignatureRegex.test(signature);
}
function execErrorSignature(signature) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["execTyped"])(errorSignatureRegex, signature);
}
// https://regexr.com/7gmoq
const eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isEventSignature(signature) {
    return eventSignatureRegex.test(signature);
}
function execEventSignature(signature) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["execTyped"])(eventSignatureRegex, signature);
}
// https://regexr.com/7gmot
const functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
function isFunctionSignature(signature) {
    return functionSignatureRegex.test(signature);
}
function execFunctionSignature(signature) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["execTyped"])(functionSignatureRegex, signature);
}
// https://regexr.com/7gmp3
const structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
function isStructSignature(signature) {
    return structSignatureRegex.test(signature);
}
function execStructSignature(signature) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["execTyped"])(structSignatureRegex, signature);
}
// https://regexr.com/78u01
const constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
function isConstructorSignature(signature) {
    return constructorSignatureRegex.test(signature);
}
function execConstructorSignature(signature) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["execTyped"])(constructorSignatureRegex, signature);
}
// https://regexr.com/7srtn
const fallbackSignatureRegex = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
function isFallbackSignature(signature) {
    return fallbackSignatureRegex.test(signature);
}
function execFallbackSignature(signature) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["execTyped"])(fallbackSignatureRegex, signature);
}
// https://regexr.com/78u1k
const receiveSignatureRegex = /^receive\(\) external payable$/;
function isReceiveSignature(signature) {
    return receiveSignatureRegex.test(signature);
}
const modifiers = new Set([
    'memory',
    'indexed',
    'storage',
    'calldata'
]);
const eventModifiers = new Set([
    'indexed'
]);
const functionModifiers = new Set([
    'calldata',
    'memory',
    'storage'
]); //# sourceMappingURL=signatures.js.map
}),
"[project]/node_modules/abitype/dist/esm/version.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "version",
    ()=>version
]);
const version = '1.2.3'; //# sourceMappingURL=version.js.map
}),
"[project]/node_modules/abitype/dist/esm/errors.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BaseError",
    ()=>BaseError
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$version$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/version.js [app-ssr] (ecmascript)");
;
class BaseError extends Error {
    constructor(shortMessage, args = {}){
        const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
        const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
        const message = [
            shortMessage || 'An error occurred.',
            '',
            ...args.metaMessages ? [
                ...args.metaMessages,
                ''
            ] : [],
            ...docsPath ? [
                `Docs: https://abitype.dev${docsPath}`
            ] : [],
            ...details ? [
                `Details: ${details}`
            ] : [],
            `Version: abitype@${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$version$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["version"]}`
        ].join('\n');
        super(message);
        Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiTypeError'
        });
        if (args.cause) this.cause = args.cause;
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.shortMessage = shortMessage;
    }
} //# sourceMappingURL=errors.js.map
}),
"[project]/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InvalidAbiItemError",
    ()=>InvalidAbiItemError,
    "UnknownSolidityTypeError",
    ()=>UnknownSolidityTypeError,
    "UnknownTypeError",
    ()=>UnknownTypeError
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/errors.js [app-ssr] (ecmascript)");
;
class InvalidAbiItemError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor({ signature }){
        super('Failed to parse ABI item.', {
            details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,
            docsPath: '/api/human#parseabiitem-1'
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidAbiItemError'
        });
    }
}
class UnknownTypeError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor({ type }){
        super('Unknown type.', {
            metaMessages: [
                `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'UnknownTypeError'
        });
    }
}
class UnknownSolidityTypeError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor({ type }){
        super('Unknown type.', {
            metaMessages: [
                `Type "${type}" is not a valid ABI type.`
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'UnknownSolidityTypeError'
        });
    }
} //# sourceMappingURL=abiItem.js.map
}),
"[project]/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InvalidAbiParameterError",
    ()=>InvalidAbiParameterError,
    "InvalidAbiParametersError",
    ()=>InvalidAbiParametersError,
    "InvalidAbiTypeParameterError",
    ()=>InvalidAbiTypeParameterError,
    "InvalidFunctionModifierError",
    ()=>InvalidFunctionModifierError,
    "InvalidModifierError",
    ()=>InvalidModifierError,
    "InvalidParameterError",
    ()=>InvalidParameterError,
    "SolidityProtectedKeywordError",
    ()=>SolidityProtectedKeywordError
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/errors.js [app-ssr] (ecmascript)");
;
class InvalidAbiParameterError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor({ param }){
        super('Failed to parse ABI parameter.', {
            details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,
            docsPath: '/api/human#parseabiparameter-1'
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidAbiParameterError'
        });
    }
}
class InvalidAbiParametersError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor({ params }){
        super('Failed to parse ABI parameters.', {
            details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,
            docsPath: '/api/human#parseabiparameters-1'
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidAbiParametersError'
        });
    }
}
class InvalidParameterError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor({ param }){
        super('Invalid ABI parameter.', {
            details: param
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidParameterError'
        });
    }
}
class SolidityProtectedKeywordError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor({ param, name }){
        super('Invalid ABI parameter.', {
            details: param,
            metaMessages: [
                `"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'SolidityProtectedKeywordError'
        });
    }
}
class InvalidModifierError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor({ param, type, modifier }){
        super('Invalid ABI parameter.', {
            details: param,
            metaMessages: [
                `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ''}.`
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidModifierError'
        });
    }
}
class InvalidFunctionModifierError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor({ param, type, modifier }){
        super('Invalid ABI parameter.', {
            details: param,
            metaMessages: [
                `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ''}.`,
                `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidFunctionModifierError'
        });
    }
}
class InvalidAbiTypeParameterError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor({ abiParameter }){
        super('Invalid ABI parameter.', {
            details: JSON.stringify(abiParameter, null, 2),
            metaMessages: [
                'ABI parameter type is invalid.'
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidAbiTypeParameterError'
        });
    }
} //# sourceMappingURL=abiParameter.js.map
}),
"[project]/node_modules/abitype/dist/esm/human-readable/errors/signature.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InvalidSignatureError",
    ()=>InvalidSignatureError,
    "InvalidStructSignatureError",
    ()=>InvalidStructSignatureError,
    "UnknownSignatureError",
    ()=>UnknownSignatureError
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/errors.js [app-ssr] (ecmascript)");
;
class InvalidSignatureError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor({ signature, type }){
        super(`Invalid ${type} signature.`, {
            details: signature
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidSignatureError'
        });
    }
}
class UnknownSignatureError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor({ signature }){
        super('Unknown signature.', {
            details: signature
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'UnknownSignatureError'
        });
    }
}
class InvalidStructSignatureError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor({ signature }){
        super('Invalid struct signature.', {
            details: signature,
            metaMessages: [
                'No properties exist.'
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidStructSignatureError'
        });
    }
} //# sourceMappingURL=signature.js.map
}),
"[project]/node_modules/abitype/dist/esm/human-readable/errors/struct.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CircularReferenceError",
    ()=>CircularReferenceError
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/errors.js [app-ssr] (ecmascript)");
;
class CircularReferenceError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor({ type }){
        super('Circular reference detected.', {
            metaMessages: [
                `Struct "${type}" is a circular reference.`
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'CircularReferenceError'
        });
    }
} //# sourceMappingURL=struct.js.map
}),
"[project]/node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InvalidParenthesisError",
    ()=>InvalidParenthesisError
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/errors.js [app-ssr] (ecmascript)");
;
class InvalidParenthesisError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseError"] {
    constructor({ current, depth }){
        super('Unbalanced parentheses.', {
            metaMessages: [
                `"${current.trim()}" has too many ${depth > 0 ? 'opening' : 'closing'} parentheses.`
            ],
            details: `Depth "${depth}"`
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidParenthesisError'
        });
    }
} //# sourceMappingURL=splitParameters.js.map
}),
"[project]/node_modules/abitype/dist/esm/human-readable/runtime/cache.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Gets {@link parameterCache} cache key namespaced by {@link type} and {@link structs}. This prevents parameters from being accessible to types that don't allow them (e.g. `string indexed foo` not allowed outside of `type: 'event'`) and ensures different struct definitions with the same name are cached separately.
 * @param param ABI parameter string
 * @param type ABI parameter type
 * @param structs Struct definitions to include in cache key
 * @returns Cache key for {@link parameterCache}
 */ __turbopack_context__.s([
    "getParameterCacheKey",
    ()=>getParameterCacheKey,
    "parameterCache",
    ()=>parameterCache
]);
function getParameterCacheKey(param, type, structs) {
    let structKey = '';
    if (structs) for (const struct of Object.entries(structs)){
        if (!struct) continue;
        let propertyKey = '';
        for (const property of struct[1]){
            propertyKey += `[${property.type}${property.name ? `:${property.name}` : ''}]`;
        }
        structKey += `(${struct[0]}{${propertyKey}})`;
    }
    if (type) return `${type}:${param}${structKey}`;
    return `${param}${structKey}`;
}
const parameterCache = new Map([
    // Unnamed
    [
        'address',
        {
            type: 'address'
        }
    ],
    [
        'bool',
        {
            type: 'bool'
        }
    ],
    [
        'bytes',
        {
            type: 'bytes'
        }
    ],
    [
        'bytes32',
        {
            type: 'bytes32'
        }
    ],
    [
        'int',
        {
            type: 'int256'
        }
    ],
    [
        'int256',
        {
            type: 'int256'
        }
    ],
    [
        'string',
        {
            type: 'string'
        }
    ],
    [
        'uint',
        {
            type: 'uint256'
        }
    ],
    [
        'uint8',
        {
            type: 'uint8'
        }
    ],
    [
        'uint16',
        {
            type: 'uint16'
        }
    ],
    [
        'uint24',
        {
            type: 'uint24'
        }
    ],
    [
        'uint32',
        {
            type: 'uint32'
        }
    ],
    [
        'uint64',
        {
            type: 'uint64'
        }
    ],
    [
        'uint96',
        {
            type: 'uint96'
        }
    ],
    [
        'uint112',
        {
            type: 'uint112'
        }
    ],
    [
        'uint160',
        {
            type: 'uint160'
        }
    ],
    [
        'uint192',
        {
            type: 'uint192'
        }
    ],
    [
        'uint256',
        {
            type: 'uint256'
        }
    ],
    // Named
    [
        'address owner',
        {
            type: 'address',
            name: 'owner'
        }
    ],
    [
        'address to',
        {
            type: 'address',
            name: 'to'
        }
    ],
    [
        'bool approved',
        {
            type: 'bool',
            name: 'approved'
        }
    ],
    [
        'bytes _data',
        {
            type: 'bytes',
            name: '_data'
        }
    ],
    [
        'bytes data',
        {
            type: 'bytes',
            name: 'data'
        }
    ],
    [
        'bytes signature',
        {
            type: 'bytes',
            name: 'signature'
        }
    ],
    [
        'bytes32 hash',
        {
            type: 'bytes32',
            name: 'hash'
        }
    ],
    [
        'bytes32 r',
        {
            type: 'bytes32',
            name: 'r'
        }
    ],
    [
        'bytes32 root',
        {
            type: 'bytes32',
            name: 'root'
        }
    ],
    [
        'bytes32 s',
        {
            type: 'bytes32',
            name: 's'
        }
    ],
    [
        'string name',
        {
            type: 'string',
            name: 'name'
        }
    ],
    [
        'string symbol',
        {
            type: 'string',
            name: 'symbol'
        }
    ],
    [
        'string tokenURI',
        {
            type: 'string',
            name: 'tokenURI'
        }
    ],
    [
        'uint tokenId',
        {
            type: 'uint256',
            name: 'tokenId'
        }
    ],
    [
        'uint8 v',
        {
            type: 'uint8',
            name: 'v'
        }
    ],
    [
        'uint256 balance',
        {
            type: 'uint256',
            name: 'balance'
        }
    ],
    [
        'uint256 tokenId',
        {
            type: 'uint256',
            name: 'tokenId'
        }
    ],
    [
        'uint256 value',
        {
            type: 'uint256',
            name: 'value'
        }
    ],
    // Indexed
    [
        'event:address indexed from',
        {
            type: 'address',
            name: 'from',
            indexed: true
        }
    ],
    [
        'event:address indexed to',
        {
            type: 'address',
            name: 'to',
            indexed: true
        }
    ],
    [
        'event:uint indexed tokenId',
        {
            type: 'uint256',
            name: 'tokenId',
            indexed: true
        }
    ],
    [
        'event:uint256 indexed tokenId',
        {
            type: 'uint256',
            name: 'tokenId',
            indexed: true
        }
    ]
]); //# sourceMappingURL=cache.js.map
}),
"[project]/node_modules/abitype/dist/esm/human-readable/runtime/utils.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isSolidityKeyword",
    ()=>isSolidityKeyword,
    "isSolidityType",
    ()=>isSolidityType,
    "isValidDataLocation",
    ()=>isValidDataLocation,
    "parseAbiParameter",
    ()=>parseAbiParameter,
    "parseConstructorSignature",
    ()=>parseConstructorSignature,
    "parseErrorSignature",
    ()=>parseErrorSignature,
    "parseEventSignature",
    ()=>parseEventSignature,
    "parseFallbackSignature",
    ()=>parseFallbackSignature,
    "parseFunctionSignature",
    ()=>parseFunctionSignature,
    "parseSignature",
    ()=>parseSignature,
    "splitParameters",
    ()=>splitParameters
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/regex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$abiItem$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$abiParameter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/errors/signature.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$splitParameters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/errors/splitParameters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$cache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/runtime/cache.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
function parseSignature(signature, structs = {}) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isFunctionSignature"])(signature)) return parseFunctionSignature(signature, structs);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isEventSignature"])(signature)) return parseEventSignature(signature, structs);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isErrorSignature"])(signature)) return parseErrorSignature(signature, structs);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isConstructorSignature"])(signature)) return parseConstructorSignature(signature, structs);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isFallbackSignature"])(signature)) return parseFallbackSignature(signature);
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isReceiveSignature"])(signature)) return {
        type: 'receive',
        stateMutability: 'payable'
    };
    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnknownSignatureError"]({
        signature
    });
}
function parseFunctionSignature(signature, structs = {}) {
    const match = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["execFunctionSignature"])(signature);
    if (!match) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InvalidSignatureError"]({
        signature,
        type: 'function'
    });
    const inputParams = splitParameters(match.parameters);
    const inputs = [];
    const inputLength = inputParams.length;
    for(let i = 0; i < inputLength; i++){
        inputs.push(parseAbiParameter(inputParams[i], {
            modifiers: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["functionModifiers"],
            structs,
            type: 'function'
        }));
    }
    const outputs = [];
    if (match.returns) {
        const outputParams = splitParameters(match.returns);
        const outputLength = outputParams.length;
        for(let i = 0; i < outputLength; i++){
            outputs.push(parseAbiParameter(outputParams[i], {
                modifiers: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["functionModifiers"],
                structs,
                type: 'function'
            }));
        }
    }
    return {
        name: match.name,
        type: 'function',
        stateMutability: match.stateMutability ?? 'nonpayable',
        inputs,
        outputs
    };
}
function parseEventSignature(signature, structs = {}) {
    const match = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["execEventSignature"])(signature);
    if (!match) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InvalidSignatureError"]({
        signature,
        type: 'event'
    });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length = params.length;
    for(let i = 0; i < length; i++)abiParameters.push(parseAbiParameter(params[i], {
        modifiers: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["eventModifiers"],
        structs,
        type: 'event'
    }));
    return {
        name: match.name,
        type: 'event',
        inputs: abiParameters
    };
}
function parseErrorSignature(signature, structs = {}) {
    const match = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["execErrorSignature"])(signature);
    if (!match) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InvalidSignatureError"]({
        signature,
        type: 'error'
    });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length = params.length;
    for(let i = 0; i < length; i++)abiParameters.push(parseAbiParameter(params[i], {
        structs,
        type: 'error'
    }));
    return {
        name: match.name,
        type: 'error',
        inputs: abiParameters
    };
}
function parseConstructorSignature(signature, structs = {}) {
    const match = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["execConstructorSignature"])(signature);
    if (!match) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InvalidSignatureError"]({
        signature,
        type: 'constructor'
    });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length = params.length;
    for(let i = 0; i < length; i++)abiParameters.push(parseAbiParameter(params[i], {
        structs,
        type: 'constructor'
    }));
    return {
        type: 'constructor',
        stateMutability: match.stateMutability ?? 'nonpayable',
        inputs: abiParameters
    };
}
function parseFallbackSignature(signature) {
    const match = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["execFallbackSignature"])(signature);
    if (!match) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InvalidSignatureError"]({
        signature,
        type: 'fallback'
    });
    return {
        type: 'fallback',
        stateMutability: match.stateMutability ?? 'nonpayable'
    };
}
const abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*(?:\spayable)?)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
const abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
const dynamicIntegerRegex = /^u?int$/;
function parseAbiParameter(param, options) {
    // optional namespace cache by `type`
    const parameterCacheKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$cache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getParameterCacheKey"])(param, options?.type, options?.structs);
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$cache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parameterCache"].has(parameterCacheKey)) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$cache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parameterCache"].get(parameterCacheKey);
    const isTuple = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isTupleRegex"].test(param);
    const match = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["execTyped"])(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
    if (!match) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$abiParameter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InvalidParameterError"]({
        param
    });
    if (match.name && isSolidityKeyword(match.name)) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$abiParameter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SolidityProtectedKeywordError"]({
        param,
        name: match.name
    });
    const name = match.name ? {
        name: match.name
    } : {};
    const indexed = match.modifier === 'indexed' ? {
        indexed: true
    } : {};
    const structs = options?.structs ?? {};
    let type;
    let components = {};
    if (isTuple) {
        type = 'tuple';
        const params = splitParameters(match.type);
        const components_ = [];
        const length = params.length;
        for(let i = 0; i < length; i++){
            // remove `modifiers` from `options` to prevent from being added to tuple components
            components_.push(parseAbiParameter(params[i], {
                structs
            }));
        }
        components = {
            components: components_
        };
    } else if (match.type in structs) {
        type = 'tuple';
        components = {
            components: structs[match.type]
        };
    } else if (dynamicIntegerRegex.test(match.type)) {
        type = `${match.type}256`;
    } else if (match.type === 'address payable') {
        type = 'address';
    } else {
        type = match.type;
        if (!(options?.type === 'struct') && !isSolidityType(type)) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$abiItem$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnknownSolidityTypeError"]({
            type
        });
    }
    if (match.modifier) {
        // Check if modifier exists, but is not allowed (e.g. `indexed` in `functionModifiers`)
        if (!options?.modifiers?.has?.(match.modifier)) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$abiParameter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InvalidModifierError"]({
            param,
            type: options?.type,
            modifier: match.modifier
        });
        // Check if resolved `type` is valid if there is a function modifier
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["functionModifiers"].has(match.modifier) && !isValidDataLocation(type, !!match.array)) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$abiParameter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InvalidFunctionModifierError"]({
            param,
            type: options?.type,
            modifier: match.modifier
        });
    }
    const abiParameter = {
        type: `${type}${match.array ?? ''}`,
        ...name,
        ...indexed,
        ...components
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$cache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parameterCache"].set(parameterCacheKey, abiParameter);
    return abiParameter;
}
function splitParameters(params, result = [], current = '', depth = 0) {
    const length = params.trim().length;
    // biome-ignore lint/correctness/noUnreachable: recursive
    for(let i = 0; i < length; i++){
        const char = params[i];
        const tail = params.slice(i + 1);
        switch(char){
            case ',':
                return depth === 0 ? splitParameters(tail, [
                    ...result,
                    current.trim()
                ]) : splitParameters(tail, result, `${current}${char}`, depth);
            case '(':
                return splitParameters(tail, result, `${current}${char}`, depth + 1);
            case ')':
                return splitParameters(tail, result, `${current}${char}`, depth - 1);
            default:
                return splitParameters(tail, result, `${current}${char}`, depth);
        }
    }
    if (current === '') return result;
    if (depth !== 0) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$splitParameters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InvalidParenthesisError"]({
        current,
        depth
    });
    result.push(current.trim());
    return result;
}
function isSolidityType(type) {
    return type === 'address' || type === 'bool' || type === 'function' || type === 'string' || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesRegex"].test(type) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["integerRegex"].test(type);
}
const protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function isSolidityKeyword(name) {
    return name === 'address' || name === 'bool' || name === 'function' || name === 'string' || name === 'tuple' || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesRegex"].test(name) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["integerRegex"].test(name) || protectedKeywordsRegex.test(name);
}
function isValidDataLocation(type, isArray) {
    return isArray || type === 'bytes' || type === 'string' || type === 'tuple';
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/abitype/dist/esm/human-readable/runtime/structs.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parseStructs",
    ()=>parseStructs
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/regex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$abiItem$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$abiParameter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/errors/signature.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$struct$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/errors/struct.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/runtime/utils.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
function parseStructs(signatures) {
    // Create "shallow" version of each struct (and filter out non-structs or invalid structs)
    const shallowStructs = {};
    const signaturesLength = signatures.length;
    for(let i = 0; i < signaturesLength; i++){
        const signature = signatures[i];
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isStructSignature"])(signature)) continue;
        const match = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["execStructSignature"])(signature);
        if (!match) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InvalidSignatureError"]({
            signature,
            type: 'struct'
        });
        const properties = match.properties.split(';');
        const components = [];
        const propertiesLength = properties.length;
        for(let k = 0; k < propertiesLength; k++){
            const property = properties[k];
            const trimmed = property.trim();
            if (!trimmed) continue;
            const abiParameter = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseAbiParameter"])(trimmed, {
                type: 'struct'
            });
            components.push(abiParameter);
        }
        if (!components.length) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InvalidStructSignatureError"]({
            signature
        });
        shallowStructs[match.name] = components;
    }
    // Resolve nested structs inside each parameter
    const resolvedStructs = {};
    const entries = Object.entries(shallowStructs);
    const entriesLength = entries.length;
    for(let i = 0; i < entriesLength; i++){
        const [name, parameters] = entries[i];
        resolvedStructs[name] = resolveStructs(parameters, shallowStructs);
    }
    return resolvedStructs;
}
const typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function resolveStructs(abiParameters = [], structs = {}, ancestors = new Set()) {
    const components = [];
    const length = abiParameters.length;
    for(let i = 0; i < length; i++){
        const abiParameter = abiParameters[i];
        const isTuple = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isTupleRegex"].test(abiParameter.type);
        if (isTuple) components.push(abiParameter);
        else {
            const match = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$regex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["execTyped"])(typeWithoutTupleRegex, abiParameter.type);
            if (!match?.type) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$abiParameter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InvalidAbiTypeParameterError"]({
                abiParameter
            });
            const { array, type } = match;
            if (type in structs) {
                if (ancestors.has(type)) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$struct$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CircularReferenceError"]({
                    type
                });
                components.push({
                    ...abiParameter,
                    type: `tuple${array ?? ''}`,
                    components: resolveStructs(structs[type], structs, new Set([
                        ...ancestors,
                        type
                    ]))
                });
            } else {
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isSolidityType"])(type)) components.push(abiParameter);
                else throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$abiItem$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnknownTypeError"]({
                    type
                });
            }
        }
    }
    return components;
} //# sourceMappingURL=structs.js.map
}),
"[project]/node_modules/abitype/dist/esm/human-readable/parseAbi.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parseAbi",
    ()=>parseAbi
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$structs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/runtime/structs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/runtime/utils.js [app-ssr] (ecmascript)");
;
;
;
function parseAbi(signatures) {
    const structs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$structs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseStructs"])(signatures);
    const abi = [];
    const length = signatures.length;
    for(let i = 0; i < length; i++){
        const signature = signatures[i];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isStructSignature"])(signature)) continue;
        abi.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSignature"])(signature, structs));
    }
    return abi;
} //# sourceMappingURL=parseAbi.js.map
}),
"[project]/node_modules/abitype/dist/esm/human-readable/parseAbiItem.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parseAbiItem",
    ()=>parseAbiItem
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$abiItem$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/errors/abiItem.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$structs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/runtime/structs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/runtime/utils.js [app-ssr] (ecmascript)");
;
;
;
;
function parseAbiItem(signature) {
    let abiItem;
    if (typeof signature === 'string') abiItem = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSignature"])(signature);
    else {
        const structs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$structs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseStructs"])(signature);
        const length = signature.length;
        for(let i = 0; i < length; i++){
            const signature_ = signature[i];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isStructSignature"])(signature_)) continue;
            abiItem = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseSignature"])(signature_, structs);
            break;
        }
    }
    if (!abiItem) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$abiItem$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InvalidAbiItemError"]({
        signature
    });
    return abiItem;
} //# sourceMappingURL=parseAbiItem.js.map
}),
"[project]/node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parseAbiParameters",
    ()=>parseAbiParameters
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$abiParameter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/errors/abiParameter.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/runtime/signatures.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$structs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/runtime/structs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/abitype/dist/esm/human-readable/runtime/utils.js [app-ssr] (ecmascript)");
;
;
;
;
;
function parseAbiParameters(params) {
    const abiParameters = [];
    if (typeof params === 'string') {
        const parameters = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["splitParameters"])(params);
        const length = parameters.length;
        for(let i = 0; i < length; i++){
            abiParameters.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseAbiParameter"])(parameters[i], {
                modifiers: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["modifiers"]
            }));
        }
    } else {
        const structs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$structs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseStructs"])(params);
        const length = params.length;
        for(let i = 0; i < length; i++){
            const signature = params[i];
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isStructSignature"])(signature)) continue;
            const parameters = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["splitParameters"])(signature);
            const length = parameters.length;
            for(let k = 0; k < length; k++){
                abiParameters.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseAbiParameter"])(parameters[k], {
                    modifiers: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$runtime$2f$signatures$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["modifiers"],
                    structs
                }));
            }
        }
    }
    if (abiParameters.length === 0) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$abitype$2f$dist$2f$esm$2f$human$2d$readable$2f$errors$2f$abiParameter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InvalidAbiParametersError"]({
        params
    });
    return abiParameters;
} //# sourceMappingURL=parseAbiParameters.js.map
}),
"[project]/node_modules/@noble/hashes/esm/legacy.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MD5",
    ()=>MD5,
    "RIPEMD160",
    ()=>RIPEMD160,
    "SHA1",
    ()=>SHA1,
    "md5",
    ()=>md5,
    "ripemd160",
    ()=>ripemd160,
    "sha1",
    ()=>sha1
]);
/**

SHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.
Don't use them in a new protocol. What "weak" means:

- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.
- No practical pre-image attacks (only theoretical, 2^123.4)
- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151
 * @module
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/_md.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/utils.js [app-ssr] (ecmascript)");
;
;
/** Initial SHA1 state */ const SHA1_IV = /* @__PURE__ */ Uint32Array.from([
    0x67452301,
    0xefcdab89,
    0x98badcfe,
    0x10325476,
    0xc3d2e1f0
]);
// Reusable temporary buffer
const SHA1_W = /* @__PURE__ */ new Uint32Array(80);
class SHA1 extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HashMD"] {
    constructor(){
        super(64, 20, 8, false);
        this.A = SHA1_IV[0] | 0;
        this.B = SHA1_IV[1] | 0;
        this.C = SHA1_IV[2] | 0;
        this.D = SHA1_IV[3] | 0;
        this.E = SHA1_IV[4] | 0;
    }
    get() {
        const { A, B, C, D, E } = this;
        return [
            A,
            B,
            C,
            D,
            E
        ];
    }
    set(A, B, C, D, E) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
    }
    process(view, offset) {
        for(let i = 0; i < 16; i++, offset += 4)SHA1_W[i] = view.getUint32(offset, false);
        for(let i = 16; i < 80; i++)SHA1_W[i] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rotl"])(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
        // Compression function main loop, 80 rounds
        let { A, B, C, D, E } = this;
        for(let i = 0; i < 80; i++){
            let F, K;
            if (i < 20) {
                F = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Chi"])(B, C, D);
                K = 0x5a827999;
            } else if (i < 40) {
                F = B ^ C ^ D;
                K = 0x6ed9eba1;
            } else if (i < 60) {
                F = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Maj"])(B, C, D);
                K = 0x8f1bbcdc;
            } else {
                F = B ^ C ^ D;
                K = 0xca62c1d6;
            }
            const T = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rotl"])(A, 5) + F + E + K + SHA1_W[i] | 0;
            E = D;
            D = C;
            C = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rotl"])(B, 30);
            B = A;
            A = T;
        }
        // Add the compressed chunk to the current hash value
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        this.set(A, B, C, D, E);
    }
    roundClean() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clean"])(SHA1_W);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clean"])(this.buffer);
    }
}
const sha1 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createHasher"])(()=>new SHA1());
/** Per-round constants */ const p32 = /* @__PURE__ */ Math.pow(2, 32);
const K = /* @__PURE__ */ Array.from({
    length: 64
}, (_, i)=>Math.floor(p32 * Math.abs(Math.sin(i + 1))));
/** md5 initial state: same as sha1, but 4 u32 instead of 5. */ const MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);
// Reusable temporary buffer
const MD5_W = /* @__PURE__ */ new Uint32Array(16);
class MD5 extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HashMD"] {
    constructor(){
        super(64, 16, 8, true);
        this.A = MD5_IV[0] | 0;
        this.B = MD5_IV[1] | 0;
        this.C = MD5_IV[2] | 0;
        this.D = MD5_IV[3] | 0;
    }
    get() {
        const { A, B, C, D } = this;
        return [
            A,
            B,
            C,
            D
        ];
    }
    set(A, B, C, D) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
    }
    process(view, offset) {
        for(let i = 0; i < 16; i++, offset += 4)MD5_W[i] = view.getUint32(offset, true);
        // Compression function main loop, 64 rounds
        let { A, B, C, D } = this;
        for(let i = 0; i < 64; i++){
            let F, g, s;
            if (i < 16) {
                F = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Chi"])(B, C, D);
                g = i;
                s = [
                    7,
                    12,
                    17,
                    22
                ];
            } else if (i < 32) {
                F = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Chi"])(D, B, C);
                g = (5 * i + 1) % 16;
                s = [
                    5,
                    9,
                    14,
                    20
                ];
            } else if (i < 48) {
                F = B ^ C ^ D;
                g = (3 * i + 5) % 16;
                s = [
                    4,
                    11,
                    16,
                    23
                ];
            } else {
                F = C ^ (B | ~D);
                g = 7 * i % 16;
                s = [
                    6,
                    10,
                    15,
                    21
                ];
            }
            F = F + A + K[i] + MD5_W[g];
            A = D;
            D = C;
            C = B;
            B = B + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rotl"])(F, s[i % 4]);
        }
        // Add the compressed chunk to the current hash value
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        this.set(A, B, C, D);
    }
    roundClean() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clean"])(MD5_W);
    }
    destroy() {
        this.set(0, 0, 0, 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clean"])(this.buffer);
    }
}
const md5 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createHasher"])(()=>new MD5());
// RIPEMD-160
const Rho160 = /* @__PURE__ */ Uint8Array.from([
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8
]);
const Id160 = /* @__PURE__ */ (()=>Uint8Array.from(new Array(16).fill(0).map((_, i)=>i)))();
const Pi160 = /* @__PURE__ */ (()=>Id160.map((i)=>(9 * i + 5) % 16))();
const idxLR = /* @__PURE__ */ (()=>{
    const L = [
        Id160
    ];
    const R = [
        Pi160
    ];
    const res = [
        L,
        R
    ];
    for(let i = 0; i < 4; i++)for (let j of res)j.push(j[i].map((k)=>Rho160[k]));
    return res;
})();
const idxL = /* @__PURE__ */ (()=>idxLR[0])();
const idxR = /* @__PURE__ */ (()=>idxLR[1])();
// const [idxL, idxR] = idxLR;
const shifts160 = /* @__PURE__ */ [
    [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8
    ],
    [
        12,
        13,
        11,
        15,
        6,
        9,
        9,
        7,
        12,
        15,
        11,
        13,
        7,
        8,
        7,
        7
    ],
    [
        13,
        15,
        14,
        11,
        7,
        7,
        6,
        8,
        13,
        14,
        13,
        12,
        5,
        5,
        6,
        9
    ],
    [
        14,
        11,
        12,
        14,
        8,
        6,
        5,
        5,
        15,
        12,
        15,
        14,
        9,
        9,
        8,
        6
    ],
    [
        15,
        12,
        13,
        13,
        9,
        5,
        8,
        6,
        14,
        11,
        12,
        11,
        8,
        6,
        5,
        5
    ]
].map((i)=>Uint8Array.from(i));
const shiftsL160 = /* @__PURE__ */ idxL.map((idx, i)=>idx.map((j)=>shifts160[i][j]));
const shiftsR160 = /* @__PURE__ */ idxR.map((idx, i)=>idx.map((j)=>shifts160[i][j]));
const Kl160 = /* @__PURE__ */ Uint32Array.from([
    0x00000000,
    0x5a827999,
    0x6ed9eba1,
    0x8f1bbcdc,
    0xa953fd4e
]);
const Kr160 = /* @__PURE__ */ Uint32Array.from([
    0x50a28be6,
    0x5c4dd124,
    0x6d703ef3,
    0x7a6d76e9,
    0x00000000
]);
// It's called f() in spec.
function ripemd_f(group, x, y, z) {
    if (group === 0) return x ^ y ^ z;
    if (group === 1) return x & y | ~x & z;
    if (group === 2) return (x | ~y) ^ z;
    if (group === 3) return x & z | y & ~z;
    return x ^ (y | ~z);
}
// Reusable temporary buffer
const BUF_160 = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HashMD"] {
    constructor(){
        super(64, 20, 8, true);
        this.h0 = 0x67452301 | 0;
        this.h1 = 0xefcdab89 | 0;
        this.h2 = 0x98badcfe | 0;
        this.h3 = 0x10325476 | 0;
        this.h4 = 0xc3d2e1f0 | 0;
    }
    get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [
            h0,
            h1,
            h2,
            h3,
            h4
        ];
    }
    set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
    }
    process(view, offset) {
        for(let i = 0; i < 16; i++, offset += 4)BUF_160[i] = view.getUint32(offset, true);
        // prettier-ignore
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        // Instead of iterating 0 to 80, we split it into 5 groups
        // And use the groups in constants, functions, etc. Much simpler
        for(let group = 0; group < 5; group++){
            const rGroup = 4 - group;
            const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore
            const rl = idxL[group], rr = idxR[group]; // prettier-ignore
            const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore
            for(let i = 0; i < 16; i++){
                const tl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rotl"])(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;
                al = el, el = dl, dl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rotl"])(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
            }
            // 2 loops are 10% faster
            for(let i = 0; i < 16; i++){
                const tr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rotl"])(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;
                ar = er, er = dr, dr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["rotl"])(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
            }
        }
        // Add the compressed chunk to the current hash value
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
    }
    roundClean() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clean"])(BUF_160);
    }
    destroy() {
        this.destroyed = true;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clean"])(this.buffer);
        this.set(0, 0, 0, 0, 0);
    }
}
const ripemd160 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createHasher"])(()=>new RIPEMD160()); //# sourceMappingURL=legacy.js.map
}),
"[project]/node_modules/@noble/hashes/esm/ripemd160.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RIPEMD160",
    ()=>RIPEMD160,
    "ripemd160",
    ()=>ripemd160
]);
/**
 * RIPEMD-160 legacy hash function.
 * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
 * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
 * @module
 * @deprecated
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$legacy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/legacy.js [app-ssr] (ecmascript)");
;
const RIPEMD160 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$legacy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RIPEMD160"];
const ripemd160 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$legacy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ripemd160"]; //# sourceMappingURL=ripemd160.js.map
}),
"[project]/node_modules/@noble/hashes/_u64.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
exports.add = add;
exports.fromBig = fromBig;
exports.split = split;
/**
 * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.
 * @todo re-check https://issues.chromium.org/issues/42212588
 * @module
 */ const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
    if (le) return {
        h: Number(n & U32_MASK64),
        l: Number(n >> _32n & U32_MASK64)
    };
    return {
        h: Number(n >> _32n & U32_MASK64) | 0,
        l: Number(n & U32_MASK64) | 0
    };
}
function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for(let i = 0; i < len; i++){
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [
            h,
            l
        ];
    }
    return [
        Ah,
        Al
    ];
}
const toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, _l, s)=>h >>> s;
exports.shrSH = shrSH;
const shrSL = (h, l, s)=>h << 32 - s | l >>> s;
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s)=>h >>> s | l << 32 - s;
exports.rotrSH = rotrSH;
const rotrSL = (h, l, s)=>h << 32 - s | l >>> s;
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;
exports.rotrBH = rotrBH;
const rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l)=>l;
exports.rotr32H = rotr32H;
const rotr32L = (h, _l)=>h;
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s)=>h << s | l >>> 32 - s;
exports.rotlSH = rotlSH;
const rotlSL = (h, l, s)=>l << s | h >>> 32 - s;
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;
exports.rotlBH = rotlBH;
const rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return {
        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
        l: l | 0
    };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
exports.add3L = add3L;
const add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
exports.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
exports.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
exports.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
exports.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
exports.add5H = add5H;
// prettier-ignore
const u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
};
exports.default = u64; //# sourceMappingURL=_u64.js.map
}),
"[project]/node_modules/@noble/hashes/cryptoNode.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.crypto = void 0;
/**
 * Internal webcrypto alias.
 * We prefer WebCrypto aka globalThis.crypto, which exists in node.js 16+.
 * Falls back to Node.js built-in crypto for Node.js <=v14.
 * See utils.ts for details.
 * @module
 */ // @ts-ignore
const nc = __turbopack_context__.r("[externals]/node:crypto [external] (node:crypto, cjs)");
exports.crypto = nc && typeof nc === 'object' && 'webcrypto' in nc ? nc.webcrypto : nc && typeof nc === 'object' && 'randomBytes' in nc ? nc : undefined; //# sourceMappingURL=cryptoNode.js.map
}),
"[project]/node_modules/@noble/hashes/utils.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Utilities for hex, bytes, CSPRNG.
 * @module
 */ /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
exports.isBytes = isBytes;
exports.anumber = anumber;
exports.abytes = abytes;
exports.ahash = ahash;
exports.aexists = aexists;
exports.aoutput = aoutput;
exports.u8 = u8;
exports.u32 = u32;
exports.clean = clean;
exports.createView = createView;
exports.rotr = rotr;
exports.rotl = rotl;
exports.byteSwap = byteSwap;
exports.byteSwap32 = byteSwap32;
exports.bytesToHex = bytesToHex;
exports.hexToBytes = hexToBytes;
exports.asyncLoop = asyncLoop;
exports.utf8ToBytes = utf8ToBytes;
exports.bytesToUtf8 = bytesToUtf8;
exports.toBytes = toBytes;
exports.kdfInputToBytes = kdfInputToBytes;
exports.concatBytes = concatBytes;
exports.checkOpts = checkOpts;
exports.createHasher = createHasher;
exports.createOptHasher = createOptHasher;
exports.createXOFer = createXOFer;
exports.randomBytes = randomBytes;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
const crypto_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/cryptoNode.js [app-ssr] (ecmascript)");
/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */ function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';
}
/** Asserts something is positive integer. */ function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);
}
/** Asserts something is Uint8Array. */ function abytes(b, ...lengths) {
    if (!isBytes(b)) throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
/** Asserts something is hash */ function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function') throw new Error('Hash should be wrapped by utils.createHasher');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
/** Asserts a hash instance has not been destroyed / finished */ function aexists(instance, checkFinished = true) {
    if (instance.destroyed) throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
}
/** Asserts output is properly-sized byte array */ function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error('digestInto() expects output buffer of length at least ' + min);
    }
}
/** Cast u8 / u16 / u32 to u8. */ function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** Cast u8 / u16 / u32 to u32. */ function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
/** Zeroize a byte array. Warning: JS provides no guarantees. */ function clean(...arrays) {
    for(let i = 0; i < arrays.length; i++){
        arrays[i].fill(0);
    }
}
/** Create DataView of an array for easy byte-level manipulation. */ function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** The rotate right (circular right shift) operation for uint32 */ function rotr(word, shift) {
    return word << 32 - shift | word >>> shift;
}
/** The rotate left (circular left shift) operation for uint32 */ function rotl(word, shift) {
    return word << shift | word >>> 32 - shift >>> 0;
}
/** Is current platform little-endian? Most are. Big-Endian platform: IBM */ exports.isLE = (()=>new Uint8Array(new Uint32Array([
        0x11223344
    ]).buffer)[0] === 0x44)();
/** The byte swap operation for uint32 */ function byteSwap(word) {
    return word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;
}
/** Conditionally byte swap if on a big-endian platform */ exports.swap8IfBE = exports.isLE ? (n)=>n : (n)=>byteSwap(n);
/** @deprecated */ exports.byteSwapIfBE = exports.swap8IfBE;
/** In place byte swap for Uint32Array */ function byteSwap32(arr) {
    for(let i = 0; i < arr.length; i++){
        arr[i] = byteSwap(arr[i]);
    }
    return arr;
}
exports.swap32IfBE = exports.isLE ? (u)=>u : byteSwap32;
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
const hasHexBuiltin = /* @__PURE__ */ (()=>// @ts-ignore
    typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, '0'));
/**
 * Convert byte array to hex string. Uses built-in function, when available.
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */ function bytesToHex(bytes) {
    abytes(bytes);
    // @ts-ignore
    if (hasHexBuiltin) return bytes.toHex();
    // pre-caching improves the speed 6x
    let hex = '';
    for(let i = 0; i < bytes.length; i++){
        hex += hexes[bytes[i]];
    }
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
/**
 * Convert hex string to byte array. Uses built-in function, when available.
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */ function hexToBytes(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    // @ts-ignore
    if (hasHexBuiltin) return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
/**
 * There is no setImmediate in browser and setTimeout is slow.
 * Call of async fn will return Promise, which will be fullfiled only on
 * next scheduler queue processing step and this is exactly what we need.
 */ const nextTick = async ()=>{};
exports.nextTick = nextTick;
/** Returns control to thread each 'tick' ms to avoid blocking. */ async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for(let i = 0; i < iters; i++){
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick) continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
/**
 * Converts string to bytes using UTF8 encoding.
 * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])
 */ function utf8ToBytes(str) {
    if (typeof str !== 'string') throw new Error('string expected');
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
 */ function bytesToUtf8(bytes) {
    return new TextDecoder().decode(bytes);
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */ function toBytes(data) {
    if (typeof data === 'string') data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/**
 * Helper for KDFs: consumes uint8array or string.
 * When string is passed, does utf8 decoding, using TextDecoder.
 */ function kdfInputToBytes(data) {
    if (typeof data === 'string') data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/** Copies several Uint8Arrays into one. */ function concatBytes(...arrays) {
    let sum = 0;
    for(let i = 0; i < arrays.length; i++){
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
function checkOpts(defaults, opts) {
    if (opts !== undefined && ({}).toString.call(opts) !== '[object Object]') throw new Error('options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
/** For runtime check if class implements interface */ class Hash {
}
exports.Hash = Hash;
/** Wraps hash function, creating an interface on top of it */ function createHasher(hashCons) {
    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = ()=>hashCons();
    return hashC;
}
function createOptHasher(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
function createXOFer(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
exports.wrapConstructor = createHasher;
exports.wrapConstructorWithOpts = createOptHasher;
exports.wrapXOFConstructorWithOpts = createXOFer;
/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */ function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    // Legacy Node.js compatibility
    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/@noble/hashes/sha3.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;
exports.keccakP = keccakP;
/**
 * SHA3 (keccak) hash function, based on a new "Sponge function" design.
 * Different from older hashes, the internal state is bigger than output size.
 *
 * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),
 * [Website](https://keccak.team/keccak.html),
 * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).
 *
 * Check out `sha3-addons` module for cSHAKE, k12, and others.
 * @module
 */ const _u64_ts_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/_u64.js [app-ssr] (ecmascript)");
// prettier-ignore
const utils_ts_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/utils.js [app-ssr] (ecmascript)");
// No __PURE__ annotations in sha3 header:
// EVERYTHING is in fact used on every export.
// Various per round constants calculations
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
const SHA3_PI = [];
const SHA3_ROTL = [];
const _SHA3_IOTA = [];
for(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){
    // Pi
    [x, y] = [
        y,
        (2 * x + 3 * y) % 5
    ];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    // Iota
    let t = _0n;
    for(let j = 0; j < 7; j++){
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
}
const IOTAS = (0, _u64_ts_1.split)(_SHA3_IOTA, true);
const SHA3_IOTA_H = IOTAS[0];
const SHA3_IOTA_L = IOTAS[1];
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s)=>s > 32 ? (0, _u64_ts_1.rotlBH)(h, l, s) : (0, _u64_ts_1.rotlSH)(h, l, s);
const rotlL = (h, l, s)=>s > 32 ? (0, _u64_ts_1.rotlBL)(h, l, s) : (0, _u64_ts_1.rotlSL)(h, l, s);
/** `keccakf1600` internal function, additionally allows to adjust round count. */ function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for(let round = 24 - rounds; round < 24; round++){
        // Theta 
        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for(let x = 0; x < 10; x += 2){
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for(let y = 0; y < 50; y += 10){
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho () and Pi ()
        let curH = s[2];
        let curL = s[3];
        for(let t = 0; t < 24; t++){
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi ()
        for(let y = 0; y < 50; y += 10){
            for(let x = 0; x < 10; x++)B[x] = s[y + x];
            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota ()
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    (0, utils_ts_1.clean)(B);
}
/** Keccak sponge function. */ class Keccak extends utils_ts_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){
        super();
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        this.enableXOF = false;
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        // Can be passed from user as dkLen
        (0, utils_ts_1.anumber)(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        // 0 < blockLen < 200
        if (!(0 < blockLen && blockLen < 200)) throw new Error('only keccak-f1600 function is supported');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_ts_1.u32)(this.state);
    }
    clone() {
        return this._cloneInto();
    }
    keccak() {
        (0, utils_ts_1.swap32IfBE)(this.state32);
        keccakP(this.state32, this.rounds);
        (0, utils_ts_1.swap32IfBE)(this.state32);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { blockLen, state } = this;
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen) this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished) return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        (0, utils_ts_1.aexists)(this, false);
        (0, utils_ts_1.abytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for(let pos = 0, len = out.length; pos < len;){
            if (this.posOut >= blockLen) this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF) throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        (0, utils_ts_1.anumber)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0, utils_ts_1.aoutput)(out, this);
        if (this.finished) throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.state);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen)=>(0, utils_ts_1.createHasher)(()=>new Keccak(blockLen, suffix, outputLen));
/** SHA3-224 hash function. */ exports.sha3_224 = (()=>gen(0x06, 144, 224 / 8))();
/** SHA3-256 hash function. Different from keccak-256. */ exports.sha3_256 = (()=>gen(0x06, 136, 256 / 8))();
/** SHA3-384 hash function. */ exports.sha3_384 = (()=>gen(0x06, 104, 384 / 8))();
/** SHA3-512 hash function. */ exports.sha3_512 = (()=>gen(0x06, 72, 512 / 8))();
/** keccak-224 hash function. */ exports.keccak_224 = (()=>gen(0x01, 144, 224 / 8))();
/** keccak-256 hash function. Different from SHA3-256. */ exports.keccak_256 = (()=>gen(0x01, 136, 256 / 8))();
/** keccak-384 hash function. */ exports.keccak_384 = (()=>gen(0x01, 104, 384 / 8))();
/** keccak-512 hash function. */ exports.keccak_512 = (()=>gen(0x01, 72, 512 / 8))();
const genShake = (suffix, blockLen, outputLen)=>(0, utils_ts_1.createXOFer)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
/** SHAKE128 XOF with 128-bit security. */ exports.shake128 = (()=>genShake(0x1f, 168, 128 / 8))();
/** SHAKE256 XOF with 256-bit security. */ exports.shake256 = (()=>genShake(0x1f, 136, 256 / 8))(); //# sourceMappingURL=sha3.js.map
}),
"[project]/node_modules/@noble/hashes/_md.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;
exports.setBigUint64 = setBigUint64;
exports.Chi = Chi;
exports.Maj = Maj;
/**
 * Internal Merkle-Damgard hash utils.
 * @module
 */ const utils_ts_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/utils.js [app-ssr] (ecmascript)");
/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */ function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number(value >> _32n & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
/** Choice: a ? b : c */ function Chi(a, b, c) {
    return a & b ^ ~a & c;
}
/** Majority function, true if any two inputs is true. */ function Maj(a, b, c) {
    return a & b ^ a & c ^ b & c;
}
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */ class HashMD extends utils_ts_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE){
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_ts_1.createView)(this.buffer);
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_ts_1.createView)(data);
                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for(let i = pos; i < blockLen; i++)buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_ts_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');
        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen) to.buffer.set(buffer);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
}
exports.HashMD = HashMD;
/**
 * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.
 * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.
 */ /** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */ exports.SHA256_IV = Uint32Array.from([
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19
]);
/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */ exports.SHA224_IV = Uint32Array.from([
    0xc1059ed8,
    0x367cd507,
    0x3070dd17,
    0xf70e5939,
    0xffc00b31,
    0x68581511,
    0x64f98fa7,
    0xbefa4fa4
]);
/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */ exports.SHA384_IV = Uint32Array.from([
    0xcbbb9d5d,
    0xc1059ed8,
    0x629a292a,
    0x367cd507,
    0x9159015a,
    0x3070dd17,
    0x152fecd8,
    0xf70e5939,
    0x67332667,
    0xffc00b31,
    0x8eb44a87,
    0x68581511,
    0xdb0c2e0d,
    0x64f98fa7,
    0x47b5481d,
    0xbefa4fa4
]);
/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */ exports.SHA512_IV = Uint32Array.from([
    0x6a09e667,
    0xf3bcc908,
    0xbb67ae85,
    0x84caa73b,
    0x3c6ef372,
    0xfe94f82b,
    0xa54ff53a,
    0x5f1d36f1,
    0x510e527f,
    0xade682d1,
    0x9b05688c,
    0x2b3e6c1f,
    0x1f83d9ab,
    0xfb41bd6b,
    0x5be0cd19,
    0x137e2179
]); //# sourceMappingURL=_md.js.map
}),
"[project]/node_modules/@noble/hashes/sha2.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;
/**
 * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.
 * SHA256 is the fastest hash implementable in JS, even faster than Blake3.
 * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and
 * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
 * @module
 */ const _md_ts_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/_md.js [app-ssr] (ecmascript)");
const u64 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/_u64.js [app-ssr] (ecmascript)");
const utils_ts_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/utils.js [app-ssr] (ecmascript)");
/**
 * Round constants:
 * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)
 */ // prettier-ignore
const SHA256_K = /* @__PURE__ */ Uint32Array.from([
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
]);
/** Reusable temporary buffer. "W" comes straight from spec. */ const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_ts_1.HashMD {
    constructor(outputLen = 32){
        super(64, outputLen, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = _md_ts_1.SHA256_IV[0] | 0;
        this.B = _md_ts_1.SHA256_IV[1] | 0;
        this.C = _md_ts_1.SHA256_IV[2] | 0;
        this.D = _md_ts_1.SHA256_IV[3] | 0;
        this.E = _md_ts_1.SHA256_IV[4] | 0;
        this.F = _md_ts_1.SHA256_IV[5] | 0;
        this.G = _md_ts_1.SHA256_IV[6] | 0;
        this.H = _md_ts_1.SHA256_IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [
            A,
            B,
            C,
            D,
            E,
            F,
            G,
            H
        ];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);
        for(let i = 16; i < 64; i++){
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for(let i = 0; i < 64; i++){
            const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
            const T1 = H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
            const T2 = sigma0 + (0, _md_ts_1.Maj)(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
        }
        // Add the compressed chunk to the current hash value
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA256_W);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.SHA256 = SHA256;
class SHA224 extends SHA256 {
    constructor(){
        super(28);
        this.A = _md_ts_1.SHA224_IV[0] | 0;
        this.B = _md_ts_1.SHA224_IV[1] | 0;
        this.C = _md_ts_1.SHA224_IV[2] | 0;
        this.D = _md_ts_1.SHA224_IV[3] | 0;
        this.E = _md_ts_1.SHA224_IV[4] | 0;
        this.F = _md_ts_1.SHA224_IV[5] | 0;
        this.G = _md_ts_1.SHA224_IV[6] | 0;
        this.H = _md_ts_1.SHA224_IV[7] | 0;
    }
}
exports.SHA224 = SHA224;
// SHA2-512 is slower than sha256 in js because u64 operations are slow.
// Round contants
// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409
// prettier-ignore
const K512 = /* @__PURE__ */ (()=>u64.split([
        '0x428a2f98d728ae22',
        '0x7137449123ef65cd',
        '0xb5c0fbcfec4d3b2f',
        '0xe9b5dba58189dbbc',
        '0x3956c25bf348b538',
        '0x59f111f1b605d019',
        '0x923f82a4af194f9b',
        '0xab1c5ed5da6d8118',
        '0xd807aa98a3030242',
        '0x12835b0145706fbe',
        '0x243185be4ee4b28c',
        '0x550c7dc3d5ffb4e2',
        '0x72be5d74f27b896f',
        '0x80deb1fe3b1696b1',
        '0x9bdc06a725c71235',
        '0xc19bf174cf692694',
        '0xe49b69c19ef14ad2',
        '0xefbe4786384f25e3',
        '0x0fc19dc68b8cd5b5',
        '0x240ca1cc77ac9c65',
        '0x2de92c6f592b0275',
        '0x4a7484aa6ea6e483',
        '0x5cb0a9dcbd41fbd4',
        '0x76f988da831153b5',
        '0x983e5152ee66dfab',
        '0xa831c66d2db43210',
        '0xb00327c898fb213f',
        '0xbf597fc7beef0ee4',
        '0xc6e00bf33da88fc2',
        '0xd5a79147930aa725',
        '0x06ca6351e003826f',
        '0x142929670a0e6e70',
        '0x27b70a8546d22ffc',
        '0x2e1b21385c26c926',
        '0x4d2c6dfc5ac42aed',
        '0x53380d139d95b3df',
        '0x650a73548baf63de',
        '0x766a0abb3c77b2a8',
        '0x81c2c92e47edaee6',
        '0x92722c851482353b',
        '0xa2bfe8a14cf10364',
        '0xa81a664bbc423001',
        '0xc24b8b70d0f89791',
        '0xc76c51a30654be30',
        '0xd192e819d6ef5218',
        '0xd69906245565a910',
        '0xf40e35855771202a',
        '0x106aa07032bbd1b8',
        '0x19a4c116b8d2d0c8',
        '0x1e376c085141ab53',
        '0x2748774cdf8eeb99',
        '0x34b0bcb5e19b48a8',
        '0x391c0cb3c5c95a63',
        '0x4ed8aa4ae3418acb',
        '0x5b9cca4f7763e373',
        '0x682e6ff3d6b2b8a3',
        '0x748f82ee5defb2fc',
        '0x78a5636f43172f60',
        '0x84c87814a1f0ab72',
        '0x8cc702081a6439ec',
        '0x90befffa23631e28',
        '0xa4506cebde82bde9',
        '0xbef9a3f7b2c67915',
        '0xc67178f2e372532b',
        '0xca273eceea26619c',
        '0xd186b8c721c0c207',
        '0xeada7dd6cde0eb1e',
        '0xf57d4f7fee6ed178',
        '0x06f067aa72176fba',
        '0x0a637dc5a2c898a6',
        '0x113f9804bef90dae',
        '0x1b710b35131c471b',
        '0x28db77f523047d84',
        '0x32caab7b40c72493',
        '0x3c9ebe0a15c9bebc',
        '0x431d67c49c100d4c',
        '0x4cc5d4becb3e42b6',
        '0x597f299cfc657e2a',
        '0x5fcb6fab3ad6faec',
        '0x6c44198c4a475817'
    ].map((n)=>BigInt(n))))();
const SHA512_Kh = /* @__PURE__ */ (()=>K512[0])();
const SHA512_Kl = /* @__PURE__ */ (()=>K512[1])();
// Reusable temporary buffers
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends _md_ts_1.HashMD {
    constructor(outputLen = 64){
        super(128, outputLen, 16, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = _md_ts_1.SHA512_IV[0] | 0;
        this.Al = _md_ts_1.SHA512_IV[1] | 0;
        this.Bh = _md_ts_1.SHA512_IV[2] | 0;
        this.Bl = _md_ts_1.SHA512_IV[3] | 0;
        this.Ch = _md_ts_1.SHA512_IV[4] | 0;
        this.Cl = _md_ts_1.SHA512_IV[5] | 0;
        this.Dh = _md_ts_1.SHA512_IV[6] | 0;
        this.Dl = _md_ts_1.SHA512_IV[7] | 0;
        this.Eh = _md_ts_1.SHA512_IV[8] | 0;
        this.El = _md_ts_1.SHA512_IV[9] | 0;
        this.Fh = _md_ts_1.SHA512_IV[10] | 0;
        this.Fl = _md_ts_1.SHA512_IV[11] | 0;
        this.Gh = _md_ts_1.SHA512_IV[12] | 0;
        this.Gl = _md_ts_1.SHA512_IV[13] | 0;
        this.Hh = _md_ts_1.SHA512_IV[14] | 0;
        this.Hl = _md_ts_1.SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [
            Ah,
            Al,
            Bh,
            Bl,
            Ch,
            Cl,
            Dh,
            Dl,
            Eh,
            El,
            Fh,
            Fl,
            Gh,
            Gl,
            Hh,
            Hl
        ];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for(let i = 0; i < 16; i++, offset += 4){
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for(let i = 16; i < 80; i++){
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for(let i = 0; i < 80; i++){
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = u64.add3L(T1l, sigma0l, MAJl);
            Ah = u64.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
exports.SHA512 = SHA512;
class SHA384 extends SHA512 {
    constructor(){
        super(48);
        this.Ah = _md_ts_1.SHA384_IV[0] | 0;
        this.Al = _md_ts_1.SHA384_IV[1] | 0;
        this.Bh = _md_ts_1.SHA384_IV[2] | 0;
        this.Bl = _md_ts_1.SHA384_IV[3] | 0;
        this.Ch = _md_ts_1.SHA384_IV[4] | 0;
        this.Cl = _md_ts_1.SHA384_IV[5] | 0;
        this.Dh = _md_ts_1.SHA384_IV[6] | 0;
        this.Dl = _md_ts_1.SHA384_IV[7] | 0;
        this.Eh = _md_ts_1.SHA384_IV[8] | 0;
        this.El = _md_ts_1.SHA384_IV[9] | 0;
        this.Fh = _md_ts_1.SHA384_IV[10] | 0;
        this.Fl = _md_ts_1.SHA384_IV[11] | 0;
        this.Gh = _md_ts_1.SHA384_IV[12] | 0;
        this.Gl = _md_ts_1.SHA384_IV[13] | 0;
        this.Hh = _md_ts_1.SHA384_IV[14] | 0;
        this.Hl = _md_ts_1.SHA384_IV[15] | 0;
    }
}
exports.SHA384 = SHA384;
/**
 * Truncated SHA512/256 and SHA512/224.
 * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as "intermediary" IV of SHA512/t.
 * Then t hashes string to produce result IV.
 * See `test/misc/sha2-gen-iv.js`.
 */ /** SHA512/224 IV */ const T224_IV = /* @__PURE__ */ Uint32Array.from([
    0x8c3d37c8,
    0x19544da2,
    0x73e19966,
    0x89dcd4d6,
    0x1dfab7ae,
    0x32ff9c82,
    0x679dd514,
    0x582f9fcf,
    0x0f6d2b69,
    0x7bd44da8,
    0x77e36f73,
    0x04c48942,
    0x3f9d85a8,
    0x6a1d36c8,
    0x1112e6ad,
    0x91d692a1
]);
/** SHA512/256 IV */ const T256_IV = /* @__PURE__ */ Uint32Array.from([
    0x22312194,
    0xfc2bf72c,
    0x9f555fa3,
    0xc84c64c2,
    0x2393b86b,
    0x6f53b151,
    0x96387719,
    0x5940eabd,
    0x96283ee2,
    0xa88effe3,
    0xbe5e1e25,
    0x53863992,
    0x2b0199fc,
    0x2c85b8aa,
    0x0eb72ddc,
    0x81c52ca2
]);
class SHA512_224 extends SHA512 {
    constructor(){
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
    }
}
exports.SHA512_224 = SHA512_224;
class SHA512_256 extends SHA512 {
    constructor(){
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
    }
}
exports.SHA512_256 = SHA512_256;
/**
 * SHA2-256 hash function from RFC 4634.
 *
 * It is the fastest JS hash, even faster than Blake3.
 * To break sha256 using birthday attack, attackers need to try 2^128 hashes.
 * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.
 */ exports.sha256 = (0, utils_ts_1.createHasher)(()=>new SHA256());
/** SHA2-224 hash function from RFC 4634 */ exports.sha224 = (0, utils_ts_1.createHasher)(()=>new SHA224());
/** SHA2-512 hash function from RFC 4634. */ exports.sha512 = (0, utils_ts_1.createHasher)(()=>new SHA512());
/** SHA2-384 hash function from RFC 4634. */ exports.sha384 = (0, utils_ts_1.createHasher)(()=>new SHA384());
/**
 * SHA2-512/256 "truncated" hash function, with improved resistance to length extension attacks.
 * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).
 */ exports.sha512_256 = (0, utils_ts_1.createHasher)(()=>new SHA512_256());
/**
 * SHA2-512/224 "truncated" hash function, with improved resistance to length extension attacks.
 * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).
 */ exports.sha512_224 = (0, utils_ts_1.createHasher)(()=>new SHA512_224()); //# sourceMappingURL=sha2.js.map
}),
"[project]/node_modules/@noble/hashes/sha256.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sha224 = exports.SHA224 = exports.sha256 = exports.SHA256 = void 0;
/**
 * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.
 *
 * To break sha256 using birthday attack, attackers need to try 2^128 hashes.
 * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.
 *
 * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
 * @module
 * @deprecated
 */ const sha2_ts_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/sha2.js [app-ssr] (ecmascript)");
/** @deprecated Use import from `noble/hashes/sha2` module */ exports.SHA256 = sha2_ts_1.SHA256;
/** @deprecated Use import from `noble/hashes/sha2` module */ exports.sha256 = sha2_ts_1.sha256;
/** @deprecated Use import from `noble/hashes/sha2` module */ exports.SHA224 = sha2_ts_1.SHA224;
/** @deprecated Use import from `noble/hashes/sha2` module */ exports.sha224 = sha2_ts_1.sha224; //# sourceMappingURL=sha256.js.map
}),
"[project]/node_modules/@scure/base/lib/esm/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "base16",
    ()=>base16,
    "base32",
    ()=>base32,
    "base32crockford",
    ()=>base32crockford,
    "base32hex",
    ()=>base32hex,
    "base32hexnopad",
    ()=>base32hexnopad,
    "base32nopad",
    ()=>base32nopad,
    "base58",
    ()=>base58,
    "base58check",
    ()=>base58check,
    "base58flickr",
    ()=>base58flickr,
    "base58xmr",
    ()=>base58xmr,
    "base58xrp",
    ()=>base58xrp,
    "base64",
    ()=>base64,
    "base64nopad",
    ()=>base64nopad,
    "base64url",
    ()=>base64url,
    "base64urlnopad",
    ()=>base64urlnopad,
    "bech32",
    ()=>bech32,
    "bech32m",
    ()=>bech32m,
    "bytes",
    ()=>bytes,
    "bytesToString",
    ()=>bytesToString,
    "createBase58check",
    ()=>createBase58check,
    "hex",
    ()=>hex,
    "str",
    ()=>str,
    "stringToBytes",
    ()=>stringToBytes,
    "utf8",
    ()=>utf8,
    "utils",
    ()=>utils
]);
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';
}
/** Asserts something is Uint8Array. */ function abytes(b, ...lengths) {
    if (!isBytes(b)) throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
function isArrayOf(isString, arr) {
    if (!Array.isArray(arr)) return false;
    if (arr.length === 0) return true;
    if (isString) {
        return arr.every((item)=>typeof item === 'string');
    } else {
        return arr.every((item)=>Number.isSafeInteger(item));
    }
}
// no abytes: seems to have 10% slowdown. Why?!
function afn(input) {
    if (typeof input !== 'function') throw new Error('function expected');
    return true;
}
function astr(label, input) {
    if (typeof input !== 'string') throw new Error(`${label}: string expected`);
    return true;
}
function anumber(n) {
    if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);
}
function aArr(input) {
    if (!Array.isArray(input)) throw new Error('array expected');
}
function astrArr(label, input) {
    if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
    if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function chain(...args) {
    const id = (a)=>a;
    // Wrap call in closure so JIT can inline calls
    const wrap = (a, b)=>(c)=>a(b(c));
    // Construct chain of args[-1].encode(args[-2].encode([...]))
    const encode = args.map((x)=>x.encode).reduceRight(wrap, id);
    // Construct chain of args[0].decode(args[1].decode(...))
    const decode = args.map((x)=>x.decode).reduce(wrap, id);
    return {
        encode,
        decode
    };
}
/**
 * Encodes integer radix representation to array of strings using alphabet and back.
 * Could also be array of strings.
 * @__NO_SIDE_EFFECTS__
 */ function alphabet(letters) {
    // mapping 1 to "b"
    const lettersA = typeof letters === 'string' ? letters.split('') : letters;
    const len = lettersA.length;
    astrArr('alphabet', lettersA);
    // mapping "b" to 1
    const indexes = new Map(lettersA.map((l, i)=>[
            l,
            i
        ]));
    return {
        encode: (digits)=>{
            aArr(digits);
            return digits.map((i)=>{
                if (!Number.isSafeInteger(i) || i < 0 || i >= len) throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
                return lettersA[i];
            });
        },
        decode: (input)=>{
            aArr(input);
            return input.map((letter)=>{
                astr('alphabet.decode', letter);
                const i = indexes.get(letter);
                if (i === undefined) throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
                return i;
            });
        }
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function join(separator = '') {
    astr('join', separator);
    return {
        encode: (from)=>{
            astrArr('join.decode', from);
            return from.join(separator);
        },
        decode: (to)=>{
            astr('join.decode', to);
            return to.split(separator);
        }
    };
}
/**
 * Pad strings array so it has integer number of bits
 * @__NO_SIDE_EFFECTS__
 */ function padding(bits, chr = '=') {
    anumber(bits);
    astr('padding', chr);
    return {
        encode (data) {
            astrArr('padding.encode', data);
            while(data.length * bits % 8)data.push(chr);
            return data;
        },
        decode (input) {
            astrArr('padding.decode', input);
            let end = input.length;
            if (end * bits % 8) throw new Error('padding: invalid, string should have whole number of bytes');
            for(; end > 0 && input[end - 1] === chr; end--){
                const last = end - 1;
                const byte = last * bits;
                if (byte % 8 === 0) throw new Error('padding: invalid, string has too much padding');
            }
            return input.slice(0, end);
        }
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function normalize(fn) {
    afn(fn);
    return {
        encode: (from)=>from,
        decode: (to)=>fn(to)
    };
}
/**
 * Slow: O(n^2) time complexity
 */ function convertRadix(data, from, to) {
    // base 1 is impossible
    if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
    if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
    aArr(data);
    if (!data.length) return [];
    let pos = 0;
    const res = [];
    const digits = Array.from(data, (d)=>{
        anumber(d);
        if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);
        return d;
    });
    const dlen = digits.length;
    while(true){
        let carry = 0;
        let done = true;
        for(let i = pos; i < dlen; i++){
            const digit = digits[i];
            const fromCarry = from * carry;
            const digitBase = fromCarry + digit;
            if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
                throw new Error('convertRadix: carry overflow');
            }
            const div = digitBase / to;
            carry = digitBase % to;
            const rounded = Math.floor(div);
            digits[i] = rounded;
            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error('convertRadix: carry overflow');
            if (!done) continue;
            else if (!rounded) pos = i;
            else done = false;
        }
        res.push(carry);
        if (done) break;
    }
    for(let i = 0; i < data.length - 1 && data[i] === 0; i++)res.push(0);
    return res.reverse();
}
const gcd = (a, b)=>b === 0 ? a : gcd(b, a % b);
const radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to)=>from + (to - gcd(from, to));
const powers = /* @__PURE__ */ (()=>{
    let res = [];
    for(let i = 0; i < 40; i++)res.push(2 ** i);
    return res;
})();
/**
 * Implemented with numbers, because BigInt is 5x slower
 */ function convertRadix2(data, from, to, padding) {
    aArr(data);
    if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);
    if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);
    if (radix2carry(from, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
    }
    let carry = 0;
    let pos = 0; // bitwise position in current element
    const max = powers[from];
    const mask = powers[to] - 1;
    const res = [];
    for (const n of data){
        anumber(n);
        if (n >= max) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
        carry = carry << from | n;
        if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for(; pos >= to; pos -= to)res.push((carry >> pos - to & mask) >>> 0);
        const pow = powers[pos];
        if (pow === undefined) throw new Error('invalid carry');
        carry &= pow - 1; // clean carry, otherwise it will cause overflow
    }
    carry = carry << to - pos & mask;
    if (!padding && pos >= from) throw new Error('Excess padding');
    if (!padding && carry > 0) throw new Error(`Non-zero padding: ${carry}`);
    if (padding && pos > 0) res.push(carry >>> 0);
    return res;
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function radix(num) {
    anumber(num);
    const _256 = 2 ** 8;
    return {
        encode: (bytes)=>{
            if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');
            return convertRadix(Array.from(bytes), _256, num);
        },
        decode: (digits)=>{
            anumArr('radix.decode', digits);
            return Uint8Array.from(convertRadix(digits, num, _256));
        }
    };
}
/**
 * If both bases are power of same number (like `2**8 <-> 2**64`),
 * there is a linear algorithm. For now we have implementation for power-of-two bases only.
 * @__NO_SIDE_EFFECTS__
 */ function radix2(bits, revPadding = false) {
    anumber(bits);
    if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');
    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error('radix2: carry overflow');
    return {
        encode: (bytes)=>{
            if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');
            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
        },
        decode: (digits)=>{
            anumArr('radix2.decode', digits);
            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        }
    };
}
function unsafeWrapper(fn) {
    afn(fn);
    return function(...args) {
        try {
            return fn.apply(null, args);
        } catch (e) {}
    };
}
function checksum(len, fn) {
    anumber(len);
    afn(fn);
    return {
        encode (data) {
            if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');
            const sum = fn(data).slice(0, len);
            const res = new Uint8Array(data.length + len);
            res.set(data);
            res.set(sum, data.length);
            return res;
        },
        decode (data) {
            if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');
            const payload = data.slice(0, -len);
            const oldChecksum = data.slice(-len);
            const newChecksum = fn(payload).slice(0, len);
            for(let i = 0; i < len; i++)if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');
            return payload;
        }
    };
}
const utils = {
    alphabet,
    chain,
    checksum,
    convertRadix,
    convertRadix2,
    radix,
    radix2,
    join,
    padding
};
const base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));
const base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));
const base32nopad = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));
const base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));
const base32hexnopad = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));
const base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s)=>s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));
// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64
// prettier-ignore
const hasBase64Builtin = /* @__PURE__ */ (()=>typeof Uint8Array.from([]).toBase64 === 'function' && typeof Uint8Array.fromBase64 === 'function')();
const decodeBase64Builtin = (s, isUrl)=>{
    astr('base64', s);
    const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
    const alphabet = isUrl ? 'base64url' : 'base64';
    if (s.length > 0 && !re.test(s)) throw new Error('invalid base64');
    return Uint8Array.fromBase64(s, {
        alphabet,
        lastChunkHandling: 'strict'
    });
};
const base64 = hasBase64Builtin ? {
    encode (b) {
        abytes(b);
        return b.toBase64();
    },
    decode (s) {
        return decodeBase64Builtin(s, false);
    }
} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));
const base64nopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));
const base64url = hasBase64Builtin ? {
    encode (b) {
        abytes(b);
        return b.toBase64({
            alphabet: 'base64url'
        });
    },
    decode (s) {
        return decodeBase64Builtin(s, true);
    }
} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));
const base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));
// base58 code
// -----------
const genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc)=>chain(radix(58), alphabet(abc), join(''));
const base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
const base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');
const base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');
// Data len (index) -> encoded block len
const XMR_BLOCK_LEN = [
    0,
    2,
    3,
    5,
    6,
    7,
    9,
    10,
    11
];
const base58xmr = {
    encode (data) {
        let res = '';
        for(let i = 0; i < data.length; i += 8){
            const block = data.subarray(i, i + 8);
            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');
        }
        return res;
    },
    decode (str) {
        let res = [];
        for(let i = 0; i < str.length; i += 11){
            const slice = str.slice(i, i + 11);
            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
            const block = base58.decode(slice);
            for(let j = 0; j < block.length - blockLen; j++){
                if (block[j] !== 0) throw new Error('base58xmr: wrong padding');
            }
            res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
    }
};
const createBase58check = (sha256)=>chain(checksum(4, (data)=>sha256(sha256(data))), base58);
const base58check = createBase58check;
const BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));
const POLYMOD_GENERATORS = [
    0x3b6a57b2,
    0x26508e6d,
    0x1ea119fa,
    0x3d4233dd,
    0x2a1462b3
];
function bech32Polymod(pre) {
    const b = pre >> 25;
    let chk = (pre & 0x1ffffff) << 5;
    for(let i = 0; i < POLYMOD_GENERATORS.length; i++){
        if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];
    }
    return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
    const len = prefix.length;
    let chk = 1;
    for(let i = 0; i < len; i++){
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod(chk) ^ c >> 5;
    }
    chk = bech32Polymod(chk);
    for(let i = 0; i < len; i++)chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;
    for (let v of words)chk = bech32Polymod(chk) ^ v;
    for(let i = 0; i < 6; i++)chk = bech32Polymod(chk);
    chk ^= encodingConst;
    return BECH_ALPHABET.encode(convertRadix2([
        chk % powers[30]
    ], 30, 5, false));
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function genBech32(encoding) {
    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;
    const _words = radix2(5);
    const fromWords = _words.decode;
    const toWords = _words.encode;
    const fromWordsUnsafe = unsafeWrapper(fromWords);
    function encode(prefix, words, limit = 90) {
        astr('bech32.encode prefix', prefix);
        if (isBytes(words)) words = Array.from(words);
        anumArr('bech32.encode', words);
        const plen = prefix.length;
        if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);
        const actualLength = plen + 7 + words.length;
        if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        const lowered = prefix.toLowerCase();
        const sum = bechChecksum(lowered, words, ENCODING_CONST);
        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
    }
    function decode(str, limit = 90) {
        astr('bech32.decode input', str);
        const slen = str.length;
        if (slen < 8 || limit !== false && slen > limit) throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
        // don't allow mixed case
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);
        const sepIndex = lowered.lastIndexOf('1');
        if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = lowered.slice(0, sepIndex);
        const data = lowered.slice(sepIndex + 1);
        if (data.length < 6) throw new Error('Data must be at least 6 characters long');
        const words = BECH_ALPHABET.decode(data).slice(0, -6);
        const sum = bechChecksum(prefix, words, ENCODING_CONST);
        if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return {
            prefix,
            words
        };
    }
    const decodeUnsafe = unsafeWrapper(decode);
    function decodeToBytes(str) {
        const { prefix, words } = decode(str, false);
        return {
            prefix,
            words,
            bytes: fromWords(words)
        };
    }
    function encodeFromBytes(prefix, bytes) {
        return encode(prefix, toWords(bytes));
    }
    return {
        encode,
        decode,
        encodeFromBytes,
        decodeToBytes,
        decodeUnsafe,
        fromWords,
        fromWordsUnsafe,
        toWords
    };
}
const bech32 = genBech32('bech32');
const bech32m = genBech32('bech32m');
const utf8 = {
    encode: (data)=>new TextDecoder().decode(data),
    decode: (str)=>new TextEncoder().encode(str)
};
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
// prettier-ignore
const hasHexBuiltin = /* @__PURE__ */ (()=>typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// prettier-ignore
const hexBuiltin = {
    encode (data) {
        abytes(data);
        return data.toHex();
    },
    decode (s) {
        astr('hex', s);
        return Uint8Array.fromHex(s);
    }
};
const hex = hasHexBuiltin ? hexBuiltin : chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s)=>{
    if (typeof s !== 'string' || s.length % 2 !== 0) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
    return s.toLowerCase();
}));
// prettier-ignore
const CODERS = {
    utf8,
    hex,
    base16,
    base32,
    base64,
    base64url,
    base58,
    base58xmr
};
const coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';
const bytesToString = (type, bytes)=>{
    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);
    if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');
    return CODERS[type].encode(bytes);
};
const str = bytesToString; // as in python, but for bytes only
const stringToBytes = (type, str)=>{
    if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);
    if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');
    return CODERS[type].decode(str);
};
const bytes = stringToBytes; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@scure/base/lib/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.createBase58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64nopad = exports.base64 = exports.base32crockford = exports.base32hexnopad = exports.base32hex = exports.base32nopad = exports.base32 = exports.base16 = exports.utils = void 0;
function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';
}
/** Asserts something is Uint8Array. */ function abytes(b, ...lengths) {
    if (!isBytes(b)) throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
function isArrayOf(isString, arr) {
    if (!Array.isArray(arr)) return false;
    if (arr.length === 0) return true;
    if (isString) {
        return arr.every((item)=>typeof item === 'string');
    } else {
        return arr.every((item)=>Number.isSafeInteger(item));
    }
}
// no abytes: seems to have 10% slowdown. Why?!
function afn(input) {
    if (typeof input !== 'function') throw new Error('function expected');
    return true;
}
function astr(label, input) {
    if (typeof input !== 'string') throw new Error(`${label}: string expected`);
    return true;
}
function anumber(n) {
    if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);
}
function aArr(input) {
    if (!Array.isArray(input)) throw new Error('array expected');
}
function astrArr(label, input) {
    if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
    if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function chain(...args) {
    const id = (a)=>a;
    // Wrap call in closure so JIT can inline calls
    const wrap = (a, b)=>(c)=>a(b(c));
    // Construct chain of args[-1].encode(args[-2].encode([...]))
    const encode = args.map((x)=>x.encode).reduceRight(wrap, id);
    // Construct chain of args[0].decode(args[1].decode(...))
    const decode = args.map((x)=>x.decode).reduce(wrap, id);
    return {
        encode,
        decode
    };
}
/**
 * Encodes integer radix representation to array of strings using alphabet and back.
 * Could also be array of strings.
 * @__NO_SIDE_EFFECTS__
 */ function alphabet(letters) {
    // mapping 1 to "b"
    const lettersA = typeof letters === 'string' ? letters.split('') : letters;
    const len = lettersA.length;
    astrArr('alphabet', lettersA);
    // mapping "b" to 1
    const indexes = new Map(lettersA.map((l, i)=>[
            l,
            i
        ]));
    return {
        encode: (digits)=>{
            aArr(digits);
            return digits.map((i)=>{
                if (!Number.isSafeInteger(i) || i < 0 || i >= len) throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
                return lettersA[i];
            });
        },
        decode: (input)=>{
            aArr(input);
            return input.map((letter)=>{
                astr('alphabet.decode', letter);
                const i = indexes.get(letter);
                if (i === undefined) throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
                return i;
            });
        }
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function join(separator = '') {
    astr('join', separator);
    return {
        encode: (from)=>{
            astrArr('join.decode', from);
            return from.join(separator);
        },
        decode: (to)=>{
            astr('join.decode', to);
            return to.split(separator);
        }
    };
}
/**
 * Pad strings array so it has integer number of bits
 * @__NO_SIDE_EFFECTS__
 */ function padding(bits, chr = '=') {
    anumber(bits);
    astr('padding', chr);
    return {
        encode (data) {
            astrArr('padding.encode', data);
            while(data.length * bits % 8)data.push(chr);
            return data;
        },
        decode (input) {
            astrArr('padding.decode', input);
            let end = input.length;
            if (end * bits % 8) throw new Error('padding: invalid, string should have whole number of bytes');
            for(; end > 0 && input[end - 1] === chr; end--){
                const last = end - 1;
                const byte = last * bits;
                if (byte % 8 === 0) throw new Error('padding: invalid, string has too much padding');
            }
            return input.slice(0, end);
        }
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function normalize(fn) {
    afn(fn);
    return {
        encode: (from)=>from,
        decode: (to)=>fn(to)
    };
}
/**
 * Slow: O(n^2) time complexity
 */ function convertRadix(data, from, to) {
    // base 1 is impossible
    if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
    if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
    aArr(data);
    if (!data.length) return [];
    let pos = 0;
    const res = [];
    const digits = Array.from(data, (d)=>{
        anumber(d);
        if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);
        return d;
    });
    const dlen = digits.length;
    while(true){
        let carry = 0;
        let done = true;
        for(let i = pos; i < dlen; i++){
            const digit = digits[i];
            const fromCarry = from * carry;
            const digitBase = fromCarry + digit;
            if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
                throw new Error('convertRadix: carry overflow');
            }
            const div = digitBase / to;
            carry = digitBase % to;
            const rounded = Math.floor(div);
            digits[i] = rounded;
            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error('convertRadix: carry overflow');
            if (!done) continue;
            else if (!rounded) pos = i;
            else done = false;
        }
        res.push(carry);
        if (done) break;
    }
    for(let i = 0; i < data.length - 1 && data[i] === 0; i++)res.push(0);
    return res.reverse();
}
const gcd = (a, b)=>b === 0 ? a : gcd(b, a % b);
const radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to)=>from + (to - gcd(from, to));
const powers = /* @__PURE__ */ (()=>{
    let res = [];
    for(let i = 0; i < 40; i++)res.push(2 ** i);
    return res;
})();
/**
 * Implemented with numbers, because BigInt is 5x slower
 */ function convertRadix2(data, from, to, padding) {
    aArr(data);
    if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);
    if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);
    if (radix2carry(from, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
    }
    let carry = 0;
    let pos = 0; // bitwise position in current element
    const max = powers[from];
    const mask = powers[to] - 1;
    const res = [];
    for (const n of data){
        anumber(n);
        if (n >= max) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
        carry = carry << from | n;
        if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for(; pos >= to; pos -= to)res.push((carry >> pos - to & mask) >>> 0);
        const pow = powers[pos];
        if (pow === undefined) throw new Error('invalid carry');
        carry &= pow - 1; // clean carry, otherwise it will cause overflow
    }
    carry = carry << to - pos & mask;
    if (!padding && pos >= from) throw new Error('Excess padding');
    if (!padding && carry > 0) throw new Error(`Non-zero padding: ${carry}`);
    if (padding && pos > 0) res.push(carry >>> 0);
    return res;
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function radix(num) {
    anumber(num);
    const _256 = 2 ** 8;
    return {
        encode: (bytes)=>{
            if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');
            return convertRadix(Array.from(bytes), _256, num);
        },
        decode: (digits)=>{
            anumArr('radix.decode', digits);
            return Uint8Array.from(convertRadix(digits, num, _256));
        }
    };
}
/**
 * If both bases are power of same number (like `2**8 <-> 2**64`),
 * there is a linear algorithm. For now we have implementation for power-of-two bases only.
 * @__NO_SIDE_EFFECTS__
 */ function radix2(bits, revPadding = false) {
    anumber(bits);
    if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');
    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error('radix2: carry overflow');
    return {
        encode: (bytes)=>{
            if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');
            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
        },
        decode: (digits)=>{
            anumArr('radix2.decode', digits);
            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        }
    };
}
function unsafeWrapper(fn) {
    afn(fn);
    return function(...args) {
        try {
            return fn.apply(null, args);
        } catch (e) {}
    };
}
function checksum(len, fn) {
    anumber(len);
    afn(fn);
    return {
        encode (data) {
            if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');
            const sum = fn(data).slice(0, len);
            const res = new Uint8Array(data.length + len);
            res.set(data);
            res.set(sum, data.length);
            return res;
        },
        decode (data) {
            if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');
            const payload = data.slice(0, -len);
            const oldChecksum = data.slice(-len);
            const newChecksum = fn(payload).slice(0, len);
            for(let i = 0; i < len; i++)if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');
            return payload;
        }
    };
}
// prettier-ignore
exports.utils = {
    alphabet,
    chain,
    checksum,
    convertRadix,
    convertRadix2,
    radix,
    radix2,
    join,
    padding
};
// RFC 4648 aka RFC 3548
// ---------------------
/**
 * base16 encoding from RFC 4648.
 * @example
 * ```js
 * base16.encode(Uint8Array.from([0x12, 0xab]));
 * // => '12AB'
 * ```
 */ exports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));
/**
 * base32 encoding from RFC 4648. Has padding.
 * Use `base32nopad` for unpadded version.
 * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.
 * @example
 * ```js
 * base32.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'CKVQ===='
 * base32.decode('CKVQ====');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */ exports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));
/**
 * base32 encoding from RFC 4648. No padding.
 * Use `base32` for padded version.
 * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.
 * @example
 * ```js
 * base32nopad.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'CKVQ'
 * base32nopad.decode('CKVQ');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */ exports.base32nopad = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));
/**
 * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.
 * Use `base32hexnopad` for unpadded version.
 * @example
 * ```js
 * base32hex.encode(Uint8Array.from([0x12, 0xab]));
 * // => '2ALG===='
 * base32hex.decode('2ALG====');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */ exports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));
/**
 * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.
 * Use `base32hex` for padded version.
 * @example
 * ```js
 * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));
 * // => '2ALG'
 * base32hexnopad.decode('2ALG');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */ exports.base32hexnopad = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));
/**
 * base32 encoding from RFC 4648. Doug Crockford's version.
 * https://www.crockford.com/base32.html
 * @example
 * ```js
 * base32crockford.encode(Uint8Array.from([0x12, 0xab]));
 * // => '2ANG'
 * base32crockford.decode('2ANG');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */ exports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s)=>s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));
// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64
// prettier-ignore
const hasBase64Builtin = /* @__PURE__ */ (()=>typeof Uint8Array.from([]).toBase64 === 'function' && typeof Uint8Array.fromBase64 === 'function')();
const decodeBase64Builtin = (s, isUrl)=>{
    astr('base64', s);
    const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
    const alphabet = isUrl ? 'base64url' : 'base64';
    if (s.length > 0 && !re.test(s)) throw new Error('invalid base64');
    return Uint8Array.fromBase64(s, {
        alphabet,
        lastChunkHandling: 'strict'
    });
};
/**
 * base64 from RFC 4648. Padded.
 * Use `base64nopad` for unpadded version.
 * Also check out `base64url`, `base64urlnopad`.
 * Falls back to built-in function, when available.
 * @example
 * ```js
 * base64.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'Eqs='
 * base64.decode('Eqs=');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */ // prettier-ignore
exports.base64 = hasBase64Builtin ? {
    encode (b) {
        abytes(b);
        return b.toBase64();
    },
    decode (s) {
        return decodeBase64Builtin(s, false);
    }
} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));
/**
 * base64 from RFC 4648. No padding.
 * Use `base64` for padded version.
 * @example
 * ```js
 * base64nopad.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'Eqs'
 * base64nopad.decode('Eqs');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */ exports.base64nopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));
/**
 * base64 from RFC 4648, using URL-safe alphabet. Padded.
 * Use `base64urlnopad` for unpadded version.
 * Falls back to built-in function, when available.
 * @example
 * ```js
 * base64url.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'Eqs='
 * base64url.decode('Eqs=');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */ // prettier-ignore
exports.base64url = hasBase64Builtin ? {
    encode (b) {
        abytes(b);
        return b.toBase64({
            alphabet: 'base64url'
        });
    },
    decode (s) {
        return decodeBase64Builtin(s, true);
    }
} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));
/**
 * base64 from RFC 4648, using URL-safe alphabet. No padding.
 * Use `base64url` for padded version.
 * @example
 * ```js
 * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));
 * // => 'Eqs'
 * base64urlnopad.decode('Eqs');
 * // => Uint8Array.from([0x12, 0xab])
 * ```
 */ exports.base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));
// base58 code
// -----------
const genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc)=>chain(radix(58), alphabet(abc), join(''));
/**
 * base58: base64 without ambigous characters +, /, 0, O, I, l.
 * Quadratic (O(n^2)) - so, can't be used on large inputs.
 * @example
 * ```js
 * base58.decode('01abcdef');
 * // => '3UhJW'
 * ```
 */ exports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
/**
 * base58: flickr version. Check out `base58`.
 */ exports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');
/**
 * base58: XRP version. Check out `base58`.
 */ exports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');
// Data len (index) -> encoded block len
const XMR_BLOCK_LEN = [
    0,
    2,
    3,
    5,
    6,
    7,
    9,
    10,
    11
];
/**
 * base58: XMR version. Check out `base58`.
 * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.
 * Block encoding significantly reduces quadratic complexity of base58.
 */ exports.base58xmr = {
    encode (data) {
        let res = '';
        for(let i = 0; i < data.length; i += 8){
            const block = data.subarray(i, i + 8);
            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');
        }
        return res;
    },
    decode (str) {
        let res = [];
        for(let i = 0; i < str.length; i += 11){
            const slice = str.slice(i, i + 11);
            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
            const block = exports.base58.decode(slice);
            for(let j = 0; j < block.length - blockLen; j++){
                if (block[j] !== 0) throw new Error('base58xmr: wrong padding');
            }
            res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
    }
};
/**
 * Method, which creates base58check encoder.
 * Requires function, calculating sha256.
 */ const createBase58check = (sha256)=>chain(checksum(4, (data)=>sha256(sha256(data))), exports.base58);
exports.createBase58check = createBase58check;
/**
 * Use `createBase58check` instead.
 * @deprecated
 */ exports.base58check = exports.createBase58check;
const BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));
const POLYMOD_GENERATORS = [
    0x3b6a57b2,
    0x26508e6d,
    0x1ea119fa,
    0x3d4233dd,
    0x2a1462b3
];
function bech32Polymod(pre) {
    const b = pre >> 25;
    let chk = (pre & 0x1ffffff) << 5;
    for(let i = 0; i < POLYMOD_GENERATORS.length; i++){
        if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];
    }
    return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
    const len = prefix.length;
    let chk = 1;
    for(let i = 0; i < len; i++){
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod(chk) ^ c >> 5;
    }
    chk = bech32Polymod(chk);
    for(let i = 0; i < len; i++)chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;
    for (let v of words)chk = bech32Polymod(chk) ^ v;
    for(let i = 0; i < 6; i++)chk = bech32Polymod(chk);
    chk ^= encodingConst;
    return BECH_ALPHABET.encode(convertRadix2([
        chk % powers[30]
    ], 30, 5, false));
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function genBech32(encoding) {
    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;
    const _words = radix2(5);
    const fromWords = _words.decode;
    const toWords = _words.encode;
    const fromWordsUnsafe = unsafeWrapper(fromWords);
    function encode(prefix, words, limit = 90) {
        astr('bech32.encode prefix', prefix);
        if (isBytes(words)) words = Array.from(words);
        anumArr('bech32.encode', words);
        const plen = prefix.length;
        if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);
        const actualLength = plen + 7 + words.length;
        if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        const lowered = prefix.toLowerCase();
        const sum = bechChecksum(lowered, words, ENCODING_CONST);
        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
    }
    function decode(str, limit = 90) {
        astr('bech32.decode input', str);
        const slen = str.length;
        if (slen < 8 || limit !== false && slen > limit) throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
        // don't allow mixed case
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);
        const sepIndex = lowered.lastIndexOf('1');
        if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = lowered.slice(0, sepIndex);
        const data = lowered.slice(sepIndex + 1);
        if (data.length < 6) throw new Error('Data must be at least 6 characters long');
        const words = BECH_ALPHABET.decode(data).slice(0, -6);
        const sum = bechChecksum(prefix, words, ENCODING_CONST);
        if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return {
            prefix,
            words
        };
    }
    const decodeUnsafe = unsafeWrapper(decode);
    function decodeToBytes(str) {
        const { prefix, words } = decode(str, false);
        return {
            prefix,
            words,
            bytes: fromWords(words)
        };
    }
    function encodeFromBytes(prefix, bytes) {
        return encode(prefix, toWords(bytes));
    }
    return {
        encode,
        decode,
        encodeFromBytes,
        decodeToBytes,
        decodeUnsafe,
        fromWords,
        fromWordsUnsafe,
        toWords
    };
}
/**
 * bech32 from BIP 173. Operates on words.
 * For high-level, check out scure-btc-signer:
 * https://github.com/paulmillr/scure-btc-signer.
 */ exports.bech32 = genBech32('bech32');
/**
 * bech32m from BIP 350. Operates on words.
 * It was to mitigate `bech32` weaknesses.
 * For high-level, check out scure-btc-signer:
 * https://github.com/paulmillr/scure-btc-signer.
 */ exports.bech32m = genBech32('bech32m');
/**
 * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.
 * @example
 * ```js
 * const b = utf8.decode("hey"); // => new Uint8Array([ 104, 101, 121 ])
 * const str = utf8.encode(b); // "hey"
 * ```
 */ exports.utf8 = {
    encode: (data)=>new TextDecoder().decode(data),
    decode: (str)=>new TextEncoder().encode(str)
};
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
// prettier-ignore
const hasHexBuiltin = /* @__PURE__ */ (()=>typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// prettier-ignore
const hexBuiltin = {
    encode (data) {
        abytes(data);
        return data.toHex();
    },
    decode (s) {
        astr('hex', s);
        return Uint8Array.fromHex(s);
    }
};
/**
 * hex string decoder. Uses built-in function, when available.
 * @example
 * ```js
 * const b = hex.decode("0102ff"); // => new Uint8Array([ 1, 2, 255 ])
 * const str = hex.encode(b); // "0102ff"
 * ```
 */ exports.hex = hasHexBuiltin ? hexBuiltin : chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s)=>{
    if (typeof s !== 'string' || s.length % 2 !== 0) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
    return s.toLowerCase();
}));
// prettier-ignore
const CODERS = {
    utf8: exports.utf8,
    hex: exports.hex,
    base16: exports.base16,
    base32: exports.base32,
    base64: exports.base64,
    base64url: exports.base64url,
    base58: exports.base58,
    base58xmr: exports.base58xmr
};
const coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';
/** @deprecated */ const bytesToString = (type, bytes)=>{
    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);
    if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');
    return CODERS[type].encode(bytes);
};
exports.bytesToString = bytesToString;
/** @deprecated */ exports.str = exports.bytesToString; // as in python, but for bytes only
/** @deprecated */ const stringToBytes = (type, str)=>{
    if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);
    if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');
    return CODERS[type].decode(str);
};
exports.stringToBytes = stringToBytes;
/** @deprecated */ exports.bytes = exports.stringToBytes; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@metamask/superstruct/dist/error.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * A `StructFailure` represents a single specific failure in validation.
 */ /**
 * `StructError` objects are thrown (or returned) when validation fails.
 *
 * Validation logic is design to exit early for maximum performance. The error
 * represents the first error encountered during validation. For more detail,
 * the `error.failures` property is a generator function that can be run to
 * continue validation and receive all the failures in the data.
 */ __turbopack_context__.s([
    "StructError",
    ()=>StructError
]);
class StructError extends TypeError {
    constructor(failure, failures){
        let cached;
        const { message, explanation, ...rest } = failure;
        const { path } = failure;
        const cause = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;
        super(explanation ?? cause);
        if (explanation !== null && explanation !== undefined) {
            this.cause = cause;
        }
        Object.assign(this, rest);
        this.name = this.constructor.name;
        this.failures = ()=>{
            return cached ?? (cached = [
                failure,
                ...failures()
            ]);
        };
    }
} //# sourceMappingURL=error.mjs.map
}),
"[project]/node_modules/@metamask/superstruct/dist/utils.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isObject",
    ()=>isObject,
    "isPlainObject",
    ()=>isPlainObject,
    "print",
    ()=>print,
    "run",
    ()=>run,
    "shiftIterator",
    ()=>shiftIterator,
    "toFailure",
    ()=>toFailure,
    "toFailures",
    ()=>toFailures
]);
/**
 * Check if a value is an iterator.
 *
 * @param value - The value to check.
 * @returns Whether the value is an iterator.
 */ function isIterable(value) {
    return isObject(value) && typeof value[Symbol.iterator] === 'function';
}
function isObject(value) {
    return typeof value === 'object' && value !== null;
}
function isPlainObject(value) {
    if (Object.prototype.toString.call(value) !== '[object Object]') {
        return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.prototype;
}
function print(value) {
    if (typeof value === 'symbol') {
        return value.toString();
    }
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;
}
function shiftIterator(input) {
    const { done, value } = input.next();
    return done ? undefined : value;
}
function toFailure(result, context, struct, value) {
    if (result === true) {
        return undefined;
    } else if (result === false) {
        // eslint-disable-next-line no-param-reassign
        result = {};
    } else if (typeof result === 'string') {
        // eslint-disable-next-line no-param-reassign
        result = {
            message: result
        };
    }
    const { path, branch } = context;
    const { type } = struct;
    const { refinement, message = `Expected a value of type \`${type}\`${refinement ? ` with refinement \`${refinement}\`` : ''}, but received: \`${print(value)}\`` } = result;
    return {
        value,
        type,
        refinement,
        key: path[path.length - 1],
        path,
        branch,
        ...result,
        message
    };
}
function* toFailures(result, context, struct, value) {
    if (!isIterable(result)) {
        // eslint-disable-next-line no-param-reassign
        result = [
            result
        ];
    }
    for (const validationResult of result){
        const failure = toFailure(validationResult, context, struct, value);
        if (failure) {
            yield failure;
        }
    }
}
function* run(value, struct, options = {}) {
    const { path = [], branch = [
        value
    ], coerce = false, mask = false } = options;
    const context = {
        path,
        branch
    };
    if (coerce) {
        // eslint-disable-next-line no-param-reassign
        value = struct.coercer(value, context);
        if (mask && struct.type !== 'type' && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {
            for(const key in value){
                if (struct.schema[key] === undefined) {
                    delete value[key];
                }
            }
        }
    }
    let status = 'valid';
    for (const failure of struct.validator(value, context)){
        failure.explanation = options.message;
        status = 'not_valid';
        yield [
            failure,
            undefined
        ];
    }
    // eslint-disable-next-line prefer-const
    for (let [innerKey, innerValue, innerStruct] of struct.entries(value, context)){
        const iterable = run(innerValue, innerStruct, {
            path: innerKey === undefined ? path : [
                ...path,
                innerKey
            ],
            branch: innerKey === undefined ? branch : [
                ...branch,
                innerValue
            ],
            coerce,
            mask,
            message: options.message
        });
        for (const result of iterable){
            if (result[0]) {
                status = result[0].refinement === null || result[0].refinement === undefined ? 'not_valid' : 'not_refined';
                yield [
                    result[0],
                    undefined
                ];
            } else if (coerce) {
                innerValue = result[1];
                if (innerKey === undefined) {
                    // eslint-disable-next-line no-param-reassign
                    value = innerValue;
                } else if (value instanceof Map) {
                    value.set(innerKey, innerValue);
                } else if (value instanceof Set) {
                    value.add(innerValue);
                } else if (isObject(value)) {
                    if (innerValue !== undefined || innerKey in value) {
                        value[innerKey] = innerValue;
                    }
                }
            }
        }
    }
    if (status !== 'not_valid') {
        for (const failure of struct.refiner(value, context)){
            failure.explanation = options.message;
            status = 'not_refined';
            yield [
                failure,
                undefined
            ];
        }
    }
    if (status === 'valid') {
        yield [
            undefined,
            value
        ];
    }
} //# sourceMappingURL=utils.mjs.map
}),
"[project]/node_modules/@metamask/superstruct/dist/struct.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ExactOptionalStruct",
    ()=>ExactOptionalStruct,
    "Struct",
    ()=>Struct,
    "assert",
    ()=>assert,
    "create",
    ()=>create,
    "is",
    ()=>is,
    "mask",
    ()=>mask,
    "validate",
    ()=>validate
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$error$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/error.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/utils.mjs [app-ssr] (ecmascript)");
;
;
class Struct {
    constructor(props){
        const { type, schema, validator, refiner, coercer = (value)=>value, entries = function*() {
        /* noop */ } } = props;
        this.type = type;
        this.schema = schema;
        this.entries = entries;
        this.coercer = coercer;
        if (validator) {
            this.validator = (value, context)=>{
                const result = validator(value, context);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toFailures"])(result, context, this, value);
            };
        } else {
            this.validator = ()=>[];
        }
        if (refiner) {
            this.refiner = (value, context)=>{
                const result = refiner(value, context);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toFailures"])(result, context, this, value);
            };
        } else {
            this.refiner = ()=>[];
        }
    }
    /**
     * Assert that a value passes the struct's validation, throwing if it doesn't.
     */ assert(value, message) {
        return assert(value, this, message);
    }
    /**
     * Create a value with the struct's coercion logic, then validate it.
     */ create(value, message) {
        return create(value, this, message);
    }
    /**
     * Check if a value passes the struct's validation.
     */ is(value) {
        return is(value, this);
    }
    /**
     * Mask a value, coercing and validating it, but returning only the subset of
     * properties defined by the struct's schema.
     */ mask(value, message) {
        return mask(value, this, message);
    }
    /**
     * Validate a value with the struct's validation logic, returning a tuple
     * representing the result.
     *
     * You may optionally pass `true` for the `withCoercion` argument to coerce
     * the value before attempting to validate it. If you do, the result will
     * contain the coerced result when successful.
     */ validate(value, options = {}) {
        return validate(value, this, options);
    }
}
// String instead of a Symbol in case of multiple different versions of this library.
const ExactOptionalBrand = 'EXACT_OPTIONAL';
class ExactOptionalStruct extends Struct {
    constructor(props){
        super({
            ...props,
            type: `exact optional ${props.type}`
        });
        this.brand = ExactOptionalBrand;
    }
    static isExactOptional(value) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(value) && 'brand' in value && value.brand === ExactOptionalBrand;
    }
}
function assert(value, struct, message) {
    const result = validate(value, struct, {
        message
    });
    if (result[0]) {
        throw result[0];
    }
}
function create(value, struct, message) {
    const result = validate(value, struct, {
        coerce: true,
        message
    });
    if (result[0]) {
        throw result[0];
    } else {
        return result[1];
    }
}
function mask(value, struct, message) {
    const result = validate(value, struct, {
        coerce: true,
        mask: true,
        message
    });
    if (result[0]) {
        throw result[0];
    } else {
        return result[1];
    }
}
function is(value, struct) {
    const result = validate(value, struct);
    return !result[0];
}
function validate(value, struct, options = {}) {
    const tuples = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["run"])(value, struct, options);
    const tuple = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["shiftIterator"])(tuples);
    if (tuple[0]) {
        const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$error$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["StructError"](tuple[0], function*() {
            for (const innerTuple of tuples){
                if (innerTuple[0]) {
                    yield innerTuple[0];
                }
            }
        });
        return [
            error,
            undefined
        ];
    }
    const validatedValue = tuple[1];
    return [
        undefined,
        validatedValue
    ];
} //# sourceMappingURL=struct.mjs.map
}),
"[project]/node_modules/@metamask/superstruct/dist/structs/refinements.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "empty",
    ()=>empty,
    "max",
    ()=>max,
    "min",
    ()=>min,
    "nonempty",
    ()=>nonempty,
    "pattern",
    ()=>pattern,
    "refine",
    ()=>refine,
    "size",
    ()=>size
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/struct.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/utils.mjs [app-ssr] (ecmascript)");
;
;
function empty(struct) {
    return refine(struct, 'empty', (value)=>{
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const size = getSize(value);
        return size === 0 || `Expected an empty ${struct.type} but received one with a size of \`${size}\``;
    });
}
/**
 * Get the size of a string, array, map, or set.
 *
 * @param value - The value to measure.
 * @returns The size of the value.
 */ function getSize(value) {
    if (value instanceof Map || value instanceof Set) {
        return value.size;
    }
    return value.length;
}
function max(struct, threshold, options = {}) {
    const { exclusive } = options;
    return refine(struct, 'max', (value)=>{
        return exclusive ? value < threshold : value <= threshold || `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \`${value}\``;
    });
}
function min(struct, threshold, options = {}) {
    const { exclusive } = options;
    return refine(struct, 'min', (value)=>{
        return exclusive ? value > threshold : value >= threshold || `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \`${value}\``;
    });
}
function nonempty(struct) {
    return refine(struct, 'nonempty', (value)=>{
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const size = getSize(value);
        return size > 0 || `Expected a nonempty ${struct.type} but received an empty one`;
    });
}
function pattern(struct, regexp) {
    return refine(struct, 'pattern', (value)=>{
        return regexp.test(value) || `Expected a ${struct.type} matching \`/${regexp.source}/\` but received "${value}"`;
    });
}
function size(struct, minimum, maximum = minimum) {
    const expected = `Expected a ${struct.type}`;
    const of = minimum === maximum ? `of \`${minimum}\`` : `between \`${minimum}\` and \`${maximum}\``;
    return refine(struct, 'size', (value)=>{
        if (typeof value === 'number' || value instanceof Date) {
            return minimum <= value && value <= maximum || // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${expected} ${of} but received \`${value}\``;
        } else if (value instanceof Map || value instanceof Set) {
            // eslint-disable-next-line @typescript-eslint/no-shadow
            const { size } = value;
            return minimum <= size && size <= maximum || `${expected} with a size ${of} but received one with a size of \`${size}\``;
        }
        const { length } = value;
        return minimum <= length && length <= maximum || `${expected} with a length ${of} but received one with a length of \`${length}\``;
    });
}
function refine(struct, name, refiner) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        ...struct,
        *refiner (value, ctx) {
            yield* struct.refiner(value, ctx);
            const result = refiner(value, ctx);
            const failures = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toFailures"])(result, ctx, struct, value);
            for (const failure of failures){
                yield {
                    ...failure,
                    refinement: name
                };
            }
        }
    });
} //# sourceMappingURL=refinements.mjs.map
}),
"[project]/node_modules/@metamask/superstruct/dist/structs/utilities.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "assign",
    ()=>assign,
    "define",
    ()=>define,
    "deprecated",
    ()=>deprecated,
    "dynamic",
    ()=>dynamic,
    "lazy",
    ()=>lazy,
    "omit",
    ()=>omit,
    "partial",
    ()=>partial,
    "pick",
    ()=>pick
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/struct.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/structs/types.mjs [app-ssr] (ecmascript)");
;
;
function assign(...Structs) {
    const isType = Structs[0]?.type === 'type';
    const schemas = Structs.map(({ schema })=>schema);
    const schema = Object.assign({}, ...schemas);
    return isType ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["type"])(schema) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["object"])(schema);
}
function define(name, validator) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: name,
        schema: null,
        validator
    });
}
function deprecated(struct, log) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        ...struct,
        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx),
        validator (value, ctx) {
            if (value === undefined) {
                return true;
            }
            log(value, ctx);
            return struct.validator(value, ctx);
        }
    });
}
function dynamic(fn) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'dynamic',
        schema: null,
        *entries (value, ctx) {
            const struct = fn(value, ctx);
            yield* struct.entries(value, ctx);
        },
        validator (value, ctx) {
            const struct = fn(value, ctx);
            return struct.validator(value, ctx);
        },
        coercer (value, ctx) {
            const struct = fn(value, ctx);
            return struct.coercer(value, ctx);
        },
        refiner (value, ctx) {
            const struct = fn(value, ctx);
            return struct.refiner(value, ctx);
        }
    });
}
function lazy(fn) {
    let struct;
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'lazy',
        schema: null,
        *entries (value, ctx) {
            struct ?? (struct = fn());
            yield* struct.entries(value, ctx);
        },
        validator (value, ctx) {
            struct ?? (struct = fn());
            return struct.validator(value, ctx);
        },
        coercer (value, ctx) {
            struct ?? (struct = fn());
            return struct.coercer(value, ctx);
        },
        refiner (value, ctx) {
            struct ?? (struct = fn());
            return struct.refiner(value, ctx);
        }
    });
}
function omit(struct, keys) {
    const { schema } = struct;
    const subschema = {
        ...schema
    };
    for (const key of keys){
        delete subschema[key];
    }
    switch(struct.type){
        case 'type':
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["type"])(subschema);
        default:
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["object"])(subschema);
    }
}
function partial(struct) {
    const isStruct = struct instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"];
    const schema = isStruct ? {
        ...struct.schema
    } : {
        ...struct
    };
    // eslint-disable-next-line guard-for-in
    for(const key in schema){
        schema[key] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["optional"])(schema[key]);
    }
    if (isStruct && struct.type === 'type') {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["type"])(schema);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["object"])(schema);
}
function pick(struct, keys) {
    const { schema } = struct;
    const subschema = {};
    for (const key of keys){
        subschema[key] = schema[key];
    }
    switch(struct.type){
        case 'type':
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["type"])(subschema);
        default:
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$types$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["object"])(subschema);
    }
} //# sourceMappingURL=utilities.mjs.map
}),
"[project]/node_modules/@metamask/superstruct/dist/structs/types.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "any",
    ()=>any,
    "array",
    ()=>array,
    "bigint",
    ()=>bigint,
    "boolean",
    ()=>boolean,
    "date",
    ()=>date,
    "enums",
    ()=>enums,
    "exactOptional",
    ()=>exactOptional,
    "func",
    ()=>func,
    "instance",
    ()=>instance,
    "integer",
    ()=>integer,
    "intersection",
    ()=>intersection,
    "literal",
    ()=>literal,
    "map",
    ()=>map,
    "never",
    ()=>never,
    "nullable",
    ()=>nullable,
    "number",
    ()=>number,
    "object",
    ()=>object,
    "optional",
    ()=>optional,
    "record",
    ()=>record,
    "regexp",
    ()=>regexp,
    "set",
    ()=>set,
    "string",
    ()=>string,
    "tuple",
    ()=>tuple,
    "type",
    ()=>type,
    "union",
    ()=>union,
    "unknown",
    ()=>unknown
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/struct.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/utils.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/superstruct/dist/structs/utilities.mjs [app-ssr] (ecmascript)");
;
;
;
function any() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('any', ()=>true);
}
function array(Element) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'array',
        schema: Element,
        *entries (value) {
            if (Element && Array.isArray(value)) {
                for (const [index, arrayValue] of value.entries()){
                    yield [
                        index,
                        arrayValue,
                        Element
                    ];
                }
            }
        },
        coercer (value) {
            return Array.isArray(value) ? value.slice() : value;
        },
        validator (value) {
            return Array.isArray(value) || `Expected an array value, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
        }
    });
}
function bigint() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('bigint', (value)=>{
        return typeof value === 'bigint';
    });
}
function boolean() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('boolean', (value)=>{
        return typeof value === 'boolean';
    });
}
function date() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('date', (value)=>{
        return value instanceof Date && !isNaN(value.getTime()) || `Expected a valid \`Date\` object, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
    });
}
function enums(values) {
    const schema = {};
    const description = values.map((value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)).join();
    for (const key of values){
        schema[key] = key;
    }
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'enums',
        schema,
        validator (value) {
            return values.includes(value) || `Expected one of \`${description}\`, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
        }
    });
}
function func() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('func', (value)=>{
        return typeof value === 'function' || `Expected a function, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
    });
}
function instance(Class) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('instance', (value)=>{
        return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
    });
}
function integer() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('integer', (value)=>{
        return typeof value === 'number' && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
    });
}
function intersection(Structs) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'intersection',
        schema: null,
        *entries (value, context) {
            for (const { entries } of Structs){
                yield* entries(value, context);
            }
        },
        *validator (value, context) {
            for (const { validator } of Structs){
                yield* validator(value, context);
            }
        },
        *refiner (value, context) {
            for (const { refiner } of Structs){
                yield* refiner(value, context);
            }
        }
    });
}
function literal(constant) {
    const description = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(constant);
    const valueType = typeof constant;
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'literal',
        schema: valueType === 'string' || valueType === 'number' || valueType === 'boolean' ? constant : null,
        validator (value) {
            return value === constant || `Expected the literal \`${description}\`, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
        }
    });
}
function map(Key, Value) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'map',
        schema: null,
        *entries (value) {
            if (Key && Value && value instanceof Map) {
                for (const [mapKey, mapValue] of value.entries()){
                    yield [
                        mapKey,
                        mapKey,
                        Key
                    ];
                    yield [
                        mapKey,
                        mapValue,
                        Value
                    ];
                }
            }
        },
        coercer (value) {
            return value instanceof Map ? new Map(value) : value;
        },
        validator (value) {
            return value instanceof Map || `Expected a \`Map\` object, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
        }
    });
}
function never() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('never', ()=>false);
}
function nullable(struct) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        ...struct,
        validator: (value, ctx)=>value === null || struct.validator(value, ctx),
        refiner: (value, ctx)=>value === null || struct.refiner(value, ctx)
    });
}
function number() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('number', (value)=>{
        return typeof value === 'number' && !isNaN(value) || `Expected a number, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
    });
}
function object(schema) {
    const knowns = schema ? Object.keys(schema) : [];
    const Never = never();
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'object',
        schema: schema ?? null,
        *entries (value) {
            if (schema && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(value)) {
                const unknowns = new Set(Object.keys(value));
                for (const key of knowns){
                    unknowns.delete(key);
                    const propertySchema = schema[key];
                    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExactOptionalStruct"].isExactOptional(propertySchema) && !Object.prototype.hasOwnProperty.call(value, key)) {
                        continue;
                    }
                    yield [
                        key,
                        value[key],
                        schema[key]
                    ];
                }
                for (const key of unknowns){
                    yield [
                        key,
                        value[key],
                        Never
                    ];
                }
            }
        },
        validator (value) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(value) || `Expected an object, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
        },
        coercer (value) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(value) ? {
                ...value
            } : value;
        }
    });
}
function optional(struct) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        ...struct,
        validator: (value, ctx)=>value === undefined || struct.validator(value, ctx),
        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx)
    });
}
function exactOptional(struct) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ExactOptionalStruct"](struct);
}
function record(Key, Value) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'record',
        schema: null,
        *entries (value) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(value)) {
                // eslint-disable-next-line guard-for-in
                for(const objectKey in value){
                    const objectValue = value[objectKey];
                    yield [
                        objectKey,
                        objectKey,
                        Key
                    ];
                    yield [
                        objectKey,
                        objectValue,
                        Value
                    ];
                }
            }
        },
        validator (value) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(value) || `Expected an object, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
        }
    });
}
function regexp() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('regexp', (value)=>{
        return value instanceof RegExp;
    });
}
function set(Element) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'set',
        schema: null,
        *entries (value) {
            if (Element && value instanceof Set) {
                for (const setValue of value){
                    yield [
                        setValue,
                        setValue,
                        Element
                    ];
                }
            }
        },
        coercer (value) {
            return value instanceof Set ? new Set(value) : value;
        },
        validator (value) {
            return value instanceof Set || `Expected a \`Set\` object, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
        }
    });
}
function string() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('string', (value)=>{
        return typeof value === 'string' || `Expected a string, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
    });
}
function tuple(Structs) {
    const Never = never();
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'tuple',
        schema: null,
        *entries (value) {
            if (Array.isArray(value)) {
                const length = Math.max(Structs.length, value.length);
                for(let i = 0; i < length; i++){
                    yield [
                        i,
                        value[i],
                        Structs[i] || Never
                    ];
                }
            }
        },
        validator (value) {
            return Array.isArray(value) || `Expected an array, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
        }
    });
}
function type(schema) {
    const keys = Object.keys(schema);
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'type',
        schema,
        *entries (value) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(value)) {
                for (const k of keys){
                    yield [
                        k,
                        value[k],
                        schema[k]
                    ];
                }
            }
        },
        validator (value) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(value) || `Expected an object, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`;
        },
        coercer (value) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isObject"])(value) ? {
                ...value
            } : value;
        }
    });
}
function union(Structs) {
    const description = Structs.map((struct)=>struct.type).join(' | ');
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$struct$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Struct"]({
        type: 'union',
        schema: null,
        coercer (value) {
            for (const InnerStruct of Structs){
                const [error, coerced] = InnerStruct.validate(value, {
                    coerce: true
                });
                if (!error) {
                    return coerced;
                }
            }
            return value;
        },
        validator (value, ctx) {
            const failures = [];
            for (const InnerStruct of Structs){
                const [...tuples] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["run"])(value, InnerStruct, ctx);
                const [first] = tuples;
                if (!first?.[0]) {
                    return [];
                }
                for (const [failure] of tuples){
                    if (failure) {
                        failures.push(failure);
                    }
                }
            }
            return [
                `Expected the value to satisfy a union of \`${description}\`, but received: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$utils$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["print"])(value)}`,
                ...failures
            ];
        }
    });
}
function unknown() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$superstruct$2f$dist$2f$structs$2f$utilities$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["define"])('unknown', ()=>true);
} //# sourceMappingURL=types.mjs.map
}),
"[project]/node_modules/@metamask/superstruct/dist/error.cjs [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * A `StructFailure` represents a single specific failure in validation.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StructError = void 0;
/**
 * `StructError` objects are thrown (or returned) when validation fails.
 *
 * Validation logic is design to exit early for maximum performance. The error
 * represents the first error encountered during validation. For more detail,
 * the `error.failures` property is a generator function that can be run to
 * continue validation and receive all the failures in the data.
 */ class StructError extends TypeError {
    constructor(failure, failures){
        let cached;
        const { message, explanation, ...rest } = failure;
        const { path } = failure;
        const cause = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;
        super(explanation ?? cause);
        if (explanation !== null && explanation !== undefined) {
            this.cause = cause;
        }
        Object.assign(this, rest);
        this.name = this.constructor.name;
        this.failures = ()=>{
            return cached ?? (cached = [
                failure,
                ...failures()
            ]);
        };
    }
}
exports.StructError = StructError; //# sourceMappingURL=error.cjs.map
}),
"[project]/node_modules/@metamask/superstruct/dist/utils.cjs [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.run = exports.toFailures = exports.toFailure = exports.shiftIterator = exports.print = exports.isPlainObject = exports.isObject = void 0;
/**
 * Check if a value is an iterator.
 *
 * @param value - The value to check.
 * @returns Whether the value is an iterator.
 */ function isIterable(value) {
    return isObject(value) && typeof value[Symbol.iterator] === 'function';
}
/**
 * Check if a value is a plain object.
 *
 * @param value - The value to check.
 * @returns Whether the value is a plain object.
 */ function isObject(value) {
    return typeof value === 'object' && value !== null;
}
exports.isObject = isObject;
/**
 * Check if a value is a plain object.
 *
 * @param value - The value to check.
 * @returns Whether the value is a plain object.
 */ function isPlainObject(value) {
    if (Object.prototype.toString.call(value) !== '[object Object]') {
        return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.prototype;
}
exports.isPlainObject = isPlainObject;
/**
 * Return a value as a printable string.
 *
 * @param value - The value to print.
 * @returns The value as a string.
 */ function print(value) {
    if (typeof value === 'symbol') {
        return value.toString();
    }
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;
}
exports.print = print;
/**
 * Shift (remove and return) the first value from the `input` iterator.
 * Like `Array.prototype.shift()` but for an `Iterator`.
 *
 * @param input - The iterator to shift.
 * @returns The first value of the iterator, or `undefined` if the iterator is
 * empty.
 */ function shiftIterator(input) {
    const { done, value } = input.next();
    return done ? undefined : value;
}
exports.shiftIterator = shiftIterator;
/**
 * Convert a single validation result to a failure.
 *
 * @param result - The result to convert.
 * @param context - The context of the validation.
 * @param struct - The struct being validated.
 * @param value - The value being validated.
 * @returns A failure if the result is a failure, or `undefined` if the result
 * is a success.
 */ function toFailure(result, context, struct, value) {
    if (result === true) {
        return undefined;
    } else if (result === false) {
        // eslint-disable-next-line no-param-reassign
        result = {};
    } else if (typeof result === 'string') {
        // eslint-disable-next-line no-param-reassign
        result = {
            message: result
        };
    }
    const { path, branch } = context;
    const { type } = struct;
    const { refinement, message = `Expected a value of type \`${type}\`${refinement ? ` with refinement \`${refinement}\`` : ''}, but received: \`${print(value)}\`` } = result;
    return {
        value,
        type,
        refinement,
        key: path[path.length - 1],
        path,
        branch,
        ...result,
        message
    };
}
exports.toFailure = toFailure;
/**
 * Convert a validation result to an iterable of failures.
 *
 * @param result - The result to convert.
 * @param context - The context of the validation.
 * @param struct - The struct being validated.
 * @param value - The value being validated.
 * @yields The failures.
 * @returns An iterable of failures.
 */ function* toFailures(result, context, struct, value) {
    if (!isIterable(result)) {
        // eslint-disable-next-line no-param-reassign
        result = [
            result
        ];
    }
    for (const validationResult of result){
        const failure = toFailure(validationResult, context, struct, value);
        if (failure) {
            yield failure;
        }
    }
}
exports.toFailures = toFailures;
/**
 * Check a value against a struct, traversing deeply into nested values, and
 * returning an iterator of failures or success.
 *
 * @param value - The value to check.
 * @param struct - The struct to check against.
 * @param options - Optional settings.
 * @param options.path - The path to the value in the input data.
 * @param options.branch - The branch of the value in the input data.
 * @param options.coerce - Whether to coerce the value before validating it.
 * @param options.mask - Whether to mask the value before validating it.
 * @param options.message - An optional message to include in the error.
 * @yields An iterator of failures or success.
 * @returns An iterator of failures or success.
 */ function* run(value, struct, options = {}) {
    const { path = [], branch = [
        value
    ], coerce = false, mask = false } = options;
    const context = {
        path,
        branch
    };
    if (coerce) {
        // eslint-disable-next-line no-param-reassign
        value = struct.coercer(value, context);
        if (mask && struct.type !== 'type' && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {
            for(const key in value){
                if (struct.schema[key] === undefined) {
                    delete value[key];
                }
            }
        }
    }
    let status = 'valid';
    for (const failure of struct.validator(value, context)){
        failure.explanation = options.message;
        status = 'not_valid';
        yield [
            failure,
            undefined
        ];
    }
    // eslint-disable-next-line prefer-const
    for (let [innerKey, innerValue, innerStruct] of struct.entries(value, context)){
        const iterable = run(innerValue, innerStruct, {
            path: innerKey === undefined ? path : [
                ...path,
                innerKey
            ],
            branch: innerKey === undefined ? branch : [
                ...branch,
                innerValue
            ],
            coerce,
            mask,
            message: options.message
        });
        for (const result of iterable){
            if (result[0]) {
                status = result[0].refinement === null || result[0].refinement === undefined ? 'not_valid' : 'not_refined';
                yield [
                    result[0],
                    undefined
                ];
            } else if (coerce) {
                innerValue = result[1];
                if (innerKey === undefined) {
                    // eslint-disable-next-line no-param-reassign
                    value = innerValue;
                } else if (value instanceof Map) {
                    value.set(innerKey, innerValue);
                } else if (value instanceof Set) {
                    value.add(innerValue);
                } else if (isObject(value)) {
                    if (innerValue !== undefined || innerKey in value) {
                        value[innerKey] = innerValue;
                    }
                }
            }
        }
    }
    if (status !== 'not_valid') {
        for (const failure of struct.refiner(value, context)){
            failure.explanation = options.message;
            status = 'not_refined';
            yield [
                failure,
                undefined
            ];
        }
    }
    if (status === 'valid') {
        yield [
            undefined,
            value
        ];
    }
}
exports.run = run; //# sourceMappingURL=utils.cjs.map
}),
"[project]/node_modules/@metamask/superstruct/dist/struct.cjs [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validate = exports.is = exports.mask = exports.create = exports.assert = exports.ExactOptionalStruct = exports.Struct = void 0;
const error_js_1 = __turbopack_context__.r("[project]/node_modules/@metamask/superstruct/dist/error.cjs [app-ssr] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@metamask/superstruct/dist/utils.cjs [app-ssr] (ecmascript)");
/**
 * `Struct` objects encapsulate the validation logic for a specific type of
 * values. Once constructed, you use the `assert`, `is` or `validate` helpers to
 * validate unknown input data against the struct.
 */ class Struct {
    constructor(props){
        const { type, schema, validator, refiner, coercer = (value)=>value, entries = function*() {
        /* noop */ } } = props;
        this.type = type;
        this.schema = schema;
        this.entries = entries;
        this.coercer = coercer;
        if (validator) {
            this.validator = (value, context)=>{
                const result = validator(value, context);
                return (0, utils_js_1.toFailures)(result, context, this, value);
            };
        } else {
            this.validator = ()=>[];
        }
        if (refiner) {
            this.refiner = (value, context)=>{
                const result = refiner(value, context);
                return (0, utils_js_1.toFailures)(result, context, this, value);
            };
        } else {
            this.refiner = ()=>[];
        }
    }
    /**
     * Assert that a value passes the struct's validation, throwing if it doesn't.
     */ assert(value, message) {
        return assert(value, this, message);
    }
    /**
     * Create a value with the struct's coercion logic, then validate it.
     */ create(value, message) {
        return create(value, this, message);
    }
    /**
     * Check if a value passes the struct's validation.
     */ is(value) {
        return is(value, this);
    }
    /**
     * Mask a value, coercing and validating it, but returning only the subset of
     * properties defined by the struct's schema.
     */ mask(value, message) {
        return mask(value, this, message);
    }
    /**
     * Validate a value with the struct's validation logic, returning a tuple
     * representing the result.
     *
     * You may optionally pass `true` for the `withCoercion` argument to coerce
     * the value before attempting to validate it. If you do, the result will
     * contain the coerced result when successful.
     */ validate(value, options = {}) {
        return validate(value, this, options);
    }
}
exports.Struct = Struct;
// String instead of a Symbol in case of multiple different versions of this library.
const ExactOptionalBrand = 'EXACT_OPTIONAL';
/**
 * An `ExactOptionalStruct` is a `Struct` that is used to create exactly optional
 * properties of `object()` structs.
 */ class ExactOptionalStruct extends Struct {
    constructor(props){
        super({
            ...props,
            type: `exact optional ${props.type}`
        });
        this.brand = ExactOptionalBrand;
    }
    static isExactOptional(value) {
        return (0, utils_js_1.isObject)(value) && 'brand' in value && value.brand === ExactOptionalBrand;
    }
}
exports.ExactOptionalStruct = ExactOptionalStruct;
/**
 * Assert that a value passes a struct, throwing if it doesn't.
 *
 * @param value - The value to validate.
 * @param struct - The struct to validate against.
 * @param message - An optional message to include in the error.
 */ function assert(value, struct, message) {
    const result = validate(value, struct, {
        message
    });
    if (result[0]) {
        throw result[0];
    }
}
exports.assert = assert;
/**
 * Create a value with the coercion logic of struct and validate it.
 *
 * @param value - The value to coerce and validate.
 * @param struct - The struct to validate against.
 * @param message - An optional message to include in the error.
 * @returns The coerced and validated value.
 */ function create(value, struct, message) {
    const result = validate(value, struct, {
        coerce: true,
        message
    });
    if (result[0]) {
        throw result[0];
    } else {
        return result[1];
    }
}
exports.create = create;
/**
 * Mask a value, returning only the subset of properties defined by a struct.
 *
 * @param value - The value to mask.
 * @param struct - The struct to mask against.
 * @param message - An optional message to include in the error.
 * @returns The masked value.
 */ function mask(value, struct, message) {
    const result = validate(value, struct, {
        coerce: true,
        mask: true,
        message
    });
    if (result[0]) {
        throw result[0];
    } else {
        return result[1];
    }
}
exports.mask = mask;
/**
 * Check if a value passes a struct.
 *
 * @param value - The value to validate.
 * @param struct - The struct to validate against.
 * @returns `true` if the value passes the struct, `false` otherwise.
 */ function is(value, struct) {
    const result = validate(value, struct);
    return !result[0];
}
exports.is = is;
/**
 * Validate a value against a struct, returning an error if invalid, or the
 * value (with potential coercion) if valid.
 *
 * @param value - The value to validate.
 * @param struct - The struct to validate against.
 * @param options - Optional settings.
 * @param options.coerce - Whether to coerce the value before validating it.
 * @param options.mask - Whether to mask the value before validating it.
 * @param options.message - An optional message to include in the error.
 * @returns A tuple containing the error (if invalid) and the validated value.
 */ function validate(value, struct, options = {}) {
    const tuples = (0, utils_js_1.run)(value, struct, options);
    const tuple = (0, utils_js_1.shiftIterator)(tuples);
    if (tuple[0]) {
        const error = new error_js_1.StructError(tuple[0], function*() {
            for (const innerTuple of tuples){
                if (innerTuple[0]) {
                    yield innerTuple[0];
                }
            }
        });
        return [
            error,
            undefined
        ];
    }
    const validatedValue = tuple[1];
    return [
        undefined,
        validatedValue
    ];
}
exports.validate = validate; //# sourceMappingURL=struct.cjs.map
}),
"[project]/node_modules/@metamask/superstruct/dist/structs/utilities.cjs [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.pick = exports.partial = exports.omit = exports.lazy = exports.dynamic = exports.deprecated = exports.define = exports.assign = void 0;
const struct_js_1 = __turbopack_context__.r("[project]/node_modules/@metamask/superstruct/dist/struct.cjs [app-ssr] (ecmascript)");
const types_js_1 = __turbopack_context__.r("[project]/node_modules/@metamask/superstruct/dist/structs/types.cjs [app-ssr] (ecmascript)");
/**
 * Create a new struct that combines the properties from multiple object or type
 * structs. Its return type will match the first parameter's type.
 *
 * @param Structs - The structs to combine.
 * @returns A new struct that combines the properties of the input structs.
 */ function assign(...Structs) {
    const isType = Structs[0]?.type === 'type';
    const schemas = Structs.map(({ schema })=>schema);
    const schema = Object.assign({}, ...schemas);
    return isType ? (0, types_js_1.type)(schema) : (0, types_js_1.object)(schema);
}
exports.assign = assign;
/**
 * Define a new struct type with a custom validation function.
 *
 * @param name - The name of the struct type.
 * @param validator - The validation function.
 * @returns A new struct type.
 */ function define(name, validator) {
    return new struct_js_1.Struct({
        type: name,
        schema: null,
        validator
    });
}
exports.define = define;
/**
 * Create a new struct based on an existing struct, but the value is allowed to
 * be `undefined`. `log` will be called if the value is not `undefined`.
 *
 * @param struct - The struct to augment.
 * @param log - The function to call when the value is not `undefined`.
 * @returns A new struct that will only accept `undefined` or values that pass
 * the input struct.
 */ function deprecated(struct, log) {
    return new struct_js_1.Struct({
        ...struct,
        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx),
        validator (value, ctx) {
            if (value === undefined) {
                return true;
            }
            log(value, ctx);
            return struct.validator(value, ctx);
        }
    });
}
exports.deprecated = deprecated;
/**
 * Create a struct with dynamic validation logic.
 *
 * The callback will receive the value currently being validated, and must
 * return a struct object to validate it with. This can be useful to model
 * validation logic that changes based on its input.
 *
 * @param fn - The callback to create the struct.
 * @returns A new struct with dynamic validation logic.
 */ function dynamic(fn) {
    return new struct_js_1.Struct({
        type: 'dynamic',
        schema: null,
        *entries (value, ctx) {
            const struct = fn(value, ctx);
            yield* struct.entries(value, ctx);
        },
        validator (value, ctx) {
            const struct = fn(value, ctx);
            return struct.validator(value, ctx);
        },
        coercer (value, ctx) {
            const struct = fn(value, ctx);
            return struct.coercer(value, ctx);
        },
        refiner (value, ctx) {
            const struct = fn(value, ctx);
            return struct.refiner(value, ctx);
        }
    });
}
exports.dynamic = dynamic;
/**
 * Create a struct with lazily evaluated validation logic.
 *
 * The first time validation is run with the struct, the callback will be called
 * and must return a struct object to use. This is useful for cases where you
 * want to have self-referential structs for nested data structures to avoid a
 * circular definition problem.
 *
 * @param fn - The callback to create the struct.
 * @returns A new struct with lazily evaluated validation logic.
 */ function lazy(fn) {
    let struct;
    return new struct_js_1.Struct({
        type: 'lazy',
        schema: null,
        *entries (value, ctx) {
            struct ?? (struct = fn());
            yield* struct.entries(value, ctx);
        },
        validator (value, ctx) {
            struct ?? (struct = fn());
            return struct.validator(value, ctx);
        },
        coercer (value, ctx) {
            struct ?? (struct = fn());
            return struct.coercer(value, ctx);
        },
        refiner (value, ctx) {
            struct ?? (struct = fn());
            return struct.refiner(value, ctx);
        }
    });
}
exports.lazy = lazy;
/**
 * Create a new struct based on an existing object struct, but excluding
 * specific properties.
 *
 * Like TypeScript's `Omit` utility.
 *
 * @param struct - The struct to augment.
 * @param keys - The keys to omit.
 * @returns A new struct that will not accept the input keys.
 */ function omit(struct, keys) {
    const { schema } = struct;
    const subschema = {
        ...schema
    };
    for (const key of keys){
        delete subschema[key];
    }
    switch(struct.type){
        case 'type':
            return (0, types_js_1.type)(subschema);
        default:
            return (0, types_js_1.object)(subschema);
    }
}
exports.omit = omit;
/**
 * Create a new struct based on an existing object struct, but with all of its
 * properties allowed to be `undefined`.
 *
 * Like TypeScript's `Partial` utility.
 *
 * @param struct - The struct to augment.
 * @returns A new struct that will accept the input keys as `undefined`.
 */ function partial(struct) {
    const isStruct = struct instanceof struct_js_1.Struct;
    const schema = isStruct ? {
        ...struct.schema
    } : {
        ...struct
    };
    // eslint-disable-next-line guard-for-in
    for(const key in schema){
        schema[key] = (0, types_js_1.optional)(schema[key]);
    }
    if (isStruct && struct.type === 'type') {
        return (0, types_js_1.type)(schema);
    }
    return (0, types_js_1.object)(schema);
}
exports.partial = partial;
/**
 * Create a new struct based on an existing object struct, but only including
 * specific properties.
 *
 * Like TypeScript's `Pick` utility.
 *
 * @param struct - The struct to augment.
 * @param keys - The keys to pick.
 * @returns A new struct that will only accept the input keys.
 */ function pick(struct, keys) {
    const { schema } = struct;
    const subschema = {};
    for (const key of keys){
        subschema[key] = schema[key];
    }
    switch(struct.type){
        case 'type':
            return (0, types_js_1.type)(subschema);
        default:
            return (0, types_js_1.object)(subschema);
    }
}
exports.pick = pick; //# sourceMappingURL=utilities.cjs.map
}),
"[project]/node_modules/@metamask/superstruct/dist/structs/types.cjs [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unknown = exports.union = exports.type = exports.tuple = exports.string = exports.set = exports.regexp = exports.record = exports.exactOptional = exports.optional = exports.object = exports.number = exports.nullable = exports.never = exports.map = exports.literal = exports.intersection = exports.integer = exports.instance = exports.func = exports.enums = exports.date = exports.boolean = exports.bigint = exports.array = exports.any = void 0;
const struct_js_1 = __turbopack_context__.r("[project]/node_modules/@metamask/superstruct/dist/struct.cjs [app-ssr] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@metamask/superstruct/dist/utils.cjs [app-ssr] (ecmascript)");
const utilities_js_1 = __turbopack_context__.r("[project]/node_modules/@metamask/superstruct/dist/structs/utilities.cjs [app-ssr] (ecmascript)");
/**
 * Ensure that any value passes validation.
 *
 * @returns A struct that will always pass validation.
 */ function any() {
    return (0, utilities_js_1.define)('any', ()=>true);
}
exports.any = any;
/**
 * Ensure that a value is an array and that its elements are of a specific type.
 *
 * Note: If you omit the element struct, the arrays elements will not be
 * iterated at all. This can be helpful for cases where performance is critical,
 * and it is preferred to using `array(any())`.
 *
 * @param Element - The struct to validate each element in the array against.
 * @returns A new struct that will only accept arrays of the given type.
 */ function array(Element) {
    return new struct_js_1.Struct({
        type: 'array',
        schema: Element,
        *entries (value) {
            if (Element && Array.isArray(value)) {
                for (const [index, arrayValue] of value.entries()){
                    yield [
                        index,
                        arrayValue,
                        Element
                    ];
                }
            }
        },
        coercer (value) {
            return Array.isArray(value) ? value.slice() : value;
        },
        validator (value) {
            return Array.isArray(value) || `Expected an array value, but received: ${(0, utils_js_1.print)(value)}`;
        }
    });
}
exports.array = array;
/**
 * Ensure that a value is a bigint.
 *
 * @returns A new struct that will only accept bigints.
 */ function bigint() {
    return (0, utilities_js_1.define)('bigint', (value)=>{
        return typeof value === 'bigint';
    });
}
exports.bigint = bigint;
/**
 * Ensure that a value is a boolean.
 *
 * @returns A new struct that will only accept booleans.
 */ function boolean() {
    return (0, utilities_js_1.define)('boolean', (value)=>{
        return typeof value === 'boolean';
    });
}
exports.boolean = boolean;
/**
 * Ensure that a value is a valid `Date`.
 *
 * Note: this also ensures that the value is *not* an invalid `Date` object,
 * which can occur when parsing a date fails but still returns a `Date`.
 *
 * @returns A new struct that will only accept valid `Date` objects.
 */ function date() {
    return (0, utilities_js_1.define)('date', (value)=>{
        return value instanceof Date && !isNaN(value.getTime()) || `Expected a valid \`Date\` object, but received: ${(0, utils_js_1.print)(value)}`;
    });
}
exports.date = date;
/**
 * Ensure that a value is one of a set of potential values.
 *
 * Note: after creating the struct, you can access the definition of the
 * potential values as `struct.schema`.
 *
 * @param values - The potential values that the input can be.
 * @returns A new struct that will only accept the given values.
 */ function enums(values) {
    const schema = {};
    const description = values.map((value)=>(0, utils_js_1.print)(value)).join();
    for (const key of values){
        schema[key] = key;
    }
    return new struct_js_1.Struct({
        type: 'enums',
        schema,
        validator (value) {
            return values.includes(value) || `Expected one of \`${description}\`, but received: ${(0, utils_js_1.print)(value)}`;
        }
    });
}
exports.enums = enums;
/**
 * Ensure that a value is a function.
 *
 * @returns A new struct that will only accept functions.
 */ // eslint-disable-next-line @typescript-eslint/ban-types
function func() {
    return (0, utilities_js_1.define)('func', (value)=>{
        return typeof value === 'function' || `Expected a function, but received: ${(0, utils_js_1.print)(value)}`;
    });
}
exports.func = func;
/**
 * Ensure that a value is an instance of a specific class.
 *
 * @param Class - The class that the value must be an instance of.
 * @returns A new struct that will only accept instances of the given class.
 */ function instance(Class) {
    return (0, utilities_js_1.define)('instance', (value)=>{
        return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${(0, utils_js_1.print)(value)}`;
    });
}
exports.instance = instance;
/**
 * Ensure that a value is an integer.
 *
 * @returns A new struct that will only accept integers.
 */ function integer() {
    return (0, utilities_js_1.define)('integer', (value)=>{
        return typeof value === 'number' && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${(0, utils_js_1.print)(value)}`;
    });
}
exports.integer = integer;
/**
 * Ensure that a value matches all of a set of types.
 *
 * @param Structs - The set of structs that the value must match.
 * @returns A new struct that will only accept values that match all of the
 * given structs.
 */ function intersection(Structs) {
    return new struct_js_1.Struct({
        type: 'intersection',
        schema: null,
        *entries (value, context) {
            for (const { entries } of Structs){
                yield* entries(value, context);
            }
        },
        *validator (value, context) {
            for (const { validator } of Structs){
                yield* validator(value, context);
            }
        },
        *refiner (value, context) {
            for (const { refiner } of Structs){
                yield* refiner(value, context);
            }
        }
    });
}
exports.intersection = intersection;
/**
 * Ensure that a value is an exact value, using `===` for comparison.
 *
 * @param constant - The exact value that the input must be.
 * @returns A new struct that will only accept the exact given value.
 */ function literal(constant) {
    const description = (0, utils_js_1.print)(constant);
    const valueType = typeof constant;
    return new struct_js_1.Struct({
        type: 'literal',
        schema: valueType === 'string' || valueType === 'number' || valueType === 'boolean' ? constant : null,
        validator (value) {
            return value === constant || `Expected the literal \`${description}\`, but received: ${(0, utils_js_1.print)(value)}`;
        }
    });
}
exports.literal = literal;
/**
 * Ensure that a value is a `Map` object, and that its keys and values are of
 * specific types.
 *
 * @param Key - The struct to validate each key in the map against.
 * @param Value - The struct to validate each value in the map against.
 * @returns A new struct that will only accept `Map` objects.
 */ function map(Key, Value) {
    return new struct_js_1.Struct({
        type: 'map',
        schema: null,
        *entries (value) {
            if (Key && Value && value instanceof Map) {
                for (const [mapKey, mapValue] of value.entries()){
                    yield [
                        mapKey,
                        mapKey,
                        Key
                    ];
                    yield [
                        mapKey,
                        mapValue,
                        Value
                    ];
                }
            }
        },
        coercer (value) {
            return value instanceof Map ? new Map(value) : value;
        },
        validator (value) {
            return value instanceof Map || `Expected a \`Map\` object, but received: ${(0, utils_js_1.print)(value)}`;
        }
    });
}
exports.map = map;
/**
 * Ensure that no value ever passes validation.
 *
 * @returns A new struct that will never pass validation.
 */ function never() {
    return (0, utilities_js_1.define)('never', ()=>false);
}
exports.never = never;
/**
 * Augment an existing struct to allow `null` values.
 *
 * @param struct - The struct to augment.
 * @returns A new struct that will accept `null` values.
 */ function nullable(struct) {
    return new struct_js_1.Struct({
        ...struct,
        validator: (value, ctx)=>value === null || struct.validator(value, ctx),
        refiner: (value, ctx)=>value === null || struct.refiner(value, ctx)
    });
}
exports.nullable = nullable;
/**
 * Ensure that a value is a number.
 *
 * @returns A new struct that will only accept numbers.
 */ function number() {
    return (0, utilities_js_1.define)('number', (value)=>{
        return typeof value === 'number' && !isNaN(value) || `Expected a number, but received: ${(0, utils_js_1.print)(value)}`;
    });
}
exports.number = number;
/**
 * Ensure that a value is an object, that it has a known set of properties,
 * and that its properties are of specific types.
 *
 * Note: Unrecognized properties will fail validation.
 *
 * @param schema - An object that defines the structure of the object.
 * @returns A new struct that will only accept objects.
 */ function object(schema) {
    const knowns = schema ? Object.keys(schema) : [];
    const Never = never();
    return new struct_js_1.Struct({
        type: 'object',
        schema: schema ?? null,
        *entries (value) {
            if (schema && (0, utils_js_1.isObject)(value)) {
                const unknowns = new Set(Object.keys(value));
                for (const key of knowns){
                    unknowns.delete(key);
                    const propertySchema = schema[key];
                    if (struct_js_1.ExactOptionalStruct.isExactOptional(propertySchema) && !Object.prototype.hasOwnProperty.call(value, key)) {
                        continue;
                    }
                    yield [
                        key,
                        value[key],
                        schema[key]
                    ];
                }
                for (const key of unknowns){
                    yield [
                        key,
                        value[key],
                        Never
                    ];
                }
            }
        },
        validator (value) {
            return (0, utils_js_1.isObject)(value) || `Expected an object, but received: ${(0, utils_js_1.print)(value)}`;
        },
        coercer (value) {
            return (0, utils_js_1.isObject)(value) ? {
                ...value
            } : value;
        }
    });
}
exports.object = object;
/**
 * Augment a struct to allow `undefined` values.
 *
 * @param struct - The struct to augment.
 * @returns A new struct that will accept `undefined` values.
 */ function optional(struct) {
    return new struct_js_1.Struct({
        ...struct,
        validator: (value, ctx)=>value === undefined || struct.validator(value, ctx),
        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx)
    });
}
exports.optional = optional;
/**
 * Augment a struct such that, if it is the property of an object, it is exactly optional.
 * In other words, it is either present with the correct type, or not present at all.
 *
 * NOTE: Only intended for use with `object()` structs.
 *
 * @param struct - The struct to augment.
 * @returns A new struct that can be used to create exactly optional properties of `object()`
 * structs.
 */ function exactOptional(struct) {
    return new struct_js_1.ExactOptionalStruct(struct);
}
exports.exactOptional = exactOptional;
/**
 * Ensure that a value is an object with keys and values of specific types, but
 * without ensuring any specific shape of properties.
 *
 * Like TypeScript's `Record` utility.
 */ /**
 * Ensure that a value is an object with keys and values of specific types, but
 * without ensuring any specific shape of properties.
 *
 * @param Key - The struct to validate each key in the record against.
 * @param Value - The struct to validate each value in the record against.
 * @returns A new struct that will only accept objects.
 */ function record(Key, Value) {
    return new struct_js_1.Struct({
        type: 'record',
        schema: null,
        *entries (value) {
            if ((0, utils_js_1.isObject)(value)) {
                // eslint-disable-next-line guard-for-in
                for(const objectKey in value){
                    const objectValue = value[objectKey];
                    yield [
                        objectKey,
                        objectKey,
                        Key
                    ];
                    yield [
                        objectKey,
                        objectValue,
                        Value
                    ];
                }
            }
        },
        validator (value) {
            return (0, utils_js_1.isObject)(value) || `Expected an object, but received: ${(0, utils_js_1.print)(value)}`;
        }
    });
}
exports.record = record;
/**
 * Ensure that a value is a `RegExp`.
 *
 * Note: this does not test the value against the regular expression! For that
 * you need to use the `pattern()` refinement.
 *
 * @returns A new struct that will only accept `RegExp` objects.
 */ function regexp() {
    return (0, utilities_js_1.define)('regexp', (value)=>{
        return value instanceof RegExp;
    });
}
exports.regexp = regexp;
/**
 * Ensure that a value is a `Set` object, and that its elements are of a
 * specific type.
 *
 * @param Element - The struct to validate each element in the set against.
 * @returns A new struct that will only accept `Set` objects.
 */ function set(Element) {
    return new struct_js_1.Struct({
        type: 'set',
        schema: null,
        *entries (value) {
            if (Element && value instanceof Set) {
                for (const setValue of value){
                    yield [
                        setValue,
                        setValue,
                        Element
                    ];
                }
            }
        },
        coercer (value) {
            return value instanceof Set ? new Set(value) : value;
        },
        validator (value) {
            return value instanceof Set || `Expected a \`Set\` object, but received: ${(0, utils_js_1.print)(value)}`;
        }
    });
}
exports.set = set;
/**
 * Ensure that a value is a string.
 *
 * @returns A new struct that will only accept strings.
 */ function string() {
    return (0, utilities_js_1.define)('string', (value)=>{
        return typeof value === 'string' || `Expected a string, but received: ${(0, utils_js_1.print)(value)}`;
    });
}
exports.string = string;
/**
 * Ensure that a value is a tuple of a specific length, and that each of its
 * elements is of a specific type.
 *
 * @param Structs - The set of structs that the value must match.
 * @returns A new struct that will only accept tuples of the given types.
 */ function tuple(Structs) {
    const Never = never();
    return new struct_js_1.Struct({
        type: 'tuple',
        schema: null,
        *entries (value) {
            if (Array.isArray(value)) {
                const length = Math.max(Structs.length, value.length);
                for(let i = 0; i < length; i++){
                    yield [
                        i,
                        value[i],
                        Structs[i] || Never
                    ];
                }
            }
        },
        validator (value) {
            return Array.isArray(value) || `Expected an array, but received: ${(0, utils_js_1.print)(value)}`;
        }
    });
}
exports.tuple = tuple;
/**
 * Ensure that a value has a set of known properties of specific types.
 *
 * Note: Unrecognized properties are allowed and untouched. This is similar to
 * how TypeScript's structural typing works.
 *
 * @param schema - An object that defines the structure of the object.
 * @returns A new struct that will only accept objects.
 */ function type(schema) {
    const keys = Object.keys(schema);
    return new struct_js_1.Struct({
        type: 'type',
        schema,
        *entries (value) {
            if ((0, utils_js_1.isObject)(value)) {
                for (const k of keys){
                    yield [
                        k,
                        value[k],
                        schema[k]
                    ];
                }
            }
        },
        validator (value) {
            return (0, utils_js_1.isObject)(value) || `Expected an object, but received: ${(0, utils_js_1.print)(value)}`;
        },
        coercer (value) {
            return (0, utils_js_1.isObject)(value) ? {
                ...value
            } : value;
        }
    });
}
exports.type = type;
/**
 * Ensure that a value matches one of a set of types.
 *
 * @param Structs - The set of structs that the value must match.
 * @returns A new struct that will only accept values that match one of the
 * given structs.
 */ function union(Structs) {
    const description = Structs.map((struct)=>struct.type).join(' | ');
    return new struct_js_1.Struct({
        type: 'union',
        schema: null,
        coercer (value) {
            for (const InnerStruct of Structs){
                const [error, coerced] = InnerStruct.validate(value, {
                    coerce: true
                });
                if (!error) {
                    return coerced;
                }
            }
            return value;
        },
        validator (value, ctx) {
            const failures = [];
            for (const InnerStruct of Structs){
                const [...tuples] = (0, utils_js_1.run)(value, InnerStruct, ctx);
                const [first] = tuples;
                if (!first?.[0]) {
                    return [];
                }
                for (const [failure] of tuples){
                    if (failure) {
                        failures.push(failure);
                    }
                }
            }
            return [
                `Expected the value to satisfy a union of \`${description}\`, but received: ${(0, utils_js_1.print)(value)}`,
                ...failures
            ];
        }
    });
}
exports.union = union;
/**
 * Ensure that any value passes validation, without widening its type to `any`.
 *
 * @returns A struct that will always pass validation.
 */ function unknown() {
    return (0, utilities_js_1.define)('unknown', ()=>true);
}
exports.unknown = unknown; //# sourceMappingURL=types.cjs.map
}),
"[project]/node_modules/@metamask/superstruct/dist/structs/coercions.cjs [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.trimmed = exports.defaulted = exports.coerce = void 0;
const struct_js_1 = __turbopack_context__.r("[project]/node_modules/@metamask/superstruct/dist/struct.cjs [app-ssr] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@metamask/superstruct/dist/utils.cjs [app-ssr] (ecmascript)");
const types_js_1 = __turbopack_context__.r("[project]/node_modules/@metamask/superstruct/dist/structs/types.cjs [app-ssr] (ecmascript)");
/**
 * Augment a `Struct` to add an additional coercion step to its input.
 *
 * This allows you to transform input data before validating it, to increase the
 * likelihood that it passes validationfor example for default values, parsing
 * different formats, etc.
 *
 * Note: You must use `create(value, Struct)` on the value to have the coercion
 * take effect! Using simply `assert()` or `is()` will not use coercion.
 *
 * @param struct - The struct to augment.
 * @param condition - A struct that the input must pass to be coerced.
 * @param coercer - A function that takes the input and returns the coerced
 * value.
 * @returns A new struct that will coerce its input before validating it.
 */ function coerce(struct, condition, coercer) {
    return new struct_js_1.Struct({
        ...struct,
        coercer: (value, ctx)=>{
            return (0, struct_js_1.is)(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);
        }
    });
}
exports.coerce = coerce;
/**
 * Augment a struct to replace `undefined` values with a default.
 *
 * Note: You must use `create(value, Struct)` on the value to have the coercion
 * take effect! Using simply `assert()` or `is()` will not use coercion.
 *
 * @param struct - The struct to augment.
 * @param fallback - The value to use when the input is `undefined`.
 * @param options - An optional options object.
 * @param options.strict - When `true`, the fallback will only be used when the
 * input is `undefined`. When `false`, the fallback will be used when the input
 * is `undefined` or when the input is a plain object and the fallback is a
 * plain object, and any keys in the fallback are missing from the input.
 * @returns A new struct that will replace `undefined` inputs with a default.
 */ function defaulted(struct, fallback, options = {}) {
    return coerce(struct, (0, types_js_1.unknown)(), (value)=>{
        const result = typeof fallback === 'function' ? fallback() : fallback;
        if (value === undefined) {
            return result;
        }
        if (!options.strict && (0, utils_js_1.isPlainObject)(value) && (0, utils_js_1.isPlainObject)(result)) {
            const ret = {
                ...value
            };
            let changed = false;
            for(const key in result){
                if (ret[key] === undefined) {
                    ret[key] = result[key];
                    changed = true;
                }
            }
            if (changed) {
                return ret;
            }
        }
        return value;
    });
}
exports.defaulted = defaulted;
/**
 * Augment a struct to trim string inputs.
 *
 * Note: You must use `create(value, Struct)` on the value to have the coercion
 * take effect! Using simply `assert()` or `is()` will not use coercion.
 *
 * @param struct - The struct to augment.
 * @returns A new struct that will trim string inputs before validating them.
 */ function trimmed(struct) {
    return coerce(struct, (0, types_js_1.string)(), (value)=>value.trim());
}
exports.trimmed = trimmed; //# sourceMappingURL=coercions.cjs.map
}),
"[project]/node_modules/@metamask/superstruct/dist/structs/refinements.cjs [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.refine = exports.size = exports.pattern = exports.nonempty = exports.min = exports.max = exports.empty = void 0;
const struct_js_1 = __turbopack_context__.r("[project]/node_modules/@metamask/superstruct/dist/struct.cjs [app-ssr] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@metamask/superstruct/dist/utils.cjs [app-ssr] (ecmascript)");
/**
 * Ensure that a string, array, map, or set is empty.
 *
 * @param struct - The struct to augment.
 * @returns A new struct that will only accept empty values.
 */ function empty(struct) {
    return refine(struct, 'empty', (value)=>{
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const size = getSize(value);
        return size === 0 || `Expected an empty ${struct.type} but received one with a size of \`${size}\``;
    });
}
exports.empty = empty;
/**
 * Get the size of a string, array, map, or set.
 *
 * @param value - The value to measure.
 * @returns The size of the value.
 */ function getSize(value) {
    if (value instanceof Map || value instanceof Set) {
        return value.size;
    }
    return value.length;
}
/**
 * Ensure that a number or date is below a threshold.
 *
 * @param struct - The struct to augment.
 * @param threshold - The maximum value that the input can be.
 * @param options - An optional options object.
 * @param options.exclusive - When `true`, the input must be strictly less than
 * the threshold. When `false`, the input must be less than or equal to the
 * threshold.
 * @returns A new struct that will only accept values below the threshold.
 */ function max(struct, threshold, options = {}) {
    const { exclusive } = options;
    return refine(struct, 'max', (value)=>{
        return exclusive ? value < threshold : value <= threshold || `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \`${value}\``;
    });
}
exports.max = max;
/**
 * Ensure that a number or date is above a threshold.
 *
 * @param struct - The struct to augment.
 * @param threshold - The minimum value that the input can be.
 * @param options - An optional options object.
 * @param options.exclusive - When `true`, the input must be strictly greater
 * than the threshold. When `false`, the input must be greater than or equal to
 * the threshold.
 * @returns A new struct that will only accept values above the threshold.
 */ function min(struct, threshold, options = {}) {
    const { exclusive } = options;
    return refine(struct, 'min', (value)=>{
        return exclusive ? value > threshold : value >= threshold || `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \`${value}\``;
    });
}
exports.min = min;
/**
 * Ensure that a string, array, map or set is not empty.
 *
 * @param struct - The struct to augment.
 * @returns A new struct that will only accept non-empty values.
 */ function nonempty(struct) {
    return refine(struct, 'nonempty', (value)=>{
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const size = getSize(value);
        return size > 0 || `Expected a nonempty ${struct.type} but received an empty one`;
    });
}
exports.nonempty = nonempty;
/**
 * Ensure that a string matches a regular expression.
 *
 * @param struct - The struct to augment.
 * @param regexp - The regular expression to match against.
 * @returns A new struct that will only accept strings matching the regular
 * expression.
 */ function pattern(struct, regexp) {
    return refine(struct, 'pattern', (value)=>{
        return regexp.test(value) || `Expected a ${struct.type} matching \`/${regexp.source}/\` but received "${value}"`;
    });
}
exports.pattern = pattern;
/**
 * Ensure that a string, array, number, date, map, or set has a size (or length,
 * or time) between `min` and `max`.
 *
 * @param struct - The struct to augment.
 * @param minimum - The minimum size that the input can be.
 * @param maximum - The maximum size that the input can be.
 * @returns A new struct that will only accept values within the given size
 * range.
 */ function size(struct, minimum, maximum = minimum) {
    const expected = `Expected a ${struct.type}`;
    const of = minimum === maximum ? `of \`${minimum}\`` : `between \`${minimum}\` and \`${maximum}\``;
    return refine(struct, 'size', (value)=>{
        if (typeof value === 'number' || value instanceof Date) {
            return minimum <= value && value <= maximum || // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${expected} ${of} but received \`${value}\``;
        } else if (value instanceof Map || value instanceof Set) {
            // eslint-disable-next-line @typescript-eslint/no-shadow
            const { size } = value;
            return minimum <= size && size <= maximum || `${expected} with a size ${of} but received one with a size of \`${size}\``;
        }
        const { length } = value;
        return minimum <= length && length <= maximum || `${expected} with a length ${of} but received one with a length of \`${length}\``;
    });
}
exports.size = size;
/**
 * Augment a `Struct` to add an additional refinement to the validation.
 *
 * The refiner function is guaranteed to receive a value of the struct's type,
 * because the struct's existing validation will already have passed. This
 * allows you to layer additional validation on top of existing structs.
 *
 * @param struct - The struct to augment.
 * @param name - The name of the refinement.
 * @param refiner - The refiner function.
 * @returns A new struct that will run the refiner function after the existing
 * validation.
 */ function refine(struct, name, refiner) {
    return new struct_js_1.Struct({
        ...struct,
        *refiner (value, ctx) {
            yield* struct.refiner(value, ctx);
            const result = refiner(value, ctx);
            const failures = (0, utils_js_1.toFailures)(result, ctx, struct, value);
            for (const failure of failures){
                yield {
                    ...failure,
                    refinement: name
                };
            }
        }
    });
}
exports.refine = refine; //# sourceMappingURL=refinements.cjs.map
}),
"[project]/node_modules/@metamask/superstruct/dist/index.cjs [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@metamask/superstruct/dist/error.cjs [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@metamask/superstruct/dist/struct.cjs [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@metamask/superstruct/dist/structs/coercions.cjs [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@metamask/superstruct/dist/structs/refinements.cjs [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@metamask/superstruct/dist/structs/types.cjs [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@metamask/superstruct/dist/structs/utilities.cjs [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.cjs.map
}),
"[project]/node_modules/pony-cause/lib/error-with-cause.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ErrorWithCause",
    ()=>ErrorWithCause
]);
'use strict';
class ErrorWithCause extends Error {
    /**
   * @param {string} message
   * @param {{ cause?: T }} options
   */ constructor(message, { cause } = {}){
        super(message);
        /** @type {string} */ this.name = ErrorWithCause.name;
        if (cause) {
            /** @type {T} */ this.cause = cause;
        }
        /** @type {string} */ this.message = message;
    }
}
}),
"[project]/node_modules/pony-cause/lib/helpers.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "findCauseByReference",
    ()=>findCauseByReference,
    "getErrorCause",
    ()=>getErrorCause,
    "messageWithCauses",
    ()=>messageWithCauses,
    "stackWithCauses",
    ()=>stackWithCauses
]);
'use strict';
const findCauseByReference = (err, reference)=>{
    if (!err || !reference) return;
    if (!(err instanceof Error)) return;
    if (!(reference.prototype instanceof Error) && // @ts-ignore
    reference !== Error) return;
    /**
   * Ensures we don't go circular
   *
   * @type {Set<Error>}
   */ const seen = new Set();
    /** @type {Error|undefined} */ let currentErr = err;
    while(currentErr && !seen.has(currentErr)){
        seen.add(currentErr);
        if (currentErr instanceof reference) {
            return currentErr;
        }
        currentErr = getErrorCause(currentErr);
    }
};
const getErrorCause = (err)=>{
    if (!err || typeof err !== 'object' || !('cause' in err)) {
        return;
    }
    // VError / NError style causes
    if (typeof err.cause === 'function') {
        const causeResult = err.cause();
        return causeResult instanceof Error ? causeResult : undefined;
    } else {
        return err.cause instanceof Error ? err.cause : undefined;
    }
};
/**
 * Internal method that keeps a track of which error we have already added, to avoid circular recursion
 *
 * @private
 * @param {Error} err
 * @param {Set<Error>} seen
 * @returns {string}
 */ const _stackWithCauses = (err, seen)=>{
    if (!(err instanceof Error)) return '';
    const stack = err.stack || '';
    // Ensure we don't go circular or crazily deep
    if (seen.has(err)) {
        return stack + '\ncauses have become circular...';
    }
    const cause = getErrorCause(err);
    // TODO: Follow up in https://github.com/nodejs/node/issues/38725#issuecomment-920309092 on how to log stuff
    if (cause) {
        seen.add(err);
        return stack + '\ncaused by: ' + _stackWithCauses(cause, seen);
    } else {
        return stack;
    }
};
const stackWithCauses = (err)=>_stackWithCauses(err, new Set());
/**
 * Internal method that keeps a track of which error we have already added, to avoid circular recursion
 *
 * @private
 * @param {Error} err
 * @param {Set<Error>} seen
 * @param {boolean} [skip]
 * @returns {string}
 */ const _messageWithCauses = (err, seen, skip)=>{
    if (!(err instanceof Error)) return '';
    const message = skip ? '' : err.message || '';
    // Ensure we don't go circular or crazily deep
    if (seen.has(err)) {
        return message + ': ...';
    }
    const cause = getErrorCause(err);
    if (cause) {
        seen.add(err);
        const skipIfVErrorStyleCause = 'cause' in err && typeof err.cause === 'function';
        return message + (skipIfVErrorStyleCause ? '' : ': ') + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
    } else {
        return message;
    }
};
const messageWithCauses = (err)=>_messageWithCauses(err, new Set());
}),
"[project]/node_modules/pony-cause/index.mjs [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pony$2d$cause$2f$lib$2f$error$2d$with$2d$cause$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pony-cause/lib/error-with-cause.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pony$2d$cause$2f$lib$2f$helpers$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pony-cause/lib/helpers.mjs [app-ssr] (ecmascript)");
'use strict';
;
;
}),
"[project]/node_modules/pony-cause/lib/error-with-cause.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @template [T=undefined] */ class ErrorWithCause extends Error {
    /**
   * @param {string} message
   * @param {{ cause?: T }} options
   */ constructor(message, { cause } = {}){
        super(message);
        /** @type {string} */ this.name = ErrorWithCause.name;
        if (cause) {
            /** @type {T} */ this.cause = cause;
        }
        /** @type {string} */ this.message = message;
    }
}
module.exports = {
    ErrorWithCause
}; // linemod-remove
}),
"[project]/node_modules/pony-cause/lib/helpers.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @template {Error} T
 * @param {unknown} err
 * @param {new(...args: any[]) => T} reference
 * @returns {T|undefined}
 */ const findCauseByReference = (err, reference)=>{
    if (!err || !reference) return;
    if (!(err instanceof Error)) return;
    if (!(reference.prototype instanceof Error) && // @ts-ignore
    reference !== Error) return;
    /**
   * Ensures we don't go circular
   *
   * @type {Set<Error>}
   */ const seen = new Set();
    /** @type {Error|undefined} */ let currentErr = err;
    while(currentErr && !seen.has(currentErr)){
        seen.add(currentErr);
        if (currentErr instanceof reference) {
            return currentErr;
        }
        currentErr = getErrorCause(currentErr);
    }
};
/**
 * @param {Error|{ cause?: unknown|(()=>err)}} err
 * @returns {Error|undefined}
 */ const getErrorCause = (err)=>{
    if (!err || typeof err !== 'object' || !('cause' in err)) {
        return;
    }
    // VError / NError style causes
    if (typeof err.cause === 'function') {
        const causeResult = err.cause();
        return causeResult instanceof Error ? causeResult : undefined;
    } else {
        return err.cause instanceof Error ? err.cause : undefined;
    }
};
/**
 * Internal method that keeps a track of which error we have already added, to avoid circular recursion
 *
 * @private
 * @param {Error} err
 * @param {Set<Error>} seen
 * @returns {string}
 */ const _stackWithCauses = (err, seen)=>{
    if (!(err instanceof Error)) return '';
    const stack = err.stack || '';
    // Ensure we don't go circular or crazily deep
    if (seen.has(err)) {
        return stack + '\ncauses have become circular...';
    }
    const cause = getErrorCause(err);
    // TODO: Follow up in https://github.com/nodejs/node/issues/38725#issuecomment-920309092 on how to log stuff
    if (cause) {
        seen.add(err);
        return stack + '\ncaused by: ' + _stackWithCauses(cause, seen);
    } else {
        return stack;
    }
};
/**
 * @param {Error} err
 * @returns {string}
 */ const stackWithCauses = (err)=>_stackWithCauses(err, new Set()); // linemod-prefix-with: export
/**
 * Internal method that keeps a track of which error we have already added, to avoid circular recursion
 *
 * @private
 * @param {Error} err
 * @param {Set<Error>} seen
 * @param {boolean} [skip]
 * @returns {string}
 */ const _messageWithCauses = (err, seen, skip)=>{
    if (!(err instanceof Error)) return '';
    const message = skip ? '' : err.message || '';
    // Ensure we don't go circular or crazily deep
    if (seen.has(err)) {
        return message + ': ...';
    }
    const cause = getErrorCause(err);
    if (cause) {
        seen.add(err);
        const skipIfVErrorStyleCause = 'cause' in err && typeof err.cause === 'function';
        return message + (skipIfVErrorStyleCause ? '' : ': ') + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
    } else {
        return message;
    }
};
/**
 * @param {Error} err
 * @returns {string}
 */ const messageWithCauses = (err)=>_messageWithCauses(err, new Set()); // linemod-prefix-with: export
module.exports = {
    findCauseByReference,
    getErrorCause,
    stackWithCauses,
    messageWithCauses
}; // linemod-remove
}),
"[project]/node_modules/pony-cause/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { ErrorWithCause } = __turbopack_context__.r("[project]/node_modules/pony-cause/lib/error-with-cause.js [app-ssr] (ecmascript)"); // linemod-replace-with: export { ErrorWithCause } from './lib/error-with-cause.mjs';
const { findCauseByReference, getErrorCause, messageWithCauses, stackWithCauses } = __turbopack_context__.r("[project]/node_modules/pony-cause/lib/helpers.js [app-ssr] (ecmascript)"); // linemod-replace-with: } from './lib/helpers.mjs';
module.exports = {
    ErrorWithCause,
    findCauseByReference,
    getErrorCause,
    stackWithCauses,
    messageWithCauses
}; // linemod-remove
}),
"[project]/node_modules/semver/internal/constants.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0';
const MAX_LENGTH = 256;
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */ 9007199254740991;
// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16;
// Max safe length for a build identifier. The max length minus 6 characters for
// the shortest version with a build 0.0.0+BUILD.
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
const RELEASE_TYPES = [
    'major',
    'premajor',
    'minor',
    'preminor',
    'patch',
    'prepatch',
    'prerelease'
];
module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 0b001,
    FLAG_LOOSE: 0b010
};
}),
"[project]/node_modules/semver/internal/debug.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const debug = typeof process === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args)=>console.error('SEMVER', ...args) : ()=>{};
module.exports = debug;
}),
"[project]/node_modules/semver/internal/re.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH } = __turbopack_context__.r("[project]/node_modules/semver/internal/constants.js [app-ssr] (ecmascript)");
const debug = __turbopack_context__.r("[project]/node_modules/semver/internal/debug.js [app-ssr] (ecmascript)");
exports = module.exports = {};
// The actual regexps go on exports.re
const re = exports.re = [];
const safeRe = exports.safeRe = [];
const src = exports.src = [];
const safeSrc = exports.safeSrc = [];
const t = exports.t = {};
let R = 0;
const LETTERDASHNUMBER = '[a-zA-Z0-9-]';
// Replace some greedy regex tokens to prevent regex dos issues. These regex are
// used internally via the safeRe object since all inputs in this library get
// normalized first to trim and collapse all extra whitespace. The original
// regexes are exported for userland consumption and lower level usage. A
// future breaking change could export the safer regex only with a note that
// all input should have extra whitespace removed.
const safeRegexReplacements = [
    [
        '\\s',
        1
    ],
    [
        '\\d',
        MAX_LENGTH
    ],
    [
        LETTERDASHNUMBER,
        MAX_SAFE_BUILD_LENGTH
    ]
];
const makeSafeRegex = (value)=>{
    for (const [token, max] of safeRegexReplacements){
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
};
const createToken = (name, value, isGlobal)=>{
    const safe = makeSafeRegex(value);
    const index = R++;
    debug(name, index, value);
    t[name] = index;
    src[index] = value;
    safeSrc[index] = safe;
    re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);
};
// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.
// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.
createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
createToken('NUMERICIDENTIFIERLOOSE', '\\d+');
// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.
createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
// ## Main Version
// Three dot-separated numeric identifiers.
createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.
// Non-numberic identifiers include numberic identifiers but can be longer.
// Therefore non-numberic identifiers must go first.
createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.
createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.
createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);
// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.
createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.
// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.
createToken('FULLPLAIN', `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
createToken('FULL', `^${src[t.FULLPLAIN]}$`);
// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);
createToken('GTLT', '((?:<|>)?=?)');
// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCEPLAIN', `${'(^|[^\\d])' + '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
createToken('COERCEFULL', src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?` + `(?:${src[t.BUILD]})?` + `(?:$|[^\\d])`);
createToken('COERCERTL', src[t.COERCE], true);
createToken('COERCERTLFULL', src[t.COERCEFULL], true);
// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)');
createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
exports.tildeTrimReplace = '$1~';
createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)');
createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
exports.caretTrimReplace = '$1^';
createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
exports.comparatorTrimReplace = '$1$2$3';
// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*$`);
createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*$`);
// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*');
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$');
}),
"[project]/node_modules/semver/internal/parse-options.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// parse out just the options we care about
const looseOption = Object.freeze({
    loose: true
});
const emptyOpts = Object.freeze({});
const parseOptions = (options)=>{
    if (!options) {
        return emptyOpts;
    }
    if (typeof options !== 'object') {
        return looseOption;
    }
    return options;
};
module.exports = parseOptions;
}),
"[project]/node_modules/semver/internal/identifiers.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const numeric = /^[0-9]+$/;
const compareIdentifiers = (a, b)=>{
    if (typeof a === 'number' && typeof b === 'number') {
        return a === b ? 0 : a < b ? -1 : 1;
    }
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
        a = +a;
        b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b)=>compareIdentifiers(b, a);
module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
};
}),
"[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const debug = __turbopack_context__.r("[project]/node_modules/semver/internal/debug.js [app-ssr] (ecmascript)");
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __turbopack_context__.r("[project]/node_modules/semver/internal/constants.js [app-ssr] (ecmascript)");
const { safeRe: re, t } = __turbopack_context__.r("[project]/node_modules/semver/internal/re.js [app-ssr] (ecmascript)");
const parseOptions = __turbopack_context__.r("[project]/node_modules/semver/internal/parse-options.js [app-ssr] (ecmascript)");
const { compareIdentifiers } = __turbopack_context__.r("[project]/node_modules/semver/internal/identifiers.js [app-ssr] (ecmascript)");
class SemVer {
    constructor(version, options){
        options = parseOptions(options);
        if (version instanceof SemVer) {
            if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
                return version;
            } else {
                version = version.version;
            }
        } else if (typeof version !== 'string') {
            throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
            throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug('SemVer', version, options);
        this.options = options;
        this.loose = !!options.loose;
        // this isn't actually relevant for versions, but keep it so that we
        // don't run into trouble passing this.options around.
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
            throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        // these are actually numbers
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
            throw new TypeError('Invalid major version');
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
            throw new TypeError('Invalid minor version');
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
            throw new TypeError('Invalid patch version');
        }
        // numberify any prerelease numeric ids
        if (!m[4]) {
            this.prerelease = [];
        } else {
            this.prerelease = m[4].split('.').map((id)=>{
                if (/^[0-9]+$/.test(id)) {
                    const num = +id;
                    if (num >= 0 && num < MAX_SAFE_INTEGER) {
                        return num;
                    }
                }
                return id;
            });
        }
        this.build = m[5] ? m[5].split('.') : [];
        this.format();
    }
    format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
            this.version += `-${this.prerelease.join('.')}`;
        }
        return this.version;
    }
    toString() {
        return this.version;
    }
    compare(other) {
        debug('SemVer.compare', this.version, this.options, other);
        if (!(other instanceof SemVer)) {
            if (typeof other === 'string' && other === this.version) {
                return 0;
            }
            other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
            return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
        if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
        }
        if (this.major < other.major) {
            return -1;
        }
        if (this.major > other.major) {
            return 1;
        }
        if (this.minor < other.minor) {
            return -1;
        }
        if (this.minor > other.minor) {
            return 1;
        }
        if (this.patch < other.patch) {
            return -1;
        }
        if (this.patch > other.patch) {
            return 1;
        }
        return 0;
    }
    comparePre(other) {
        if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
        }
        // NOT having a prerelease is > having one
        if (this.prerelease.length && !other.prerelease.length) {
            return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
            return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
            return 0;
        }
        let i = 0;
        do {
            const a = this.prerelease[i];
            const b = other.prerelease[i];
            debug('prerelease compare', i, a, b);
            if (a === undefined && b === undefined) {
                return 0;
            } else if (b === undefined) {
                return 1;
            } else if (a === undefined) {
                return -1;
            } else if (a === b) {
                continue;
            } else {
                return compareIdentifiers(a, b);
            }
        }while (++i)
    }
    compareBuild(other) {
        if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
            const a = this.build[i];
            const b = other.build[i];
            debug('build compare', i, a, b);
            if (a === undefined && b === undefined) {
                return 0;
            } else if (b === undefined) {
                return 1;
            } else if (a === undefined) {
                return -1;
            } else if (a === b) {
                continue;
            } else {
                return compareIdentifiers(a, b);
            }
        }while (++i)
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(release, identifier, identifierBase) {
        if (release.startsWith('pre')) {
            if (!identifier && identifierBase === false) {
                throw new Error('invalid increment argument: identifier is empty');
            }
            // Avoid an invalid semver results
            if (identifier) {
                const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
                if (!match || match[1] !== identifier) {
                    throw new Error(`invalid identifier: ${identifier}`);
                }
            }
        }
        switch(release){
            case 'premajor':
                this.prerelease.length = 0;
                this.patch = 0;
                this.minor = 0;
                this.major++;
                this.inc('pre', identifier, identifierBase);
                break;
            case 'preminor':
                this.prerelease.length = 0;
                this.patch = 0;
                this.minor++;
                this.inc('pre', identifier, identifierBase);
                break;
            case 'prepatch':
                // If this is already a prerelease, it will bump to the next version
                // drop any prereleases that might already exist, since they are not
                // relevant at this point.
                this.prerelease.length = 0;
                this.inc('patch', identifier, identifierBase);
                this.inc('pre', identifier, identifierBase);
                break;
            // If the input is a non-prerelease version, this acts the same as
            // prepatch.
            case 'prerelease':
                if (this.prerelease.length === 0) {
                    this.inc('patch', identifier, identifierBase);
                }
                this.inc('pre', identifier, identifierBase);
                break;
            case 'release':
                if (this.prerelease.length === 0) {
                    throw new Error(`version ${this.raw} is not a prerelease`);
                }
                this.prerelease.length = 0;
                break;
            case 'major':
                // If this is a pre-major version, bump up to the same major version.
                // Otherwise increment major.
                // 1.0.0-5 bumps to 1.0.0
                // 1.1.0 bumps to 2.0.0
                if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                    this.major++;
                }
                this.minor = 0;
                this.patch = 0;
                this.prerelease = [];
                break;
            case 'minor':
                // If this is a pre-minor version, bump up to the same minor version.
                // Otherwise increment minor.
                // 1.2.0-5 bumps to 1.2.0
                // 1.2.1 bumps to 1.3.0
                if (this.patch !== 0 || this.prerelease.length === 0) {
                    this.minor++;
                }
                this.patch = 0;
                this.prerelease = [];
                break;
            case 'patch':
                // If this is not a pre-release version, it will increment the patch.
                // If it is a pre-release it will bump up to the same patch version.
                // 1.2.0-5 patches to 1.2.0
                // 1.2.0 patches to 1.2.1
                if (this.prerelease.length === 0) {
                    this.patch++;
                }
                this.prerelease = [];
                break;
            // This probably shouldn't be used publicly.
            // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
            case 'pre':
                {
                    const base = Number(identifierBase) ? 1 : 0;
                    if (this.prerelease.length === 0) {
                        this.prerelease = [
                            base
                        ];
                    } else {
                        let i = this.prerelease.length;
                        while(--i >= 0){
                            if (typeof this.prerelease[i] === 'number') {
                                this.prerelease[i]++;
                                i = -2;
                            }
                        }
                        if (i === -1) {
                            // didn't increment anything
                            if (identifier === this.prerelease.join('.') && identifierBase === false) {
                                throw new Error('invalid increment argument: identifier already exists');
                            }
                            this.prerelease.push(base);
                        }
                    }
                    if (identifier) {
                        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
                        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
                        let prerelease = [
                            identifier,
                            base
                        ];
                        if (identifierBase === false) {
                            prerelease = [
                                identifier
                            ];
                        }
                        if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                            if (isNaN(this.prerelease[1])) {
                                this.prerelease = prerelease;
                            }
                        } else {
                            this.prerelease = prerelease;
                        }
                    }
                    break;
                }
            default:
                throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
            this.raw += `+${this.build.join('.')}`;
        }
        return this;
    }
}
module.exports = SemVer;
}),
"[project]/node_modules/semver/functions/parse.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const parse = (version, options, throwErrors = false)=>{
    if (version instanceof SemVer) {
        return version;
    }
    try {
        return new SemVer(version, options);
    } catch (er) {
        if (!throwErrors) {
            return null;
        }
        throw er;
    }
};
module.exports = parse;
}),
"[project]/node_modules/semver/functions/valid.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const parse = __turbopack_context__.r("[project]/node_modules/semver/functions/parse.js [app-ssr] (ecmascript)");
const valid = (version, options)=>{
    const v = parse(version, options);
    return v ? v.version : null;
};
module.exports = valid;
}),
"[project]/node_modules/semver/functions/clean.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const parse = __turbopack_context__.r("[project]/node_modules/semver/functions/parse.js [app-ssr] (ecmascript)");
const clean = (version, options)=>{
    const s = parse(version.trim().replace(/^[=v]+/, ''), options);
    return s ? s.version : null;
};
module.exports = clean;
}),
"[project]/node_modules/semver/functions/inc.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const inc = (version, release, options, identifier, identifierBase)=>{
    if (typeof options === 'string') {
        identifierBase = identifier;
        identifier = options;
        options = undefined;
    }
    try {
        return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
    } catch (er) {
        return null;
    }
};
module.exports = inc;
}),
"[project]/node_modules/semver/functions/diff.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const parse = __turbopack_context__.r("[project]/node_modules/semver/functions/parse.js [app-ssr] (ecmascript)");
const diff = (version1, version2)=>{
    const v1 = parse(version1, null, true);
    const v2 = parse(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
        return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
        // Going from prerelease -> no prerelease requires some special casing
        // If the low version has only a major, then it will always be a major
        // Some examples:
        // 1.0.0-1 -> 1.0.0
        // 1.0.0-1 -> 1.1.1
        // 1.0.0-1 -> 2.0.0
        if (!lowVersion.patch && !lowVersion.minor) {
            return 'major';
        }
        // If the main part has no difference
        if (lowVersion.compareMain(highVersion) === 0) {
            if (lowVersion.minor && !lowVersion.patch) {
                return 'minor';
            }
            return 'patch';
        }
    }
    // add the `pre` prefix if we are going to a prerelease version
    const prefix = highHasPre ? 'pre' : '';
    if (v1.major !== v2.major) {
        return prefix + 'major';
    }
    if (v1.minor !== v2.minor) {
        return prefix + 'minor';
    }
    if (v1.patch !== v2.patch) {
        return prefix + 'patch';
    }
    // high and low are preleases
    return 'prerelease';
};
module.exports = diff;
}),
"[project]/node_modules/semver/functions/major.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const major = (a, loose)=>new SemVer(a, loose).major;
module.exports = major;
}),
"[project]/node_modules/semver/functions/minor.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const minor = (a, loose)=>new SemVer(a, loose).minor;
module.exports = minor;
}),
"[project]/node_modules/semver/functions/patch.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const patch = (a, loose)=>new SemVer(a, loose).patch;
module.exports = patch;
}),
"[project]/node_modules/semver/functions/prerelease.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const parse = __turbopack_context__.r("[project]/node_modules/semver/functions/parse.js [app-ssr] (ecmascript)");
const prerelease = (version, options)=>{
    const parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
module.exports = prerelease;
}),
"[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const compare = (a, b, loose)=>new SemVer(a, loose).compare(new SemVer(b, loose));
module.exports = compare;
}),
"[project]/node_modules/semver/functions/rcompare.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)");
const rcompare = (a, b, loose)=>compare(b, a, loose);
module.exports = rcompare;
}),
"[project]/node_modules/semver/functions/compare-loose.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)");
const compareLoose = (a, b)=>compare(a, b, true);
module.exports = compareLoose;
}),
"[project]/node_modules/semver/functions/compare-build.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const compareBuild = (a, b, loose)=>{
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
module.exports = compareBuild;
}),
"[project]/node_modules/semver/functions/sort.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compareBuild = __turbopack_context__.r("[project]/node_modules/semver/functions/compare-build.js [app-ssr] (ecmascript)");
const sort = (list, loose)=>list.sort((a, b)=>compareBuild(a, b, loose));
module.exports = sort;
}),
"[project]/node_modules/semver/functions/rsort.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compareBuild = __turbopack_context__.r("[project]/node_modules/semver/functions/compare-build.js [app-ssr] (ecmascript)");
const rsort = (list, loose)=>list.sort((a, b)=>compareBuild(b, a, loose));
module.exports = rsort;
}),
"[project]/node_modules/semver/functions/gt.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)");
const gt = (a, b, loose)=>compare(a, b, loose) > 0;
module.exports = gt;
}),
"[project]/node_modules/semver/functions/lt.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)");
const lt = (a, b, loose)=>compare(a, b, loose) < 0;
module.exports = lt;
}),
"[project]/node_modules/semver/functions/eq.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)");
const eq = (a, b, loose)=>compare(a, b, loose) === 0;
module.exports = eq;
}),
"[project]/node_modules/semver/functions/neq.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)");
const neq = (a, b, loose)=>compare(a, b, loose) !== 0;
module.exports = neq;
}),
"[project]/node_modules/semver/functions/gte.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)");
const gte = (a, b, loose)=>compare(a, b, loose) >= 0;
module.exports = gte;
}),
"[project]/node_modules/semver/functions/lte.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)");
const lte = (a, b, loose)=>compare(a, b, loose) <= 0;
module.exports = lte;
}),
"[project]/node_modules/semver/functions/cmp.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const eq = __turbopack_context__.r("[project]/node_modules/semver/functions/eq.js [app-ssr] (ecmascript)");
const neq = __turbopack_context__.r("[project]/node_modules/semver/functions/neq.js [app-ssr] (ecmascript)");
const gt = __turbopack_context__.r("[project]/node_modules/semver/functions/gt.js [app-ssr] (ecmascript)");
const gte = __turbopack_context__.r("[project]/node_modules/semver/functions/gte.js [app-ssr] (ecmascript)");
const lt = __turbopack_context__.r("[project]/node_modules/semver/functions/lt.js [app-ssr] (ecmascript)");
const lte = __turbopack_context__.r("[project]/node_modules/semver/functions/lte.js [app-ssr] (ecmascript)");
const cmp = (a, op, b, loose)=>{
    switch(op){
        case '===':
            if (typeof a === 'object') {
                a = a.version;
            }
            if (typeof b === 'object') {
                b = b.version;
            }
            return a === b;
        case '!==':
            if (typeof a === 'object') {
                a = a.version;
            }
            if (typeof b === 'object') {
                b = b.version;
            }
            return a !== b;
        case '':
        case '=':
        case '==':
            return eq(a, b, loose);
        case '!=':
            return neq(a, b, loose);
        case '>':
            return gt(a, b, loose);
        case '>=':
            return gte(a, b, loose);
        case '<':
            return lt(a, b, loose);
        case '<=':
            return lte(a, b, loose);
        default:
            throw new TypeError(`Invalid operator: ${op}`);
    }
};
module.exports = cmp;
}),
"[project]/node_modules/semver/functions/coerce.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const parse = __turbopack_context__.r("[project]/node_modules/semver/functions/parse.js [app-ssr] (ecmascript)");
const { safeRe: re, t } = __turbopack_context__.r("[project]/node_modules/semver/internal/re.js [app-ssr] (ecmascript)");
const coerce = (version, options)=>{
    if (version instanceof SemVer) {
        return version;
    }
    if (typeof version === 'number') {
        version = String(version);
    }
    if (typeof version !== 'string') {
        return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
        match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
    } else {
        // Find the right-most coercible string that does not share
        // a terminus with a more left-ward coercible string.
        // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
        // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'
        //
        // Walk through the string checking with a /g regexp
        // Manually set the index so as to pick up overlapping matches.
        // Stop when we get a match that ends at the string end, since no
        // coercible string can be more right-ward without the same terminus.
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)){
            if (!match || next.index + next[0].length !== match.index + match[0].length) {
                match = next;
            }
            coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        // leave it in a clean state
        coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
        return null;
    }
    const major = match[2];
    const minor = match[3] || '0';
    const patch = match[4] || '0';
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : '';
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : '';
    return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
};
module.exports = coerce;
}),
"[project]/node_modules/semver/internal/lrucache.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

class LRUCache {
    constructor(){
        this.max = 1000;
        this.map = new Map();
    }
    get(key) {
        const value = this.map.get(key);
        if (value === undefined) {
            return undefined;
        } else {
            // Remove the key from the map and add it to the end
            this.map.delete(key);
            this.map.set(key, value);
            return value;
        }
    }
    delete(key) {
        return this.map.delete(key);
    }
    set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== undefined) {
            // If cache is full, delete the least recently used item
            if (this.map.size >= this.max) {
                const firstKey = this.map.keys().next().value;
                this.delete(firstKey);
            }
            this.map.set(key, value);
        }
        return this;
    }
}
module.exports = LRUCache;
}),
"[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SPACE_CHARACTERS = /\s+/g;
// hoisted class for cyclic dependency
class Range {
    constructor(range, options){
        options = parseOptions(options);
        if (range instanceof Range) {
            if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
                return range;
            } else {
                return new Range(range.raw, options);
            }
        }
        if (range instanceof Comparator) {
            // just put it in the set and return
            this.raw = range.value;
            this.set = [
                [
                    range
                ]
            ];
            this.formatted = undefined;
            return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        // First reduce all whitespace as much as possible so we do not have to rely
        // on potentially slow regexes like \s*. This is then stored and used for
        // future error messages as well.
        this.raw = range.trim().replace(SPACE_CHARACTERS, ' ');
        // First, split on ||
        this.set = this.raw.split('||')// map the range to a 2d array of comparators
        .map((r)=>this.parseRange(r.trim()))// throw out any comparator lists that are empty
        // this generally means that it was not a valid range, which is allowed
        // in loose mode, but will still throw if the WHOLE range is invalid.
        .filter((c)=>c.length);
        if (!this.set.length) {
            throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        // if we have any that are not the null set, throw out null sets.
        if (this.set.length > 1) {
            // keep the first one, in case they're all null sets
            const first = this.set[0];
            this.set = this.set.filter((c)=>!isNullSet(c[0]));
            if (this.set.length === 0) {
                this.set = [
                    first
                ];
            } else if (this.set.length > 1) {
                // if we have any that are *, then the range is just *
                for (const c of this.set){
                    if (c.length === 1 && isAny(c[0])) {
                        this.set = [
                            c
                        ];
                        break;
                    }
                }
            }
        }
        this.formatted = undefined;
    }
    get range() {
        if (this.formatted === undefined) {
            this.formatted = '';
            for(let i = 0; i < this.set.length; i++){
                if (i > 0) {
                    this.formatted += '||';
                }
                const comps = this.set[i];
                for(let k = 0; k < comps.length; k++){
                    if (k > 0) {
                        this.formatted += ' ';
                    }
                    this.formatted += comps[k].toString().trim();
                }
            }
        }
        return this.formatted;
    }
    format() {
        return this.range;
    }
    toString() {
        return this.range;
    }
    parseRange(range) {
        // memoize range parsing for performance.
        // this is a very hot path, and fully deterministic.
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ':' + range;
        const cached = cache.get(memoKey);
        if (cached) {
            return cached;
        }
        const loose = this.options.loose;
        // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug('hyphen replace', range);
        // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug('comparator trim', range);
        // `~ 1.2.3` => `~1.2.3`
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug('tilde trim', range);
        // `^ 1.2.3` => `^1.2.3`
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug('caret trim', range);
        // At this point, the range is completely trimmed and
        // ready to be split into comparators.
        let rangeList = range.split(' ').map((comp)=>parseComparator(comp, this.options)).join(' ').split(/\s+/)// >=0.0.0 is equivalent to *
        .map((comp)=>replaceGTE0(comp, this.options));
        if (loose) {
            // in loose mode, throw out any that are not valid comparators
            rangeList = rangeList.filter((comp)=>{
                debug('loose invalid filter', comp, this.options);
                return !!comp.match(re[t.COMPARATORLOOSE]);
            });
        }
        debug('range list', rangeList);
        // if any comparators are the null set, then replace with JUST null set
        // if more than one comparator, remove any * comparators
        // also, don't include the same comparator more than once
        const rangeMap = new Map();
        const comparators = rangeList.map((comp)=>new Comparator(comp, this.options));
        for (const comp of comparators){
            if (isNullSet(comp)) {
                return [
                    comp
                ];
            }
            rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has('')) {
            rangeMap.delete('');
        }
        const result = [
            ...rangeMap.values()
        ];
        cache.set(memoKey, result);
        return result;
    }
    intersects(range, options) {
        if (!(range instanceof Range)) {
            throw new TypeError('a Range is required');
        }
        return this.set.some((thisComparators)=>{
            return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators)=>{
                return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator)=>{
                    return rangeComparators.every((rangeComparator)=>{
                        return thisComparator.intersects(rangeComparator, options);
                    });
                });
            });
        });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version) {
        if (!version) {
            return false;
        }
        if (typeof version === 'string') {
            try {
                version = new SemVer(version, this.options);
            } catch (er) {
                return false;
            }
        }
        for(let i = 0; i < this.set.length; i++){
            if (testSet(this.set[i], version, this.options)) {
                return true;
            }
        }
        return false;
    }
}
module.exports = Range;
const LRU = __turbopack_context__.r("[project]/node_modules/semver/internal/lrucache.js [app-ssr] (ecmascript)");
const cache = new LRU();
const parseOptions = __turbopack_context__.r("[project]/node_modules/semver/internal/parse-options.js [app-ssr] (ecmascript)");
const Comparator = __turbopack_context__.r("[project]/node_modules/semver/classes/comparator.js [app-ssr] (ecmascript)");
const debug = __turbopack_context__.r("[project]/node_modules/semver/internal/debug.js [app-ssr] (ecmascript)");
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const { safeRe: re, t, comparatorTrimReplace, tildeTrimReplace, caretTrimReplace } = __turbopack_context__.r("[project]/node_modules/semver/internal/re.js [app-ssr] (ecmascript)");
const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = __turbopack_context__.r("[project]/node_modules/semver/internal/constants.js [app-ssr] (ecmascript)");
const isNullSet = (c)=>c.value === '<0.0.0-0';
const isAny = (c)=>c.value === '';
// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options)=>{
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while(result && remainingComparators.length){
        result = remainingComparators.every((otherComparator)=>{
            return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
    }
    return result;
};
// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options)=>{
    comp = comp.replace(re[t.BUILD], '');
    debug('comp', comp, options);
    comp = replaceCarets(comp, options);
    debug('caret', comp);
    comp = replaceTildes(comp, options);
    debug('tildes', comp);
    comp = replaceXRanges(comp, options);
    debug('xrange', comp);
    comp = replaceStars(comp, options);
    debug('stars', comp);
    return comp;
};
const isX = (id)=>!id || id.toLowerCase() === 'x' || id === '*';
// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
// ~0.0.1 --> >=0.0.1 <0.1.0-0
const replaceTildes = (comp, options)=>{
    return comp.trim().split(/\s+/).map((c)=>replaceTilde(c, options)).join(' ');
};
const replaceTilde = (comp, options)=>{
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr)=>{
        debug('tilde', comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
            ret = '';
        } else if (isX(m)) {
            ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
            // ~1.2 == >=1.2.0 <1.3.0-0
            ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
            debug('replaceTilde pr', pr);
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
            // ~1.2.3 == >=1.2.3 <1.3.0-0
            ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug('tilde return', ret);
        return ret;
    });
};
// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
// ^0.0.1 --> >=0.0.1 <0.0.2-0
// ^0.1.0 --> >=0.1.0 <0.2.0-0
const replaceCarets = (comp, options)=>{
    return comp.trim().split(/\s+/).map((c)=>replaceCaret(c, options)).join(' ');
};
const replaceCaret = (comp, options)=>{
    debug('caret', comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z = options.includePrerelease ? '-0' : '';
    return comp.replace(r, (_, M, m, p, pr)=>{
        debug('caret', comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
            ret = '';
        } else if (isX(m)) {
            ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
            if (M === '0') {
                ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
            } else {
                ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
            }
        } else if (pr) {
            debug('replaceCaret pr', pr);
            if (M === '0') {
                if (m === '0') {
                    ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
                } else {
                    ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
                }
            } else {
                ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
            }
        } else {
            debug('no pr');
            if (M === '0') {
                if (m === '0') {
                    ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
                } else {
                    ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
                }
            } else {
                ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
            }
        }
        debug('caret return', ret);
        return ret;
    });
};
const replaceXRanges = (comp, options)=>{
    debug('replaceXRanges', comp, options);
    return comp.split(/\s+/).map((c)=>replaceXRange(c, options)).join(' ');
};
const replaceXRange = (comp, options)=>{
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr)=>{
        debug('xRange', comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === '=' && anyX) {
            gtlt = '';
        }
        // if we're including prereleases in the match, then we need
        // to fix this to -0, the lowest possible prerelease value
        pr = options.includePrerelease ? '-0' : '';
        if (xM) {
            if (gtlt === '>' || gtlt === '<') {
                // nothing is allowed
                ret = '<0.0.0-0';
            } else {
                // nothing is forbidden
                ret = '*';
            }
        } else if (gtlt && anyX) {
            // we know patch is an x, because we have any x at all.
            // replace X with 0
            if (xm) {
                m = 0;
            }
            p = 0;
            if (gtlt === '>') {
                // >1 => >=2.0.0
                // >1.2 => >=1.3.0
                gtlt = '>=';
                if (xm) {
                    M = +M + 1;
                    m = 0;
                    p = 0;
                } else {
                    m = +m + 1;
                    p = 0;
                }
            } else if (gtlt === '<=') {
                // <=0.7.x is actually <0.8.0, since any 0.7.x should
                // pass.  Similarly, <=7.x is actually <8.0.0, etc.
                gtlt = '<';
                if (xm) {
                    M = +M + 1;
                } else {
                    m = +m + 1;
                }
            }
            if (gtlt === '<') {
                pr = '-0';
            }
            ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
            ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
            ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug('xRange return', ret);
        return ret;
    });
};
// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options)=>{
    debug('replaceStars', comp, options);
    // Looseness is ignored here.  star is always as loose as it gets!
    return comp.trim().replace(re[t.STAR], '');
};
const replaceGTE0 = (comp, options)=>{
    debug('replaceGTE0', comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '');
};
// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
// TODO build?
const hyphenReplace = (incPr)=>($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr)=>{
        if (isX(fM)) {
            from = '';
        } else if (isX(fm)) {
            from = `>=${fM}.0.0${incPr ? '-0' : ''}`;
        } else if (isX(fp)) {
            from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;
        } else if (fpr) {
            from = `>=${from}`;
        } else {
            from = `>=${from}${incPr ? '-0' : ''}`;
        }
        if (isX(tM)) {
            to = '';
        } else if (isX(tm)) {
            to = `<${+tM + 1}.0.0-0`;
        } else if (isX(tp)) {
            to = `<${tM}.${+tm + 1}.0-0`;
        } else if (tpr) {
            to = `<=${tM}.${tm}.${tp}-${tpr}`;
        } else if (incPr) {
            to = `<${tM}.${tm}.${+tp + 1}-0`;
        } else {
            to = `<=${to}`;
        }
        return `${from} ${to}`.trim();
    };
const testSet = (set, version, options)=>{
    for(let i = 0; i < set.length; i++){
        if (!set[i].test(version)) {
            return false;
        }
    }
    if (version.prerelease.length && !options.includePrerelease) {
        // Find the set of versions that are allowed to have prereleases
        // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
        // That should allow `1.2.3-pr.2` to pass.
        // However, `1.2.4-alpha.notready` should NOT be allowed,
        // even though it's within the range set by the comparators.
        for(let i = 0; i < set.length; i++){
            debug(set[i].semver);
            if (set[i].semver === Comparator.ANY) {
                continue;
            }
            if (set[i].semver.prerelease.length > 0) {
                const allowed = set[i].semver;
                if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
                    return true;
                }
            }
        }
        // Version has a -pre, but it's not one of the ones we like.
        return false;
    }
    return true;
};
}),
"[project]/node_modules/semver/classes/comparator.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const ANY = Symbol('SemVer ANY');
// hoisted class for cyclic dependency
class Comparator {
    static get ANY() {
        return ANY;
    }
    constructor(comp, options){
        options = parseOptions(options);
        if (comp instanceof Comparator) {
            if (comp.loose === !!options.loose) {
                return comp;
            } else {
                comp = comp.value;
            }
        }
        comp = comp.trim().split(/\s+/).join(' ');
        debug('comparator', comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
            this.value = '';
        } else {
            this.value = this.operator + this.semver.version;
        }
        debug('comp', this);
    }
    parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
            throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== undefined ? m[1] : '';
        if (this.operator === '=') {
            this.operator = '';
        }
        // if it literally is just '>' or '' then allow anything.
        if (!m[2]) {
            this.semver = ANY;
        } else {
            this.semver = new SemVer(m[2], this.options.loose);
        }
    }
    toString() {
        return this.value;
    }
    test(version) {
        debug('Comparator.test', version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
            return true;
        }
        if (typeof version === 'string') {
            try {
                version = new SemVer(version, this.options);
            } catch (er) {
                return false;
            }
        }
        return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
            throw new TypeError('a Comparator is required');
        }
        if (this.operator === '') {
            if (this.value === '') {
                return true;
            }
            return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === '') {
            if (comp.value === '') {
                return true;
            }
            return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        // Special cases where nothing can possibly be lower
        if (options.includePrerelease && (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
            return false;
        }
        if (!options.includePrerelease && (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
            return false;
        }
        // Same direction increasing (> or >=)
        if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
            return true;
        }
        // Same direction decreasing (< or <=)
        if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
            return true;
        }
        // same SemVer and both sides are inclusive (<= or >=)
        if (this.semver.version === comp.semver.version && this.operator.includes('=') && comp.operator.includes('=')) {
            return true;
        }
        // opposite directions less than
        if (cmp(this.semver, '<', comp.semver, options) && this.operator.startsWith('>') && comp.operator.startsWith('<')) {
            return true;
        }
        // opposite directions greater than
        if (cmp(this.semver, '>', comp.semver, options) && this.operator.startsWith('<') && comp.operator.startsWith('>')) {
            return true;
        }
        return false;
    }
}
module.exports = Comparator;
const parseOptions = __turbopack_context__.r("[project]/node_modules/semver/internal/parse-options.js [app-ssr] (ecmascript)");
const { safeRe: re, t } = __turbopack_context__.r("[project]/node_modules/semver/internal/re.js [app-ssr] (ecmascript)");
const cmp = __turbopack_context__.r("[project]/node_modules/semver/functions/cmp.js [app-ssr] (ecmascript)");
const debug = __turbopack_context__.r("[project]/node_modules/semver/internal/debug.js [app-ssr] (ecmascript)");
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/semver/functions/satisfies.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)");
const satisfies = (version, range, options)=>{
    try {
        range = new Range(range, options);
    } catch (er) {
        return false;
    }
    return range.test(version);
};
module.exports = satisfies;
}),
"[project]/node_modules/semver/ranges/to-comparators.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)");
// Mostly just for testing and legacy API reasons
const toComparators = (range, options)=>new Range(range, options).set.map((comp)=>comp.map((c)=>c.value).join(' ').trim().split(' '));
module.exports = toComparators;
}),
"[project]/node_modules/semver/ranges/max-satisfying.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)");
const maxSatisfying = (versions, range, options)=>{
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
        rangeObj = new Range(range, options);
    } catch (er) {
        return null;
    }
    versions.forEach((v)=>{
        if (rangeObj.test(v)) {
            // satisfies(v, range, options)
            if (!max || maxSV.compare(v) === -1) {
                // compare(max, v, true)
                max = v;
                maxSV = new SemVer(max, options);
            }
        }
    });
    return max;
};
module.exports = maxSatisfying;
}),
"[project]/node_modules/semver/ranges/min-satisfying.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)");
const minSatisfying = (versions, range, options)=>{
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
        rangeObj = new Range(range, options);
    } catch (er) {
        return null;
    }
    versions.forEach((v)=>{
        if (rangeObj.test(v)) {
            // satisfies(v, range, options)
            if (!min || minSV.compare(v) === 1) {
                // compare(min, v, true)
                min = v;
                minSV = new SemVer(min, options);
            }
        }
    });
    return min;
};
module.exports = minSatisfying;
}),
"[project]/node_modules/semver/ranges/min-version.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)");
const gt = __turbopack_context__.r("[project]/node_modules/semver/functions/gt.js [app-ssr] (ecmascript)");
const minVersion = (range, loose)=>{
    range = new Range(range, loose);
    let minver = new SemVer('0.0.0');
    if (range.test(minver)) {
        return minver;
    }
    minver = new SemVer('0.0.0-0');
    if (range.test(minver)) {
        return minver;
    }
    minver = null;
    for(let i = 0; i < range.set.length; ++i){
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator)=>{
            // Clone to avoid manipulating the comparator's semver object.
            const compver = new SemVer(comparator.semver.version);
            switch(comparator.operator){
                case '>':
                    if (compver.prerelease.length === 0) {
                        compver.patch++;
                    } else {
                        compver.prerelease.push(0);
                    }
                    compver.raw = compver.format();
                /* fallthrough */ case '':
                case '>=':
                    if (!setMin || gt(compver, setMin)) {
                        setMin = compver;
                    }
                    break;
                case '<':
                case '<=':
                    break;
                /* istanbul ignore next */ default:
                    throw new Error(`Unexpected operation: ${comparator.operator}`);
            }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
            minver = setMin;
        }
    }
    if (minver && range.test(minver)) {
        return minver;
    }
    return null;
};
module.exports = minVersion;
}),
"[project]/node_modules/semver/ranges/valid.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)");
const validRange = (range, options)=>{
    try {
        // Return '*' instead of '' so that truthiness works.
        // This will throw if it's invalid anyway
        return new Range(range, options).range || '*';
    } catch (er) {
        return null;
    }
};
module.exports = validRange;
}),
"[project]/node_modules/semver/ranges/outside.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const Comparator = __turbopack_context__.r("[project]/node_modules/semver/classes/comparator.js [app-ssr] (ecmascript)");
const { ANY } = Comparator;
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)");
const satisfies = __turbopack_context__.r("[project]/node_modules/semver/functions/satisfies.js [app-ssr] (ecmascript)");
const gt = __turbopack_context__.r("[project]/node_modules/semver/functions/gt.js [app-ssr] (ecmascript)");
const lt = __turbopack_context__.r("[project]/node_modules/semver/functions/lt.js [app-ssr] (ecmascript)");
const lte = __turbopack_context__.r("[project]/node_modules/semver/functions/lte.js [app-ssr] (ecmascript)");
const gte = __turbopack_context__.r("[project]/node_modules/semver/functions/gte.js [app-ssr] (ecmascript)");
const outside = (version, range, hilo, options)=>{
    version = new SemVer(version, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch(hilo){
        case '>':
            gtfn = gt;
            ltefn = lte;
            ltfn = lt;
            comp = '>';
            ecomp = '>=';
            break;
        case '<':
            gtfn = lt;
            ltefn = gte;
            ltfn = gt;
            comp = '<';
            ecomp = '<=';
            break;
        default:
            throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    // If it satisfies the range it is not outside
    if (satisfies(version, range, options)) {
        return false;
    }
    // From now on, variable terms are as if we're in "gtr" mode.
    // but note that everything is flipped for the "ltr" function.
    for(let i = 0; i < range.set.length; ++i){
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator)=>{
            if (comparator.semver === ANY) {
                comparator = new Comparator('>=0.0.0');
            }
            high = high || comparator;
            low = low || comparator;
            if (gtfn(comparator.semver, high.semver, options)) {
                high = comparator;
            } else if (ltfn(comparator.semver, low.semver, options)) {
                low = comparator;
            }
        });
        // If the edge version comparator has a operator then our version
        // isn't outside it
        if (high.operator === comp || high.operator === ecomp) {
            return false;
        }
        // If the lowest version comparator has an operator and our version
        // is less than it then it isn't higher than the range
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
            return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
            return false;
        }
    }
    return true;
};
module.exports = outside;
}),
"[project]/node_modules/semver/ranges/gtr.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Determine if version is greater than all the versions possible in the range.
const outside = __turbopack_context__.r("[project]/node_modules/semver/ranges/outside.js [app-ssr] (ecmascript)");
const gtr = (version, range, options)=>outside(version, range, '>', options);
module.exports = gtr;
}),
"[project]/node_modules/semver/ranges/ltr.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const outside = __turbopack_context__.r("[project]/node_modules/semver/ranges/outside.js [app-ssr] (ecmascript)");
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options)=>outside(version, range, '<', options);
module.exports = ltr;
}),
"[project]/node_modules/semver/ranges/intersects.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)");
const intersects = (r1, r2, options)=>{
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
};
module.exports = intersects;
}),
"[project]/node_modules/semver/ranges/simplify.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = __turbopack_context__.r("[project]/node_modules/semver/functions/satisfies.js [app-ssr] (ecmascript)");
const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)");
module.exports = (versions, range, options)=>{
    const set = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b)=>compare(a, b, options));
    for (const version of v){
        const included = satisfies(version, range, options);
        if (included) {
            prev = version;
            if (!first) {
                first = version;
            }
        } else {
            if (prev) {
                set.push([
                    first,
                    prev
                ]);
            }
            prev = null;
            first = null;
        }
    }
    if (first) {
        set.push([
            first,
            null
        ]);
    }
    const ranges = [];
    for (const [min, max] of set){
        if (min === max) {
            ranges.push(min);
        } else if (!max && min === v[0]) {
            ranges.push('*');
        } else if (!max) {
            ranges.push(`>=${min}`);
        } else if (min === v[0]) {
            ranges.push(`<=${max}`);
        } else {
            ranges.push(`${min} - ${max}`);
        }
    }
    const simplified = ranges.join(' || ');
    const original = typeof range.raw === 'string' ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
};
}),
"[project]/node_modules/semver/ranges/subset.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)");
const Comparator = __turbopack_context__.r("[project]/node_modules/semver/classes/comparator.js [app-ssr] (ecmascript)");
const { ANY } = Comparator;
const satisfies = __turbopack_context__.r("[project]/node_modules/semver/functions/satisfies.js [app-ssr] (ecmascript)");
const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)");
// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true
const subset = (sub, dom, options = {})=>{
    if (sub === dom) {
        return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER: for (const simpleSub of sub.set){
        for (const simpleDom of dom.set){
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
                continue OUTER;
            }
        }
        // the null set is a subset of everything, but null simple ranges in
        // a complex range should be ignored.  so if we saw a non-null range,
        // then we know this isn't a subset, but if EVERY simple range was null,
        // then it is a subset.
        if (sawNonNull) {
            return false;
        }
    }
    return true;
};
const minimumVersionWithPreRelease = [
    new Comparator('>=0.0.0-0')
];
const minimumVersion = [
    new Comparator('>=0.0.0')
];
const simpleSubset = (sub, dom, options)=>{
    if (sub === dom) {
        return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
            return true;
        } else if (options.includePrerelease) {
            sub = minimumVersionWithPreRelease;
        } else {
            sub = minimumVersion;
        }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
            return true;
        } else {
            dom = minimumVersion;
        }
    }
    const eqSet = new Set();
    let gt, lt;
    for (const c of sub){
        if (c.operator === '>' || c.operator === '>=') {
            gt = higherGT(gt, c, options);
        } else if (c.operator === '<' || c.operator === '<=') {
            lt = lowerLT(lt, c, options);
        } else {
            eqSet.add(c.semver);
        }
    }
    if (eqSet.size > 1) {
        return null;
    }
    let gtltComp;
    if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
            return null;
        } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
            return null;
        }
    }
    // will iterate one or zero times
    for (const eq of eqSet){
        if (gt && !satisfies(eq, String(gt), options)) {
            return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
            return null;
        }
        for (const c of dom){
            if (!satisfies(eq, String(c), options)) {
                return false;
            }
        }
        return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    // if the subset has a prerelease, we need a comparator in the superset
    // with the same tuple and a prerelease, or it's not a subset
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    // exception: <1.2.3-0 is the same as <1.2.3
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
    }
    for (const c of dom){
        hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';
        hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';
        if (gt) {
            if (needDomGTPre) {
                if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
                    needDomGTPre = false;
                }
            }
            if (c.operator === '>' || c.operator === '>=') {
                higher = higherGT(gt, c, options);
                if (higher === c && higher !== gt) {
                    return false;
                }
            } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
                return false;
            }
        }
        if (lt) {
            if (needDomLTPre) {
                if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
                    needDomLTPre = false;
                }
            }
            if (c.operator === '<' || c.operator === '<=') {
                lower = lowerLT(lt, c, options);
                if (lower === c && lower !== lt) {
                    return false;
                }
            } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
                return false;
            }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
            return false;
        }
    }
    // if there was a < or >, and nothing in the dom, then must be false
    // UNLESS it was limited by another range in the other direction.
    // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
    }
    // we needed a prerelease range in a specific tuple, but didn't get one
    // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
    // because it includes prereleases in the 1.2.3 tuple
    if (needDomGTPre || needDomLTPre) {
        return false;
    }
    return true;
};
// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options)=>{
    if (!a) {
        return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === '>' && a.operator === '>=' ? b : a;
};
// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options)=>{
    if (!a) {
        return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === '<' && a.operator === '<=' ? b : a;
};
module.exports = subset;
}),
"[project]/node_modules/semver/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// just pre-load all the stuff that index.js lazily exports
const internalRe = __turbopack_context__.r("[project]/node_modules/semver/internal/re.js [app-ssr] (ecmascript)");
const constants = __turbopack_context__.r("[project]/node_modules/semver/internal/constants.js [app-ssr] (ecmascript)");
const SemVer = __turbopack_context__.r("[project]/node_modules/semver/classes/semver.js [app-ssr] (ecmascript)");
const identifiers = __turbopack_context__.r("[project]/node_modules/semver/internal/identifiers.js [app-ssr] (ecmascript)");
const parse = __turbopack_context__.r("[project]/node_modules/semver/functions/parse.js [app-ssr] (ecmascript)");
const valid = __turbopack_context__.r("[project]/node_modules/semver/functions/valid.js [app-ssr] (ecmascript)");
const clean = __turbopack_context__.r("[project]/node_modules/semver/functions/clean.js [app-ssr] (ecmascript)");
const inc = __turbopack_context__.r("[project]/node_modules/semver/functions/inc.js [app-ssr] (ecmascript)");
const diff = __turbopack_context__.r("[project]/node_modules/semver/functions/diff.js [app-ssr] (ecmascript)");
const major = __turbopack_context__.r("[project]/node_modules/semver/functions/major.js [app-ssr] (ecmascript)");
const minor = __turbopack_context__.r("[project]/node_modules/semver/functions/minor.js [app-ssr] (ecmascript)");
const patch = __turbopack_context__.r("[project]/node_modules/semver/functions/patch.js [app-ssr] (ecmascript)");
const prerelease = __turbopack_context__.r("[project]/node_modules/semver/functions/prerelease.js [app-ssr] (ecmascript)");
const compare = __turbopack_context__.r("[project]/node_modules/semver/functions/compare.js [app-ssr] (ecmascript)");
const rcompare = __turbopack_context__.r("[project]/node_modules/semver/functions/rcompare.js [app-ssr] (ecmascript)");
const compareLoose = __turbopack_context__.r("[project]/node_modules/semver/functions/compare-loose.js [app-ssr] (ecmascript)");
const compareBuild = __turbopack_context__.r("[project]/node_modules/semver/functions/compare-build.js [app-ssr] (ecmascript)");
const sort = __turbopack_context__.r("[project]/node_modules/semver/functions/sort.js [app-ssr] (ecmascript)");
const rsort = __turbopack_context__.r("[project]/node_modules/semver/functions/rsort.js [app-ssr] (ecmascript)");
const gt = __turbopack_context__.r("[project]/node_modules/semver/functions/gt.js [app-ssr] (ecmascript)");
const lt = __turbopack_context__.r("[project]/node_modules/semver/functions/lt.js [app-ssr] (ecmascript)");
const eq = __turbopack_context__.r("[project]/node_modules/semver/functions/eq.js [app-ssr] (ecmascript)");
const neq = __turbopack_context__.r("[project]/node_modules/semver/functions/neq.js [app-ssr] (ecmascript)");
const gte = __turbopack_context__.r("[project]/node_modules/semver/functions/gte.js [app-ssr] (ecmascript)");
const lte = __turbopack_context__.r("[project]/node_modules/semver/functions/lte.js [app-ssr] (ecmascript)");
const cmp = __turbopack_context__.r("[project]/node_modules/semver/functions/cmp.js [app-ssr] (ecmascript)");
const coerce = __turbopack_context__.r("[project]/node_modules/semver/functions/coerce.js [app-ssr] (ecmascript)");
const Comparator = __turbopack_context__.r("[project]/node_modules/semver/classes/comparator.js [app-ssr] (ecmascript)");
const Range = __turbopack_context__.r("[project]/node_modules/semver/classes/range.js [app-ssr] (ecmascript)");
const satisfies = __turbopack_context__.r("[project]/node_modules/semver/functions/satisfies.js [app-ssr] (ecmascript)");
const toComparators = __turbopack_context__.r("[project]/node_modules/semver/ranges/to-comparators.js [app-ssr] (ecmascript)");
const maxSatisfying = __turbopack_context__.r("[project]/node_modules/semver/ranges/max-satisfying.js [app-ssr] (ecmascript)");
const minSatisfying = __turbopack_context__.r("[project]/node_modules/semver/ranges/min-satisfying.js [app-ssr] (ecmascript)");
const minVersion = __turbopack_context__.r("[project]/node_modules/semver/ranges/min-version.js [app-ssr] (ecmascript)");
const validRange = __turbopack_context__.r("[project]/node_modules/semver/ranges/valid.js [app-ssr] (ecmascript)");
const outside = __turbopack_context__.r("[project]/node_modules/semver/ranges/outside.js [app-ssr] (ecmascript)");
const gtr = __turbopack_context__.r("[project]/node_modules/semver/ranges/gtr.js [app-ssr] (ecmascript)");
const ltr = __turbopack_context__.r("[project]/node_modules/semver/ranges/ltr.js [app-ssr] (ecmascript)");
const intersects = __turbopack_context__.r("[project]/node_modules/semver/ranges/intersects.js [app-ssr] (ecmascript)");
const simplifyRange = __turbopack_context__.r("[project]/node_modules/semver/ranges/simplify.js [app-ssr] (ecmascript)");
const subset = __turbopack_context__.r("[project]/node_modules/semver/ranges/subset.js [app-ssr] (ecmascript)");
module.exports = {
    parse,
    valid,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
};
}),
"[project]/node_modules/@metamask/abi-utils/dist/errors.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ParserError = exports.getErrorStack = exports.getErrorMessage = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs [app-ssr] (ecmascript)");
/**
 * Attempt to get an error message from a value.
 *
 * - If the value is an error, the error's message is returned.
 * - If the value is an object with a `message` property, the value of that
 * property is returned.
 * - If the value is a string, the value is returned.
 * - Otherwise, "Unknown error." is returned.
 *
 * @param error - The value to get an error message from.
 * @returns The error message.
 * @internal
 */ const getErrorMessage = (error)=>{
    if (typeof error === 'string') {
        return error;
    }
    if (error instanceof Error) {
        return error.message;
    }
    if ((0, utils_1.isObject)(error) && (0, utils_1.hasProperty)(error, 'message') && typeof error.message === 'string') {
        return error.message;
    }
    return 'Unknown error.';
};
exports.getErrorMessage = getErrorMessage;
/**
 * Get the error stack from a value. If the value is an error, the error's stack
 * is returned. Otherwise, it returns `undefined`.
 *
 * @param error - The value to get an error stack from.
 * @returns The error stack, or `undefined` if the value is not an error.
 * @internal
 */ const getErrorStack = (error)=>{
    if (error instanceof Error) {
        return error.stack;
    }
    return undefined;
};
exports.getErrorStack = getErrorStack;
/**
 * An error that is thrown when the ABI encoder or decoder encounters an
 * issue.
 */ class ParserError extends Error {
    constructor(message, originalError){
        super(message);
        this.name = 'ParserError';
        const originalStack = (0, exports.getErrorStack)(originalError);
        if (originalStack) {
            this.stack = originalStack;
        }
    }
}
exports.ParserError = ParserError; //# sourceMappingURL=errors.js.map
}),
"[project]/node_modules/@metamask/abi-utils/dist/iterator.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.iterate = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs [app-ssr] (ecmascript)");
/**
 * Iterate over a buffer with the specified size. This will yield a part of the
 * buffer starting at an increment of the specified size, until the end of the
 * buffer is reached.
 *
 * Calling the `skip` function will make it skip the specified number of bytes.
 *
 * @param buffer - The buffer to iterate over.
 * @param size - The number of bytes to iterate with.
 * @returns An iterator that yields the parts of the byte array.
 * @yields The parts of the byte array.
 */ const iterate = function*(buffer, size = 32) {
    for(let pointer = 0; pointer < buffer.length; pointer += size){
        const skip = (length)=>{
            (0, utils_1.assert)(length >= 0, 'Cannot skip a negative number of bytes.');
            (0, utils_1.assert)(length % size === 0, 'Length must be a multiple of the size.');
            pointer += length;
        };
        const value = buffer.subarray(pointer);
        yield {
            skip,
            value
        };
    }
    return {
        skip: ()=>undefined,
        value: new Uint8Array()
    };
};
exports.iterate = iterate; //# sourceMappingURL=iterator.js.map
}),
"[project]/node_modules/@metamask/abi-utils/dist/utils/buffer.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.padEnd = exports.padStart = exports.set = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs [app-ssr] (ecmascript)");
const BUFFER_WIDTH = 32;
/**
 * Set `buffer` in `target` at the specified position.
 *
 * @param target - The buffer to set to.
 * @param buffer - The buffer to set in the target.
 * @param position - The position at which to set the target.
 * @returns The combined buffer.
 */ const set = (target, buffer, position)=>{
    return (0, utils_1.concatBytes)([
        target.subarray(0, position),
        buffer,
        target.subarray(position + buffer.length)
    ]);
};
exports.set = set;
/**
 * Add padding to a buffer. If the buffer is larger than `length`, this function won't do anything. If it's smaller, the
 * buffer will be padded to the specified length, with extra zeroes at the start.
 *
 * @param buffer - The buffer to add padding to.
 * @param length - The number of bytes to pad the buffer to.
 * @returns The padded buffer.
 */ const padStart = (buffer, length = BUFFER_WIDTH)=>{
    const padding = new Uint8Array(Math.max(length - buffer.length, 0)).fill(0x00);
    return (0, utils_1.concatBytes)([
        padding,
        buffer
    ]);
};
exports.padStart = padStart;
/**
 * Add padding to a buffer. If the buffer is larger than `length`, this function won't do anything. If it's smaller, the
 * buffer will be padded to the specified length, with extra zeroes at the end.
 *
 * @param buffer - The buffer to add padding to.
 * @param length - The number of bytes to pad the buffer to.
 * @returns The padded buffer.
 */ const padEnd = (buffer, length = BUFFER_WIDTH)=>{
    const padding = new Uint8Array(Math.max(length - buffer.length, 0)).fill(0x00);
    return (0, utils_1.concatBytes)([
        buffer,
        padding
    ]);
};
exports.padEnd = padEnd; //# sourceMappingURL=buffer.js.map
}),
"[project]/node_modules/@metamask/abi-utils/dist/utils/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/utils/buffer.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@metamask/abi-utils/dist/parsers/address.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.address = exports.getAddress = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs [app-ssr] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/errors.js [app-ssr] (ecmascript)");
const utils_2 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/utils/index.js [app-ssr] (ecmascript)");
/**
 * Normalize an address value. This accepts the address as:
 *
 * - A hex string starting with the `0x` prefix.
 * - A byte array (`Uint8Array` or `Buffer`).
 *
 * It checks that the address is 20 bytes long.
 *
 * @param value - The value to normalize.
 * @returns The normalized address as `Uint8Array`.
 */ const getAddress = (value)=>{
    const bytesValue = (0, utils_1.createBytes)(value);
    (0, utils_1.assert)(bytesValue.length <= 20, new errors_1.ParserError(`Invalid address value. Expected address to be 20 bytes long, but received ${bytesValue.length} bytes.`));
    return (0, utils_2.padStart)(bytesValue, 20);
};
exports.getAddress = getAddress;
exports.address = {
    isDynamic: false,
    /**
     * Get if the given value is a valid address type. Since `address` is a simple
     * type, this is just a check that the value is "address".
     *
     * @param type - The type to check.
     * @returns Whether the type is a valid address type.
     */ isType: (type)=>type === 'address',
    /**
     * Get the byte length of an encoded address. Since `address` is a simple
     * type, this always returns 32.
     *
     * Note that actual addresses are only 20 bytes long, but the encoding of
     * the `address` type is always 32 bytes long.
     *
     * @returns The byte length of an encoded address.
     */ getByteLength () {
        return 32;
    },
    /**
     * Encode the given address to a 32-byte-long byte array.
     *
     * @param args - The encoding arguments.
     * @param args.buffer - The byte array to add to.
     * @param args.value - The address to encode.
     * @param args.packed - Whether to use packed encoding.
     * @returns The bytes with the encoded address added to it.
     */ encode ({ buffer, value, packed }) {
        const addressValue = (0, exports.getAddress)(value);
        // If we're using packed encoding, we can just add the address bytes to the
        // byte array, without adding any padding.
        if (packed) {
            return (0, utils_1.concatBytes)([
                buffer,
                addressValue
            ]);
        }
        const addressBuffer = (0, utils_2.padStart)(addressValue);
        return (0, utils_1.concatBytes)([
            buffer,
            addressBuffer
        ]);
    },
    /**
     * Decode the given byte array to an address.
     *
     * @param args - The decoding arguments.
     * @param args.value - The byte array to decode.
     * @returns The decoded address as a hexadecimal string, starting with the
     * "0x"-prefix.
     */ decode ({ value }) {
        return (0, utils_1.add0x)((0, utils_1.bytesToHex)(value.slice(12, 32)));
    }
}; //# sourceMappingURL=address.js.map
}),
"[project]/node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fixedBytes = exports.getByteLength = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs [app-ssr] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/errors.js [app-ssr] (ecmascript)");
const utils_2 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/utils/index.js [app-ssr] (ecmascript)");
const BYTES_REGEX = /^bytes([0-9]{1,2})$/u;
/**
 * Get the length of the specified type. If a length is not specified, or if the
 * length is out of range (0 < n <= 32), this will throw an error.
 *
 * @param type - The type to get the length for.
 * @returns The byte length of the type.
 */ const getByteLength = (type)=>{
    const bytes = type.match(BYTES_REGEX)?.[1];
    (0, utils_1.assert)(bytes, `Invalid byte length. Expected a number between 1 and 32, but received "${type}".`);
    const length = Number(bytes);
    (0, utils_1.assert)(length > 0 && length <= 32, new errors_1.ParserError(`Invalid byte length. Expected a number between 1 and 32, but received "${type}".`));
    return length;
};
exports.getByteLength = getByteLength;
exports.fixedBytes = {
    isDynamic: false,
    /**
     * Check if a type is a fixed bytes type.
     *
     * @param type - The type to check.
     * @returns Whether the type is a fixed bytes type.
     */ isType (type) {
        return BYTES_REGEX.test(type);
    },
    /**
     * Get the byte length of an encoded fixed bytes type.
     *
     * @returns The byte length of the type.
     */ getByteLength () {
        return 32;
    },
    /**
     * Encode a fixed bytes value.
     *
     * @param args - The arguments to encode.
     * @param args.type - The type of the value.
     * @param args.buffer - The byte array to add to.
     * @param args.value - The value to encode.
     * @param args.packed - Whether to use packed encoding.
     * @returns The bytes with the encoded value added to it.
     */ encode ({ type, buffer, value, packed }) {
        const length = (0, exports.getByteLength)(type);
        const bufferValue = (0, utils_1.createBytes)(value);
        (0, utils_1.assert)(bufferValue.length <= length, new errors_1.ParserError(`Expected a value of length ${length}, but received a value of length ${bufferValue.length}.`));
        // For packed encoding, the value is padded to the length of the type, and
        // then added to the byte array.
        if (packed) {
            return (0, utils_1.concatBytes)([
                buffer,
                (0, utils_2.padEnd)(bufferValue, length)
            ]);
        }
        return (0, utils_1.concatBytes)([
            buffer,
            (0, utils_2.padEnd)(bufferValue)
        ]);
    },
    /**
     * Decode a fixed bytes value.
     *
     * @param args - The arguments to decode.
     * @param args.type - The type of the value.
     * @param args.value - The value to decode.
     * @returns The decoded value as a `Uint8Array`.
     */ decode ({ type, value }) {
        const length = (0, exports.getByteLength)(type);
        // Since we're returning a `Uint8Array`, we use `slice` to copy the bytes
        // into a new array.
        return value.slice(0, length);
    }
}; //# sourceMappingURL=fixed-bytes.js.map
}),
"[project]/node_modules/@metamask/abi-utils/dist/parsers/tuple.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.tuple = exports.getTupleElements = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs [app-ssr] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/errors.js [app-ssr] (ecmascript)");
const packer_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/packer.js [app-ssr] (ecmascript)");
const TUPLE_REGEX = /^\((.+)\)$/u;
const isTupleType = (type)=>TUPLE_REGEX.test(type);
/**
 * Get elements from a tuple type.
 *
 * @param type - The tuple type to get the types for.
 * @returns The elements of the tuple as string array.
 */ const getTupleElements = (type)=>{
    (0, utils_1.assert)(type.startsWith('(') && type.endsWith(')'), new errors_1.ParserError(`Invalid tuple type. Expected tuple type, but received "${type}".`));
    const elements = [];
    let current = '';
    let depth = 0;
    for(let i = 1; i < type.length - 1; i++){
        const char = type[i];
        if (char === ',' && depth === 0) {
            elements.push(current.trim());
            current = '';
        } else {
            current += char;
            if (char === '(') {
                depth += 1;
            } else if (char === ')') {
                depth -= 1;
            }
        }
    }
    if (current.trim()) {
        elements.push(current.trim());
    }
    return elements;
};
exports.getTupleElements = getTupleElements;
exports.tuple = {
    /**
     * Check if the tuple is dynamic. Tuples are dynamic if one or more elements
     * of the tuple are dynamic.
     *
     * @param type - The type to check.
     * @returns Whether the tuple is dynamic.
     */ isDynamic (type) {
        const elements = (0, exports.getTupleElements)(type);
        return elements.some((element)=>{
            const parser = (0, packer_1.getParser)(element);
            return (0, packer_1.isDynamicParser)(parser, element);
        });
    },
    /**
     * Check if a type is a tuple type.
     *
     * @param type - The type to check.
     * @returns Whether the type is a tuple type.
     */ isType (type) {
        return isTupleType(type);
    },
    /**
     * Get the byte length of a tuple type. If the tuple is dynamic, this will
     * always return 32. If the tuple is static, this will return the sum of the
     * byte lengths of the tuple elements.
     *
     * @param type - The type to get the byte length for.
     * @returns The byte length of the tuple type.
     */ getByteLength (type) {
        if ((0, packer_1.isDynamicParser)(this, type)) {
            return 32;
        }
        const elements = (0, exports.getTupleElements)(type);
        return elements.reduce((total, element)=>{
            return total + (0, packer_1.getParser)(element).getByteLength(element);
        }, 0);
    },
    /**
     * Encode a tuple value.
     *
     * @param args - The encoding arguments.
     * @param args.type - The type of the value.
     * @param args.buffer - The byte array to add to.
     * @param args.value - The value to encode.
     * @param args.packed - Whether to use non-standard packed encoding.
     * @param args.tight - Whether to use non-standard tight encoding.
     * @returns The bytes with the encoded value added to it.
     */ encode ({ type, buffer, value, packed, tight }) {
        const elements = (0, exports.getTupleElements)(type);
        return (0, packer_1.pack)({
            types: elements,
            values: value,
            byteArray: buffer,
            packed,
            tight
        });
    },
    /**
     * Decode a tuple value.
     *
     * @param args - The decoding arguments.
     * @param args.type - The type of the value.
     * @param args.value - The value to decode.
     * @param args.skip - A function to skip a number of bytes.
     * @returns The decoded value.
     */ decode ({ type, value, skip }) {
        const elements = (0, exports.getTupleElements)(type);
        const length = this.getByteLength(type) - 32;
        skip(length);
        return (0, packer_1.unpack)(elements, value);
    }
}; //# sourceMappingURL=tuple.js.map
}),
"[project]/node_modules/@metamask/abi-utils/dist/parsers/array.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.array = exports.getTupleType = exports.getArrayType = exports.isArrayType = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs [app-ssr] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/errors.js [app-ssr] (ecmascript)");
const packer_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/packer.js [app-ssr] (ecmascript)");
const utils_2 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/utils/index.js [app-ssr] (ecmascript)");
const fixed_bytes_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.js [app-ssr] (ecmascript)");
const tuple_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/parsers/tuple.js [app-ssr] (ecmascript)");
const ARRAY_REGEX = /^(?<type>.*)\[(?<length>\d*?)\]$/u;
const isArrayType = (type)=>ARRAY_REGEX.test(type);
exports.isArrayType = isArrayType;
/**
 * Get the type of the array.
 *
 * @param type - The type to get the array type for.
 * @returns The array type.
 */ const getArrayType = (type)=>{
    const match = type.match(ARRAY_REGEX);
    (0, utils_1.assert)(match?.groups?.type, new errors_1.ParserError(`Invalid array type. Expected an array type, but received "${type}".`));
    return [
        match.groups.type,
        match.groups.length ? parseInt(match.groups.length, 10) : undefined
    ];
};
exports.getArrayType = getArrayType;
/**
 * Get the type of the array as a tuple type. This is used for encoding fixed
 * length arrays, which are encoded as tuples.
 *
 * @param innerType - The type of the array.
 * @param length - The length of the array.
 * @returns The tuple type.
 */ const getTupleType = (innerType, length)=>{
    return `(${new Array(length).fill(innerType).join(',')})`;
};
exports.getTupleType = getTupleType;
exports.array = {
    /**
     * Check if the array is dynamic. Arrays are dynamic if the array does not
     * have a fixed length, or if the array type is dynamic.
     *
     * @param type - The type to check.
     * @returns Whether the array is dynamic.
     */ isDynamic (type) {
        const [innerType, length] = (0, exports.getArrayType)(type);
        return(// `T[]` is dynamic for any `T`. `T[k]` is dynamic for any dynamic `T` and
        // any `k >= 0`.
        length === undefined || (0, packer_1.isDynamicParser)((0, packer_1.getParser)(innerType), innerType));
    },
    /**
     * Check if a type is an array type.
     *
     * @param type - The type to check.
     * @returns Whether the type is an array type.
     */ isType (type) {
        return (0, exports.isArrayType)(type);
    },
    /**
     * Get the byte length of an encoded array. If the array is dynamic, this
     * returns 32, i.e., the length of the pointer to the array. If the array is
     * static, this returns the byte length of the resulting tuple type.
     *
     * @param type - The type to get the byte length for.
     * @returns The byte length of an encoded array.
     */ getByteLength (type) {
        (0, utils_1.assert)((0, exports.isArrayType)(type), new errors_1.ParserError(`Expected an array type, but received "${type}".`));
        const [innerType, length] = (0, exports.getArrayType)(type);
        if (!(0, packer_1.isDynamicParser)(this, type) && length !== undefined) {
            return tuple_1.tuple.getByteLength((0, exports.getTupleType)(innerType, length));
        }
        return 32;
    },
    /**
     * Encode the given array to a byte array. If the array is static, this uses
     * the tuple encoder.
     *
     * @param args - The encoding arguments.
     * @param args.type - The type of the array.
     * @param args.buffer - The byte array to add to.
     * @param args.value - The array to encode.
     * @param args.packed - Whether to use non-standard packed encoding.
     * @param args.tight - Whether to use non-standard tight encoding.
     * @returns The bytes with the encoded array added to it.
     */ encode ({ type, buffer, value, packed, tight }) {
        const [arrayType, fixedLength] = (0, exports.getArrayType)(type);
        // Packed encoding does not support nested arrays.
        (0, utils_1.assert)(!packed || !(0, exports.isArrayType)(arrayType), new errors_1.ParserError(`Cannot pack nested arrays.`));
        // Tightly pack `T[]` where `T` is a dynamic type. This is not supported in
        // Solidity, but is commonly used in the Ethereum ecosystem.
        if (packed && (0, packer_1.isDynamicParser)((0, packer_1.getParser)(arrayType), arrayType)) {
            return (0, packer_1.pack)({
                types: new Array(value.length).fill(arrayType),
                values: value,
                byteArray: buffer,
                packed,
                arrayPacked: true,
                tight
            });
        }
        if (fixedLength) {
            (0, utils_1.assert)(fixedLength === value.length, new errors_1.ParserError(`Array length does not match type length. Expected a length of ${fixedLength}, but received ${value.length}.`));
            // `T[k]` for any `T` and `k` is encoded as `(T[0], ..., T[k - 1])`.
            return tuple_1.tuple.encode({
                type: (0, exports.getTupleType)(arrayType, fixedLength),
                buffer,
                value,
                // In "tight" mode, we don't pad the values to 32 bytes if the value is
                // of type `bytesN`. This is an edge case in `ethereumjs-abi` that we
                // support to provide compatibility with it.
                packed: fixed_bytes_1.fixedBytes.isType(arrayType) && tight,
                tight
            });
        }
        // For packed encoding, we don't need to encode the length of the array,
        // so we can just encode the values.
        if (packed) {
            return (0, packer_1.pack)({
                types: new Array(value.length).fill(arrayType),
                values: value,
                byteArray: buffer,
                // In "tight" mode, we don't pad the values to 32 bytes if the value is
                // of type `bytesN`. This is an edge case in `ethereumjs-abi` that we
                // support to provide compatibility with it.
                packed: fixed_bytes_1.fixedBytes.isType(arrayType) && tight,
                arrayPacked: true,
                tight
            });
        }
        // `T[]` with `k` elements is encoded as `k (T[0], ..., T[k - 1])`. That
        // means that we just need to encode the length of the array, and then the
        // array itself. The pointer is encoded by the {@link pack} function.
        const arrayLength = (0, utils_2.padStart)((0, utils_1.numberToBytes)(value.length));
        return (0, packer_1.pack)({
            types: new Array(value.length).fill(arrayType),
            values: value,
            byteArray: (0, utils_1.concatBytes)([
                buffer,
                arrayLength
            ]),
            packed,
            tight
        });
    },
    /**
     * Decode an array from the given byte array.
     *
     * @param args - The decoding arguments.
     * @param args.type - The type of the array.
     * @param args.value - The byte array to decode.
     * @returns The decoded array.
     */ decode ({ type, value, ...rest }) {
        const [arrayType, fixedLength] = (0, exports.getArrayType)(type);
        if (fixedLength) {
            const result = tuple_1.tuple.decode({
                type: (0, exports.getTupleType)(arrayType, fixedLength),
                value,
                ...rest
            });
            (0, utils_1.assert)(result.length === fixedLength, new errors_1.ParserError(`Array length does not match type length. Expected a length of ${fixedLength}, but received ${result.length}.`));
            return result;
        }
        const arrayLength = (0, utils_1.bytesToNumber)(value.subarray(0, 32));
        return (0, packer_1.unpack)(new Array(arrayLength).fill(arrayType), value.subarray(32));
    }
}; //# sourceMappingURL=array.js.map
}),
"[project]/node_modules/@metamask/abi-utils/dist/parsers/number.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.number = exports.getBigInt = exports.assertNumberLength = exports.getLength = exports.isSigned = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs [app-ssr] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/errors.js [app-ssr] (ecmascript)");
const utils_2 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/utils/index.js [app-ssr] (ecmascript)");
const NUMBER_REGEX = /^u?int(?<length>[0-9]*)?$/u;
/**
 * Check if a number type is signed.
 *
 * @param type - The type to check.
 * @returns Whether the type is signed.
 */ const isSigned = (type)=>{
    return !type.startsWith('u');
};
exports.isSigned = isSigned;
/**
 * Get the length of the specified type. If a length is not specified, if the
 * length is out of range (8 <= n <= 256), or if the length is not a multiple of
 * 8, this will throw an error.
 *
 * @param type - The type to get the length for.
 * @returns The bit length of the type.
 */ const getLength = (type)=>{
    if (type === 'int' || type === 'uint') {
        return 256;
    }
    const match = type.match(NUMBER_REGEX);
    (0, utils_1.assert)(match?.groups?.length, new errors_1.ParserError(`Invalid number type. Expected a number type, but received "${type}".`));
    const length = parseInt(match.groups.length, 10);
    (0, utils_1.assert)(length >= 8 && length <= 256, new errors_1.ParserError(`Invalid number length. Expected a number between 8 and 256, but received "${type}".`));
    (0, utils_1.assert)(length % 8 === 0, new errors_1.ParserError(`Invalid number length. Expected a multiple of 8, but received "${type}".`));
    return length;
};
exports.getLength = getLength;
/**
 * Assert that the byte length of the given value is in range for the given
 * number type.
 *
 * @param value - The value to check.
 * @param type - The type of the value.
 * @throws If the value is out of range for the type.
 */ const assertNumberLength = (value, type)=>{
    const length = (0, exports.getLength)(type);
    const maxValue = BigInt(2) ** BigInt(length - ((0, exports.isSigned)(type) ? 1 : 0)) - BigInt(1);
    if ((0, exports.isSigned)(type)) {
        // Signed types must be in the range of `-(2^(length - 1))` to
        // `2^(length - 1) - 1`.
        (0, utils_1.assert)(value >= -(maxValue + BigInt(1)) && value <= maxValue, new errors_1.ParserError(`Number "${value}" is out of range for type "${type}".`));
        return;
    }
    // Unsigned types must be in the range of `0` to `2^length - 1`.
    (0, utils_1.assert)(value <= maxValue, new errors_1.ParserError(`Number "${value}" is out of range for type "${type}".`));
};
exports.assertNumberLength = assertNumberLength;
/**
 * Normalize a `bigint` value. This accepts the value as:
 *
 * - A `bigint`.
 * - A `number`.
 * - A decimal string, i.e., a string that does not start with "0x".
 * - A hexadecimal string, i.e., a string that starts with "0x".
 *
 * @param value - The number-like value to parse.
 * @returns The value parsed as bigint.
 */ const getBigInt = (value)=>{
    try {
        return (0, utils_1.createBigInt)(value);
    } catch  {
        throw new errors_1.ParserError(`Invalid number. Expected a valid number value, but received "${value}".`);
    }
};
exports.getBigInt = getBigInt;
exports.number = {
    isDynamic: false,
    /**
     * Check if a type is a number type.
     *
     * @param type - The type to check.
     * @returns Whether the type is a number type.
     */ isType (type) {
        return NUMBER_REGEX.test(type);
    },
    /**
     * Get the byte length of an encoded number type. Since `int` and `uint` are
     * simple types, this will always return 32.
     *
     * @returns The byte length of the type.
     */ getByteLength () {
        return 32;
    },
    /**
     * Encode a number value.
     *
     * @param args - The arguments to encode.
     * @param args.type - The type of the value.
     * @param args.buffer - The byte array to add to.
     * @param args.value - The value to encode.
     * @param args.packed - Whether to use packed encoding.
     * @returns The bytes with the encoded value added to it.
     */ encode ({ type, buffer, value, packed }) {
        const bigIntValue = (0, exports.getBigInt)(value);
        (0, exports.assertNumberLength)(bigIntValue, type);
        if ((0, exports.isSigned)(type)) {
            // For packed encoding, the value is padded to the length of the type, and
            // then added to the byte array.
            if (packed) {
                const length = (0, exports.getLength)(type) / 8;
                return (0, utils_1.concatBytes)([
                    buffer,
                    (0, utils_1.signedBigIntToBytes)(bigIntValue, length)
                ]);
            }
            return (0, utils_1.concatBytes)([
                buffer,
                (0, utils_2.padStart)((0, utils_1.signedBigIntToBytes)(bigIntValue, 32))
            ]);
        }
        // For packed encoding, the value is padded to the length of the type, and
        // then added to the byte array.
        if (packed) {
            const length = (0, exports.getLength)(type) / 8;
            return (0, utils_1.concatBytes)([
                buffer,
                (0, utils_2.padStart)((0, utils_1.bigIntToBytes)(bigIntValue), length)
            ]);
        }
        return (0, utils_1.concatBytes)([
            buffer,
            (0, utils_2.padStart)((0, utils_1.bigIntToBytes)(bigIntValue))
        ]);
    },
    /**
     * Decode a number value.
     *
     * @param args - The decoding arguments.
     * @param args.type - The type of the value.
     * @param args.value - The value to decode.
     * @returns The decoded value.
     */ decode ({ type, value }) {
        const buffer = value.subarray(0, 32);
        if ((0, exports.isSigned)(type)) {
            const numberValue = (0, utils_1.bytesToSignedBigInt)(buffer);
            (0, exports.assertNumberLength)(numberValue, type);
            return numberValue;
        }
        const numberValue = (0, utils_1.bytesToBigInt)(buffer);
        (0, exports.assertNumberLength)(numberValue, type);
        return numberValue;
    }
}; //# sourceMappingURL=number.js.map
}),
"[project]/node_modules/@metamask/abi-utils/dist/parsers/bool.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bool = exports.getBooleanValue = void 0;
const superstruct_1 = __turbopack_context__.r("[project]/node_modules/@metamask/superstruct/dist/index.cjs [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs [app-ssr] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/errors.js [app-ssr] (ecmascript)");
const number_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/parsers/number.js [app-ssr] (ecmascript)");
const BooleanCoercer = (0, superstruct_1.coerce)((0, superstruct_1.boolean)(), (0, superstruct_1.union)([
    (0, superstruct_1.literal)('true'),
    (0, superstruct_1.literal)('false')
]), (value)=>value === 'true');
/**
 * Normalize a boolean value. This accepts the boolean as:
 *
 * - A boolean literal.
 * - The string "true" or "false".
 *
 * @param value - The value to get a boolean for.
 * @returns The parsed boolean value. This is `BigInt(1)` for truthy values, or
 * `BigInt(0)` for falsy values.
 */ const getBooleanValue = (value)=>{
    try {
        const booleanValue = (0, superstruct_1.create)(value, BooleanCoercer);
        if (booleanValue) {
            return BigInt(1);
        }
        return BigInt(0);
    } catch  {
        throw new errors_1.ParserError(`Invalid boolean value. Expected a boolean literal, or the string "true" or "false", but received "${value}".`);
    }
};
exports.getBooleanValue = getBooleanValue;
exports.bool = {
    isDynamic: false,
    /**
     * Get if the given value is a valid boolean type. Since `bool` is a simple
     * type, this is just a check that the value is "bool".
     *
     * @param type - The type to check.
     * @returns Whether the type is a valid boolean type.
     */ isType: (type)=>type === 'bool',
    /**
     * Get the byte length of an encoded boolean. Since `bool` is a simple
     * type, this always returns 32.
     *
     * Note that actual booleans are only 1 byte long, but the encoding of
     * the `bool` type is always 32 bytes long.
     *
     * @returns The byte length of an encoded boolean.
     */ getByteLength () {
        return 32;
    },
    /**
     * Encode the given boolean to a byte array.
     *
     * @param args - The encoding arguments.
     * @param args.buffer - The byte array to add to.
     * @param args.value - The boolean to encode.
     * @param args.packed - Whether the value is packed.
     * @param args.tight - Whether to use non-standard tight encoding.
     * @returns The bytes with the encoded boolean added to it.
     */ encode ({ buffer, value, packed, tight }) {
        const booleanValue = (0, exports.getBooleanValue)(value);
        // For packed encoding, we add a single byte (`0x00` or `0x01`) to the byte
        // array.
        if (packed) {
            return (0, utils_1.concatBytes)([
                buffer,
                (0, utils_1.bigIntToBytes)(booleanValue)
            ]);
        }
        // Booleans are encoded as 32-byte integers, so we use the number parser
        // to encode the boolean value.
        return number_1.number.encode({
            type: 'uint256',
            buffer,
            value: booleanValue,
            packed,
            tight
        });
    },
    /**
     * Decode the given byte array to a boolean.
     *
     * @param args - The decoding arguments.
     * @returns The decoded boolean.
     */ decode (args) {
        // Booleans are encoded as 32-byte integers, so we use the number parser
        // to decode the boolean value.
        return number_1.number.decode({
            ...args,
            type: 'uint256'
        }) === BigInt(1);
    }
}; //# sourceMappingURL=bool.js.map
}),
"[project]/node_modules/@metamask/abi-utils/dist/parsers/bytes.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bytes = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs [app-ssr] (ecmascript)");
const utils_2 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/utils/index.js [app-ssr] (ecmascript)");
exports.bytes = {
    isDynamic: true,
    /**
     * Check if a type is a bytes type. Since `bytes` is a simple type, this is
     * just a check that the type is "bytes".
     *
     * @param type - The type to check.
     * @returns Whether the type is a bytes type.
     */ isType: (type)=>type === 'bytes',
    /**
     * Get the byte length of an encoded bytes value. Since `bytes` is a simple
     * type, this always returns 32.
     *
     * Note that actual length of a bytes value is variable, but the encoded
     * static value (pointer) is always 32 bytes long.
     *
     * @returns The byte length of an encoded bytes value.
     */ getByteLength () {
        return 32;
    },
    /**
     * Encode the given bytes value to a byte array.
     *
     * @param args - The encoding arguments.
     * @param args.buffer - The byte array to add to.
     * @param args.value - The bytes value to encode.
     * @param args.packed - Whether to use packed encoding.
     * @returns The bytes with the encoded bytes value added to it.
     */ encode ({ buffer, value, packed }) {
        const bufferValue = (0, utils_1.createBytes)(value);
        // For packed encoding, we can just add the bytes value to the byte array,
        // without adding any padding or alignment. There is also no need to
        // encode the length of the bytes.
        if (packed) {
            return (0, utils_1.concatBytes)([
                buffer,
                bufferValue
            ]);
        }
        const paddedSize = Math.ceil(bufferValue.byteLength / 32) * 32;
        // Bytes of length `k` are encoded as `k pad_right(bytes)`.
        return (0, utils_1.concatBytes)([
            buffer,
            (0, utils_2.padStart)((0, utils_1.numberToBytes)(bufferValue.byteLength)),
            (0, utils_2.padEnd)(bufferValue, paddedSize)
        ]);
    },
    /**
     * Decode the given byte array to a bytes value.
     *
     * @param args - The decoding arguments.
     * @param args.value - The byte array to decode.
     * @returns The decoded bytes value as a `Uint8Array`.
     */ decode ({ value }) {
        const bytesValue = value.subarray(0, 32);
        const length = (0, utils_1.bytesToNumber)(bytesValue);
        // Since we're returning a `Uint8Array`, we use `slice` to copy the bytes
        // into a new array.
        return value.slice(32, 32 + length);
    }
}; //# sourceMappingURL=bytes.js.map
}),
"[project]/node_modules/@metamask/abi-utils/dist/parsers/function.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fn = exports.getFunction = void 0;
const superstruct_1 = __turbopack_context__.r("[project]/node_modules/@metamask/superstruct/dist/index.cjs [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs [app-ssr] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/errors.js [app-ssr] (ecmascript)");
const fixed_bytes_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.js [app-ssr] (ecmascript)");
/**
 * A struct that represents a Solidity function. The value must be a hex string
 * or a byte array. The created value will always be an object with an `address`
 * and `selector` property.
 */ const FunctionStruct = (0, superstruct_1.coerce)((0, superstruct_1.object)({
    address: utils_1.StrictHexStruct,
    selector: utils_1.StrictHexStruct
}), (0, superstruct_1.union)([
    utils_1.StrictHexStruct,
    (0, superstruct_1.instance)(Uint8Array)
]), (value)=>{
    const bytes = (0, utils_1.createBytes)(value);
    (0, utils_1.assert)(bytes.length === 24, new errors_1.ParserError(`Invalid Solidity function. Expected function to be 24 bytes long, but received ${bytes.length} bytes.`));
    return {
        address: (0, utils_1.bytesToHex)(bytes.subarray(0, 20)),
        selector: (0, utils_1.bytesToHex)(bytes.subarray(20, 24))
    };
});
/**
 * Normalize a function. This accepts the function as:
 *
 * - A {@link SolidityFunction} object.
 * - A hexadecimal string.
 * - A byte array.
 *
 * @param input - The function-like input.
 * @returns The function as buffer.
 */ const getFunction = (input)=>{
    const value = (0, superstruct_1.create)(input, FunctionStruct);
    return (0, utils_1.concatBytes)([
        (0, utils_1.hexToBytes)(value.address),
        (0, utils_1.hexToBytes)(value.selector)
    ]);
};
exports.getFunction = getFunction;
exports.fn = {
    isDynamic: false,
    /**
     * Check if a type is a function type. Since `function` is a simple type, this
     * is just a check that the type is "function".
     *
     * @param type - The type to check.
     * @returns Whether the type is a function type.
     */ isType: (type)=>type === 'function',
    /**
     * Get the byte length of an encoded function. Since `function` is a simple
     * type, this always returns 32.
     *
     * Note that actual functions are only 24 bytes long, but the encoding of
     * the `function` type is always 32 bytes long.
     *
     * @returns The byte length of an encoded function.
     */ getByteLength () {
        return 32;
    },
    /**
     * Encode the given function to a byte array.
     *
     * @param args - The encoding arguments.
     * @param args.buffer - The byte array to add to.
     * @param args.value - The function to encode.
     * @param args.packed - Whether to use packed encoding.
     * @param args.tight - Whether to use non-standard tight encoding.
     * @returns The bytes with the encoded function added to it.
     */ encode ({ buffer, value, packed, tight }) {
        const fnValue = (0, exports.getFunction)(value);
        // Functions are encoded as `bytes24`, so we use the fixedBytes parser to
        // encode the function.
        return fixed_bytes_1.fixedBytes.encode({
            type: 'bytes24',
            buffer,
            value: fnValue,
            packed,
            tight
        });
    },
    /**
     * Decode the given byte array to a function.
     *
     * @param args - The decoding arguments.
     * @param args.value - The byte array to decode.
     * @returns The decoded function as a {@link SolidityFunction} object.
     */ decode ({ value }) {
        return {
            address: (0, utils_1.bytesToHex)(value.slice(0, 20)),
            selector: (0, utils_1.bytesToHex)(value.slice(20, 24))
        };
    }
}; //# sourceMappingURL=function.js.map
}),
"[project]/node_modules/@metamask/abi-utils/dist/parsers/parser.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=parser.js.map
}),
"[project]/node_modules/@metamask/abi-utils/dist/parsers/string.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.string = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs [app-ssr] (ecmascript)");
const bytes_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/parsers/bytes.js [app-ssr] (ecmascript)");
exports.string = {
    isDynamic: true,
    /**
     * Check if a type is a string type. Since `string` is a simple type, this
     * is just a check if the type is "string".
     *
     * @param type - The type to check.
     * @returns Whether the type is a string type.
     */ isType: (type)=>type === 'string',
    /**
     * Get the byte length of an encoded string type. Since `string` is a simple
     * type, this will always return 32.
     *
     * Note that actual strings are variable in length, but the encoded static
     * value (pointer) is always 32 bytes long.
     *
     * @returns The byte length of an encoded string.
     */ getByteLength () {
        return 32;
    },
    /**
     * Encode the given string value to a byte array.
     *
     * @param args - The encoding arguments.
     * @param args.buffer - The byte array to add to.
     * @param args.value - The string value to encode.
     * @param args.packed - Whether to use packed encoding.
     * @param args.tight - Whether to use non-standard tight encoding.
     * @returns The bytes with the encoded string value added to it.
     */ encode ({ buffer, value, packed, tight }) {
        // Strings are encoded as UTF-8 bytes, so we use the bytes parser to encode
        // the string as bytes.
        return bytes_1.bytes.encode({
            type: 'bytes',
            buffer,
            value: (0, utils_1.stringToBytes)(value),
            packed,
            tight
        });
    },
    /**
     * Decode the given byte array to a string value.
     *
     * @param args - The decoding arguments.
     * @returns The decoded string value.
     */ decode (args) {
        // Strings are encoded as UTF-8 bytes, so we use the bytes parser to decode
        // the bytes, and convert them to a string.
        return (0, utils_1.bytesToString)(bytes_1.bytes.decode(args));
    }
}; //# sourceMappingURL=string.js.map
}),
"[project]/node_modules/@metamask/abi-utils/dist/parsers/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/parsers/address.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/parsers/array.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/parsers/bool.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/parsers/bytes.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/parsers/fixed-bytes.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/parsers/function.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/parsers/number.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/parsers/parser.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/parsers/string.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/parsers/tuple.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@metamask/abi-utils/dist/packer.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unpack = exports.pack = exports.isDynamicParser = exports.getParser = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs [app-ssr] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/errors.js [app-ssr] (ecmascript)");
const iterator_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/iterator.js [app-ssr] (ecmascript)");
const parsers_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/parsers/index.js [app-ssr] (ecmascript)");
const utils_2 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/utils/index.js [app-ssr] (ecmascript)");
/**
 * Get the parser for the specified type.
 *
 * @param type - The type to get a parser for.
 * @returns The parser.
 * @throws If there is no parser for the specified type.
 */ const getParser = (type)=>{
    const parsers = {
        address: parsers_1.address,
        array: parsers_1.array,
        bool: parsers_1.bool,
        bytes: parsers_1.bytes,
        fixedBytes: parsers_1.fixedBytes,
        function: parsers_1.fn,
        number: parsers_1.number,
        string: parsers_1.string,
        tuple: parsers_1.tuple
    };
    const staticParser = parsers[type];
    if (staticParser) {
        return staticParser;
    }
    const parser = Object.values(parsers).find((value)=>value.isType(type));
    if (parser) {
        return parser;
    }
    throw new errors_1.ParserError(`The type "${type}" is not supported.`);
};
exports.getParser = getParser;
/**
 * Check if the specified parser is dynamic, for the provided types. This is
 * primarily used for parsing tuples, where a tuple can be dynamic based on the
 * types. For other parsers, it will simply use the set `isDynamic` value.
 *
 * @param parser - The parser to check.
 * @param type - The type to check the parser with.
 * @returns Whether the parser is dynamic.
 */ const isDynamicParser = (parser, type)=>{
    const { isDynamic } = parser;
    if (typeof isDynamic === 'function') {
        return isDynamic(type);
    }
    return isDynamic;
};
exports.isDynamicParser = isDynamicParser;
/**
 * Pack the provided values in a buffer, encoded with the specified types. If a
 * buffer is specified, the resulting value will be concatenated with the
 * buffer.
 *
 * @param args - The arguments object.
 * @param args.types - The types of the values to pack.
 * @param args.values - The values to pack.
 * @param args.packed - Whether to use the non-standard packed mode. Defaults to
 * `false`.
 * @param args.arrayPacked - Whether to use the non-standard packed mode for
 * arrays. Defaults to `false`.
 * @param args.byteArray - The byte array to encode the values into. Defaults to
 * an empty array.
 * @param args.tight - Whether to use tight packing mode. Only applicable when
 * `packed` is true. When true, the packed mode will not add any padding bytes.
 * This matches the packing behaviour of `ethereumjs-abi`, but is not standard.
 * @returns The resulting encoded buffer.
 */ const pack = ({ types, values, packed = false, tight = false, arrayPacked = false, byteArray = new Uint8Array() })=>{
    (0, utils_1.assert)(types.length === values.length, new errors_1.ParserError(`The number of types (${types.length}) does not match the number of values (${values.length}).`));
    const { staticBuffer, dynamicBuffer, pointers } = types.reduce(// eslint-disable-next-line @typescript-eslint/no-shadow
    ({ staticBuffer, dynamicBuffer, pointers }, type, index)=>{
        const parser = (0, exports.getParser)(type);
        const value = values[index];
        // If packed mode is enabled, we can skip the dynamic check, as all
        // values are encoded in the static buffer.
        if (packed || arrayPacked || !(0, exports.isDynamicParser)(parser, type)) {
            return {
                staticBuffer: parser.encode({
                    buffer: staticBuffer,
                    value,
                    type,
                    packed,
                    tight
                }),
                dynamicBuffer,
                pointers
            };
        }
        const newStaticBuffer = (0, utils_1.concatBytes)([
            staticBuffer,
            new Uint8Array(32)
        ]);
        const newDynamicBuffer = parser.encode({
            buffer: dynamicBuffer,
            value,
            type,
            packed,
            tight
        });
        return {
            staticBuffer: newStaticBuffer,
            dynamicBuffer: newDynamicBuffer,
            pointers: [
                ...pointers,
                {
                    position: staticBuffer.length,
                    pointer: dynamicBuffer.length
                }
            ]
        };
    }, {
        staticBuffer: new Uint8Array(),
        dynamicBuffer: new Uint8Array(),
        pointers: []
    });
    // If packed mode is enabled, there shouldn't be any dynamic values.
    (0, utils_1.assert)(!packed && !arrayPacked || dynamicBuffer.length === 0, new errors_1.ParserError('Invalid pack state.'));
    const dynamicStart = staticBuffer.length;
    const updatedBuffer = pointers.reduce((target, { pointer, position })=>{
        const offset = (0, utils_2.padStart)((0, utils_1.numberToBytes)(dynamicStart + pointer));
        return (0, utils_2.set)(target, offset, position);
    }, staticBuffer);
    return (0, utils_1.concatBytes)([
        byteArray,
        updatedBuffer,
        dynamicBuffer
    ]);
};
exports.pack = pack;
const unpack = (types, buffer)=>{
    const iterator = (0, iterator_1.iterate)(buffer);
    return types.map((type)=>{
        const { value: { value, skip }, done } = iterator.next();
        (0, utils_1.assert)(!done, new errors_1.ParserError(`The encoded value is invalid for the provided types. Reached end of buffer while attempting to parse "${type}".`));
        const parser = (0, exports.getParser)(type);
        const isDynamic = (0, exports.isDynamicParser)(parser, type);
        if (isDynamic) {
            const pointer = (0, utils_1.bytesToNumber)(value.subarray(0, 32));
            const target = buffer.subarray(pointer);
            return parser.decode({
                type,
                value: target,
                skip
            });
        }
        return parser.decode({
            type,
            value,
            skip
        });
    });
};
exports.unpack = unpack; //# sourceMappingURL=packer.js.map
}),
"[project]/node_modules/@metamask/abi-utils/dist/abi.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// ESLint gets confused by the nested list and tables in the docs, so we disable
// the rule for this file.
/* eslint-disable jsdoc/check-indentation, jsdoc/match-description */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decodeSingle = exports.decode = exports.encodePacked = exports.encodeSingle = exports.encode = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/node_modules/@metamask/utils/dist/index.cjs [app-ssr] (ecmascript)");
const errors_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/errors.js [app-ssr] (ecmascript)");
const packer_1 = __turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/packer.js [app-ssr] (ecmascript)");
/**
 * Encode the data with the provided types. The types must be valid Solidity
 * ABI types.
 *
 * This will attempt to parse the values into the correct types. For example,
 * if you pass in a hex string for a `uint256`, it will be parsed into a
 * `bigint`. Regular strings are interpreted as UTF-8 strings. If you want to
 * pass in a hex string, you must pass it in as a `Uint8Array`, or use the
 * "0x"-prefix.
 *
 * It will also attempt to infer the types of the values. For example, if you
 * pass in a string for a `uint256`, it will result in a TypeScript compile-time
 * error. This does not work for all types, however. For example, if you use
 * nested arrays or tuples, the type will be inferred as `unknown`.
 *
 * The following types are supported:
 *
 * - `address`: A 20-byte Ethereum address.
 *   - As a 40-character-long hexadecimal string, starting with "0x".
 *   - As a 20-byte-long byte array, i.e., `Uint8Array`.
 * - `bool`: A boolean value.
 *   - As a boolean literal, i.e., `true` or `false`.
 *   - As the strings "true" or "false".
 * - `bytes(n)`: A dynamic byte array.
 *   - As a hexadecimal string, starting with "0x".
 *   - As a byte array, i.e., `Uint8Array`.
 *   - As a regular string, which will be interpreted as UTF-8.
 * - `function`: A Solidity function.
 *   - As a 48-character-long hexadecimal string, starting with "0x".
 *   - As a 24-byte-long byte array, i.e., `Uint8Array`.
 *   - As a {@link SolidityFunction} object.
 * - `int(n)`: A signed integer.
 *   - As a number.
 *   - As a `bigint`.
 *   - As a hexadecimal string, starting with "0x".
 * - `string`: A dynamic UTF-8 string.
 *   - As a regular string.
 *   - As a hexadecimal string, starting with "0x".
 *   - As a byte array, i.e., `Uint8Array`.
 * - `tuple`: A tuple of values.
 *   - As an array of values.
 * - `uint(n)`: An unsigned integer.
 *   - As a number.
 *   - As a `bigint`.
 *   - As a hexadecimal string, starting with "0x".
 *
 * @example
 * ```typescript
 * import { encode, decode } from '@metamask/abi-utils';
 *
 * const types = ['uint256', 'string'];
 * const encoded = encode(types, [42, 'Hello, world!']);
 * const decoded = decode(types, encoded);
 *
 * console.log(decoded); // [42n, 'Hello, world!']
 * ```
 * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html
 * @param types - The types to encode.
 * @param values - The values to encode. This array must have the same length as
 * the types array.
 * @param packed - Whether to use the non-standard packed mode. Defaults to
 * `false`.
 * @param tight - Whether to pack the values tightly. When enabled, the values
 * will be packed without any padding. This matches the behaviour of
 * `ethereumjs-abi`. Defaults to `false`.
 * @returns The ABI encoded bytes.
 */ const encode = (types, values, packed, tight)=>{
    try {
        return (0, packer_1.pack)({
            types,
            values,
            packed,
            tight
        });
    } catch (error) {
        if (error instanceof errors_1.ParserError) {
            throw new errors_1.ParserError(`Unable to encode value: ${error.message}`, error);
        }
        throw new errors_1.ParserError(`An unexpected error occurred: ${(0, errors_1.getErrorMessage)(error)}`, error);
    }
};
exports.encode = encode;
/**
 * Encode the data with the provided type. The type must be a valid Solidity
 * ABI type.
 *
 * See {@link encode} for more information on how values are parsed.
 *
 * @example
 * ```typescript
 * import { encodeSingle, decodeSingle } from '@metamask/abi-utils';
 *
 * const encoded = encodeSingle('uint256', 42);
 * const decoded = decodeSingle('uint256', encoded);
 *
 * console.log(decoded); // 42n
 * ```
 * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#types
 * @param type - The type to encode.
 * @param value - The value to encode.
 * @returns The ABI encoded bytes.
 */ const encodeSingle = (type, value)=>{
    return (0, exports.encode)([
        type
    ], [
        value
    ]);
};
exports.encodeSingle = encodeSingle;
/**
 * Encode the data with the provided types. The types must be valid Solidity
 * ABI types. This is similar to {@link encode}, but the values are encoded in
 * the non-standard packed mode. This differs from the standard encoding in the
 * following ways:
 *
 * - Most values are packed tightly, without alignment padding.
 *   - The exception is array values, which are padded to 32 bytes.
 * - Values are still padded to their full size, i.e., `uint16` values are still
 *  padded to 2 bytes, regardless of the length of the value.
 * - The encoding of dynamic types (`bytes`, `string`) is different. The length
 * of the dynamic type is not included in the encoding, and the dynamic type is
 * not padded to a multiple of 32 bytes.
 * - All values are encoded in-place, without any offsets.
 *
 * The encoding of this is ambiguous as soon as there is more than one dynamic
 * type. That means that these values cannot be decoded with {@link decode} or
 * Solidity's `abi.decode` function.
 *
 * See {@link encode} for more information on how values are parsed.
 *
 * @example
 * ```typescript
 * import { encodePacked } from '@metamask/abi-utils';
 *
 * const encoded = encodePacked(['uint8'], [42]);
 *
 * console.log(encoded); // `Uint8Array [ 42 ]`
 * ```
 * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#types
 * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#non-standard-packed-mode
 * @param types - The types to encode.
 * @param values - The values to encode.
 * @param tight - Whether to pack the values tightly. When enabled, `bytesN`
 * values in arrays will be packed without any padding. This matches the
 * behaviour of `ethereumjs-abi`. Defaults to `false`.
 * @returns The ABI encoded bytes.
 */ const encodePacked = (types, values, tight)=>{
    return (0, exports.encode)(types, values, true, tight);
};
exports.encodePacked = encodePacked;
/**
 * Decode an ABI encoded buffer with the specified types. The types must be
 * valid Solidity ABI types.
 *
 * This will attempt to infer the output types from the input types. For
 * example, if you use `uint256` as an input type, the output type will be
 * `bigint`. This does not work for all types, however. For example, if you use
 * nested array types or tuple types, the output type will be `unknown`.
 *
 * The resulting types of the values will be as follows:
 *
 * | Contract ABI Type | Resulting JavaScript Type |
 * | ----------------- | ------------------------- |
 * | `address`         | `string`                  |
 * | `bool`            | `boolean`                 |
 * | `bytes(n)`        | `Uint8Array`              |
 * | `function`        | {@link SolidityFunction}  |
 * | `int(n)`          | `bigint`                  |
 * | `string`          | `string`                  |
 * | `tuple`           | `Array`                   |
 * | `array`           | `Array`                   |
 * | `uint(n)`         | `bigint`                  |
 *
 * @example
 * ```typescript
 * import { encode, decode } from '@metamask/abi-utils';
 *
 * const types = ['uint256', 'string'];
 * const encoded = encode(types, [42, 'Hello, world!']);
 * const decoded = decode(types, encoded);
 *
 * console.log(decoded); // [42n, 'Hello, world!']
 * ```
 * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#types
 * @param types - The types to decode the bytes with.
 * @param value - The bytes-like value to decode.
 * @returns The decoded values as array.
 */ const decode = (types, value)=>{
    const bytes = (0, utils_1.createBytes)(value);
    try {
        return (0, packer_1.unpack)(types, bytes);
    } catch (error) {
        if (error instanceof errors_1.ParserError) {
            throw new errors_1.ParserError(`Unable to decode value: ${error.message}`, error);
        }
        throw new errors_1.ParserError(`An unexpected error occurred: ${(0, errors_1.getErrorMessage)(error)}`, error);
    }
};
exports.decode = decode;
/**
 * Decode the data with the provided type. The type must be a valid Solidity
 * ABI type.
 *
 * See {@link decode} for more information on how values are parsed.
 *
 * @example
 * ```typescript
 * import { encodeSingle, decodeSingle } from '@metamask/abi-utils';
 *
 * const encoded = encodeSingle('uint256', 42);
 * const decoded = decodeSingle('uint256', encoded);
 *
 * console.log(decoded); // 42n
 * ```
 * @see https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#types
 * @param type - The type to decode.
 * @param value - The bytes-like value to decode.
 * @returns The decoded value.
 */ const decodeSingle = (type, value)=>{
    const result = (0, exports.decode)([
        type
    ], value);
    (0, utils_1.assert)(result.length === 1, new errors_1.ParserError('Decoded value array has unexpected length.'));
    return result[0];
};
exports.decodeSingle = decodeSingle; //# sourceMappingURL=abi.js.map
}),
"[project]/node_modules/@metamask/abi-utils/dist/types/abi.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=abi.js.map
}),
"[project]/node_modules/@metamask/abi-utils/dist/types/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/types/abi.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@metamask/abi-utils/dist/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/abi.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/errors.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@metamask/abi-utils/dist/types/index.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@metamask/delegation-core/dist/index.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ANY_BENEFICIARY",
    ()=>ANY_BENEFICIARY,
    "CAVEAT_TYPEHASH",
    ()=>CAVEAT_TYPEHASH,
    "DELEGATION_TYPEHASH",
    ()=>DELEGATION_TYPEHASH,
    "ROOT_AUTHORITY",
    ()=>ROOT_AUTHORITY,
    "createERC20StreamingTerms",
    ()=>createERC20StreamingTerms,
    "createERC20TokenPeriodTransferTerms",
    ()=>createERC20TokenPeriodTransferTerms,
    "createExactCalldataTerms",
    ()=>createExactCalldataTerms,
    "createNativeTokenPeriodTransferTerms",
    ()=>createNativeTokenPeriodTransferTerms,
    "createNativeTokenStreamingTerms",
    ()=>createNativeTokenStreamingTerms,
    "createNonceTerms",
    ()=>createNonceTerms,
    "createTimestampTerms",
    ()=>createTimestampTerms,
    "createValueLteTerms",
    ()=>createValueLteTerms,
    "decodeDelegations",
    ()=>decodeDelegations,
    "encodeDelegations",
    ()=>encodeDelegations,
    "hashDelegation",
    ()=>hashDelegation
]);
// src/returns.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$delegation$2d$core$2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$bytes$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/delegation-core/node_modules/@metamask/utils/dist/bytes.mjs [app-ssr] (ecmascript)");
// src/caveats/erc20Streaming.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$delegation$2d$core$2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$hex$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/delegation-core/node_modules/@metamask/utils/dist/hex.mjs [app-ssr] (ecmascript)");
// src/delegation.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$abi$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@metamask/abi-utils/dist/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/sha3.js [app-ssr] (ecmascript)");
;
var defaultOptions = {
    out: "hex"
};
function prepareResult(result, options) {
    if (options.out === "hex") {
        const hexValue = typeof result === "string" ? result : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$delegation$2d$core$2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$bytes$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(result);
        return hexValue.startsWith("0x") ? hexValue : `0x${hexValue}`;
    }
    const bytesValue = result instanceof Uint8Array ? result : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$delegation$2d$core$2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$bytes$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(result);
    return bytesValue;
}
var bytesLikeToHex = (bytesLike)=>{
    if (typeof bytesLike === "string") {
        return bytesLike;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$delegation$2d$core$2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$bytes$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(bytesLike);
};
var bytesLikeToBytes = (bytesLike)=>{
    if (typeof bytesLike === "string") {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$delegation$2d$core$2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$bytes$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(bytesLike);
    }
    return bytesLike;
};
// src/utils.ts
var toHexString = ({ value, size })=>{
    return value.toString(16).padStart(size * 2, "0");
};
// src/caveats/valueLte.ts
function createValueLteTerms(terms, options = defaultOptions) {
    const { maxValue } = terms;
    if (maxValue < 0n) {
        throw new Error("Invalid maxValue: must be greater than or equal to zero");
    }
    const hexValue = toHexString({
        value: maxValue,
        size: 32
    });
    return prepareResult(hexValue, options);
}
// src/caveats/timestamp.ts
var TIMESTAMP_UPPER_BOUND_SECONDS = 253402300799;
function createTimestampTerms(terms, encodingOptions = defaultOptions) {
    const { timestampAfterThreshold, timestampBeforeThreshold } = terms;
    if (timestampAfterThreshold < 0) {
        throw new Error("Invalid timestampAfterThreshold: must be zero or positive");
    }
    if (timestampBeforeThreshold < 0) {
        throw new Error("Invalid timestampBeforeThreshold: must be zero or positive");
    }
    if (timestampBeforeThreshold > TIMESTAMP_UPPER_BOUND_SECONDS) {
        throw new Error(`Invalid timestampBeforeThreshold: must be less than or equal to ${TIMESTAMP_UPPER_BOUND_SECONDS}`);
    }
    if (timestampAfterThreshold > TIMESTAMP_UPPER_BOUND_SECONDS) {
        throw new Error(`Invalid timestampAfterThreshold: must be less than or equal to ${TIMESTAMP_UPPER_BOUND_SECONDS}`);
    }
    if (timestampBeforeThreshold !== 0 && timestampAfterThreshold >= timestampBeforeThreshold) {
        throw new Error("Invalid thresholds: timestampBeforeThreshold must be greater than timestampAfterThreshold when both are specified");
    }
    const afterThresholdHex = toHexString({
        value: timestampAfterThreshold,
        size: 16
    });
    const beforeThresholdHex = toHexString({
        value: timestampBeforeThreshold,
        size: 16
    });
    const hexValue = `0x${afterThresholdHex}${beforeThresholdHex}`;
    return prepareResult(hexValue, encodingOptions);
}
// src/caveats/nativeTokenPeriodTransfer.ts
function createNativeTokenPeriodTransferTerms(terms, encodingOptions = defaultOptions) {
    const { periodAmount, periodDuration, startDate } = terms;
    if (periodAmount <= 0n) {
        throw new Error("Invalid periodAmount: must be a positive number");
    }
    if (periodDuration <= 0) {
        throw new Error("Invalid periodDuration: must be a positive number");
    }
    if (startDate <= 0) {
        throw new Error("Invalid startDate: must be a positive number");
    }
    const periodAmountHex = toHexString({
        value: periodAmount,
        size: 32
    });
    const periodDurationHex = toHexString({
        value: periodDuration,
        size: 32
    });
    const startDateHex = toHexString({
        value: startDate,
        size: 32
    });
    const hexValue = `0x${periodAmountHex}${periodDurationHex}${startDateHex}`;
    return prepareResult(hexValue, encodingOptions);
}
// src/caveats/exactCalldata.ts
function createExactCalldataTerms(terms, encodingOptions = defaultOptions) {
    const { calldata } = terms;
    if (typeof calldata === "string" && !calldata.startsWith("0x")) {
        throw new Error("Invalid calldata: must be a hex string starting with 0x");
    }
    return prepareResult(calldata, encodingOptions);
}
// src/caveats/nativeTokenStreaming.ts
var TIMESTAMP_UPPER_BOUND_SECONDS2 = 253402300799;
function createNativeTokenStreamingTerms(terms, encodingOptions = defaultOptions) {
    const { initialAmount, maxAmount, amountPerSecond, startTime } = terms;
    if (initialAmount < 0n) {
        throw new Error("Invalid initialAmount: must be greater than zero");
    }
    if (maxAmount <= 0n) {
        throw new Error("Invalid maxAmount: must be a positive number");
    }
    if (maxAmount < initialAmount) {
        throw new Error("Invalid maxAmount: must be greater than initialAmount");
    }
    if (amountPerSecond <= 0n) {
        throw new Error("Invalid amountPerSecond: must be a positive number");
    }
    if (startTime <= 0) {
        throw new Error("Invalid startTime: must be a positive number");
    }
    if (startTime > TIMESTAMP_UPPER_BOUND_SECONDS2) {
        throw new Error("Invalid startTime: must be less than or equal to 253402300799");
    }
    const initialAmountHex = toHexString({
        value: initialAmount,
        size: 32
    });
    const maxAmountHex = toHexString({
        value: maxAmount,
        size: 32
    });
    const amountPerSecondHex = toHexString({
        value: amountPerSecond,
        size: 32
    });
    const startTimeHex = toHexString({
        value: startTime,
        size: 32
    });
    const hexValue = `0x${initialAmountHex}${maxAmountHex}${amountPerSecondHex}${startTimeHex}`;
    return prepareResult(hexValue, encodingOptions);
}
;
var TIMESTAMP_UPPER_BOUND_SECONDS3 = 253402300799;
function createERC20StreamingTerms(terms, encodingOptions = defaultOptions) {
    const { tokenAddress, initialAmount, maxAmount, amountPerSecond, startTime } = terms;
    if (!tokenAddress) {
        throw new Error("Invalid tokenAddress: must be a valid address");
    }
    let prefixedTokenAddressHex;
    if (typeof tokenAddress === "string") {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$delegation$2d$core$2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$hex$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isHexString"])(tokenAddress) || tokenAddress.length !== 42) {
            throw new Error("Invalid tokenAddress: must be a valid address");
        }
        prefixedTokenAddressHex = tokenAddress;
    } else {
        if (tokenAddress.length !== 20) {
            throw new Error("Invalid tokenAddress: must be a valid address");
        }
        prefixedTokenAddressHex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$delegation$2d$core$2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$bytes$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(tokenAddress);
    }
    if (initialAmount < 0n) {
        throw new Error("Invalid initialAmount: must be greater than zero");
    }
    if (maxAmount <= 0n) {
        throw new Error("Invalid maxAmount: must be a positive number");
    }
    if (maxAmount < initialAmount) {
        throw new Error("Invalid maxAmount: must be greater than initialAmount");
    }
    if (amountPerSecond <= 0n) {
        throw new Error("Invalid amountPerSecond: must be a positive number");
    }
    if (startTime <= 0) {
        throw new Error("Invalid startTime: must be a positive number");
    }
    if (startTime > TIMESTAMP_UPPER_BOUND_SECONDS3) {
        throw new Error("Invalid startTime: must be less than or equal to 253402300799");
    }
    const initialAmountHex = toHexString({
        value: initialAmount,
        size: 32
    });
    const maxAmountHex = toHexString({
        value: maxAmount,
        size: 32
    });
    const amountPerSecondHex = toHexString({
        value: amountPerSecond,
        size: 32
    });
    const startTimeHex = toHexString({
        value: startTime,
        size: 32
    });
    const hexValue = `${prefixedTokenAddressHex}${initialAmountHex}${maxAmountHex}${amountPerSecondHex}${startTimeHex}`;
    return prepareResult(hexValue, encodingOptions);
}
;
function createERC20TokenPeriodTransferTerms(terms, encodingOptions = defaultOptions) {
    const { tokenAddress, periodAmount, periodDuration, startDate } = terms;
    if (!tokenAddress) {
        throw new Error("Invalid tokenAddress: must be a valid address");
    }
    let prefixedTokenAddressHex;
    if (typeof tokenAddress === "string") {
        if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$delegation$2d$core$2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$hex$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isHexString"])(tokenAddress) || tokenAddress.length !== 42) {
            throw new Error("Invalid tokenAddress: must be a valid address");
        }
        prefixedTokenAddressHex = tokenAddress;
    } else {
        if (tokenAddress.length !== 20) {
            throw new Error("Invalid tokenAddress: must be a valid address");
        }
        prefixedTokenAddressHex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$delegation$2d$core$2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$bytes$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(tokenAddress);
    }
    if (periodAmount <= 0n) {
        throw new Error("Invalid periodAmount: must be a positive number");
    }
    if (periodDuration <= 0) {
        throw new Error("Invalid periodDuration: must be a positive number");
    }
    if (startDate <= 0) {
        throw new Error("Invalid startDate: must be a positive number");
    }
    const periodAmountHex = toHexString({
        value: periodAmount,
        size: 32
    });
    const periodDurationHex = toHexString({
        value: periodDuration,
        size: 32
    });
    const startDateHex = toHexString({
        value: startDate,
        size: 32
    });
    const hexValue = `${prefixedTokenAddressHex}${periodAmountHex}${periodDurationHex}${startDateHex}`;
    return prepareResult(hexValue, encodingOptions);
}
;
var MAX_NONCE_STRING_LENGTH = 66;
function createNonceTerms(terms, encodingOptions = defaultOptions) {
    const { nonce } = terms;
    if (nonce instanceof Uint8Array && nonce.length === 0) {
        throw new Error("Invalid nonce: Uint8Array must not be empty");
    }
    if (typeof nonce === "string" && !nonce.startsWith("0x")) {
        throw new Error("Invalid nonce: string must have 0x prefix");
    }
    const hexNonce = bytesLikeToHex(nonce);
    if (hexNonce === "0x") {
        throw new Error("Invalid nonce: must not be empty");
    }
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$delegation$2d$core$2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$hex$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isHexString"])(hexNonce)) {
        throw new Error("Invalid nonce: must be a valid BytesLike value");
    }
    if (hexNonce.length > MAX_NONCE_STRING_LENGTH) {
        throw new Error("Invalid nonce: must be 32 bytes or less in length");
    }
    const nonceWithoutPrefix = hexNonce.slice(2);
    const paddedNonce = nonceWithoutPrefix.padStart(64, "0");
    const hexValue = `0x${paddedNonce}`;
    return prepareResult(hexValue, encodingOptions);
}
;
;
;
var ANY_BENEFICIARY = "0x0000000000000000000000000000000000000a11";
var ROOT_AUTHORITY = "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
var DELEGATION_TYPEHASH = "0x88c1d2ecf185adf710588203a5f263f0ff61be0d33da39792cde19ba9aa4331e";
var CAVEAT_TYPEHASH = "0x80ad7e1b04ee6d994a125f4714ca0720908bd80ed16063ec8aee4b88e9253e2d";
var DELEGATION_ARRAY_ABI_TYPES = "(address,address,bytes32,(address,bytes,bytes)[],uint256,bytes)[]";
function encodeDelegations(delegations, options = defaultOptions) {
    let result;
    if (delegations.length === 0) {
        result = new Uint8Array(64);
        result[31] = 32;
    } else {
        const encodableStructs = delegations.map((struct)=>[
                struct.delegate,
                struct.delegator,
                struct.authority,
                struct.caveats.map((caveat)=>[
                        caveat.enforcer,
                        caveat.terms,
                        caveat.args
                    ]),
                struct.salt,
                struct.signature
            ]);
        result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$abi$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodeSingle"])(DELEGATION_ARRAY_ABI_TYPES, encodableStructs);
    }
    return prepareResult(result, options);
}
var delegationFromDecodedDelegation = (decodedDelegation, convertFn)=>{
    const [delegate, delegator, authority, caveats, salt, signature] = decodedDelegation;
    return {
        delegate: convertFn(delegate),
        delegator: convertFn(delegator),
        authority: convertFn(authority),
        caveats: caveats.map(([enforcer, terms, args])=>({
                enforcer: convertFn(enforcer),
                terms: convertFn(terms),
                args: convertFn(args)
            })),
        salt,
        signature: convertFn(signature)
    };
};
function decodeDelegations(encoded, options = defaultOptions) {
    const decodedStructs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$abi$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodeSingle"])(DELEGATION_ARRAY_ABI_TYPES, encoded);
    if (options.out === "bytes") {
        return decodedStructs.map((struct)=>delegationFromDecodedDelegation(struct, bytesLikeToBytes));
    }
    return decodedStructs.map((struct)=>delegationFromDecodedDelegation(struct, bytesLikeToHex));
}
function hashDelegation(delegation, options = defaultOptions) {
    const encoded = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$abi$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"])([
        "bytes32",
        "address",
        "address",
        "bytes32",
        "bytes32",
        "uint256"
    ], [
        DELEGATION_TYPEHASH,
        delegation.delegate,
        delegation.delegator,
        delegation.authority,
        getCaveatsArrayHash(delegation.caveats),
        delegation.salt
    ]);
    const hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["keccak_256"])(encoded);
    return prepareResult(hash, options);
}
function getCaveatsArrayHash(caveats) {
    const byteLength = 32 * caveats.length;
    const encoded = new Uint8Array(byteLength);
    for(let i = 0; i < caveats.length; i++){
        const caveat = caveats[i];
        if (!caveat) {
            throw new Error(`Caveat was undefined at index ${i}`);
        }
        const caveatHash = getCaveatHash(caveat);
        encoded.set(caveatHash, i * 32);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["keccak_256"])(encoded);
}
function getCaveatHash(caveat) {
    const termsBytes = typeof caveat.terms === "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$delegation$2d$core$2f$node_modules$2f40$metamask$2f$utils$2f$dist$2f$bytes$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(caveat.terms) : caveat.terms;
    const termsHash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["keccak_256"])(termsBytes);
    const encoded = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$metamask$2f$abi$2d$utils$2f$dist$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"])([
        "bytes32",
        "address",
        "bytes32"
    ], [
        CAVEAT_TYPEHASH,
        caveat.enforcer,
        termsHash
    ]);
    const hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["keccak_256"])(encoded);
    return hash;
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/webauthn-p256/_esm/utils.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "base64ToBase64Url",
    ()=>base64ToBase64Url,
    "base64ToUtf8",
    ()=>base64ToUtf8,
    "base64UrlToBase64",
    ()=>base64UrlToBase64,
    "base64UrlToBytes",
    ()=>base64UrlToBytes,
    "bytesToBase64Url",
    ()=>bytesToBase64Url,
    "bytesToCryptoKey",
    ()=>bytesToCryptoKey,
    "bytesToHex",
    ()=>bytesToHex,
    "cryptoKeyToBytes",
    ()=>cryptoKeyToBytes,
    "hexToBytes",
    ()=>hexToBytes,
    "utf8ToBase64",
    ()=>utf8ToBase64
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/utils.js [app-ssr] (ecmascript)");
;
function bytesToHex(bytes) {
    return `0x${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(bytes)}`;
}
function hexToBytes(value) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(value.slice(2));
}
function base64UrlToBytes(base64Url) {
    const base64 = base64UrlToBase64(base64Url);
    const utf8 = base64ToUtf8(base64);
    return Uint8Array.from(utf8, (c)=>c.charCodeAt(0));
}
function bytesToBase64Url(bytes) {
    const base64 = utf8ToBase64(String.fromCharCode(...bytes));
    return base64ToBase64Url(base64);
}
function base64UrlToBase64(base64Url) {
    return base64Url.replaceAll('-', '+').replaceAll('_', '/');
}
function base64ToBase64Url(base64) {
    return base64.replaceAll('+', '-').replaceAll('/', '_').replace(/=+$/, '');
}
function base64ToUtf8(base64) {
    return atob(base64);
}
function utf8ToBase64(base64) {
    return btoa(base64);
}
async function bytesToCryptoKey(bytes) {
    return await crypto.subtle.importKey('spki', bytes, {
        name: 'ECDSA',
        namedCurve: 'P-256',
        hash: 'SHA-256'
    }, true, [
        'verify'
    ]);
}
async function cryptoKeyToBytes(key) {
    return new Uint8Array(await crypto.subtle.exportKey('raw', key));
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/webauthn-p256/_esm/sign.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getCredentialSignRequestOptions",
    ()=>getCredentialSignRequestOptions,
    "parseAsn1Signature",
    ()=>parseAsn1Signature,
    "parseSignature",
    ()=>parseSignature,
    "serializeSignature",
    ()=>serializeSignature,
    "sign",
    ()=>sign
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/curves/esm/abstract/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$p256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/curves/esm/p256.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$webauthn$2d$p256$2f$_esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/webauthn-p256/_esm/utils.js [app-ssr] (ecmascript)");
;
;
;
async function sign(parameters) {
    const { getFn = window.navigator.credentials.get.bind(window.navigator.credentials), ...rest } = parameters;
    const options = getCredentialSignRequestOptions(rest);
    try {
        const credential = await getFn(options);
        if (!credential) throw new Error('credential request failed.');
        const response = credential.response;
        const clientDataJSON = String.fromCharCode(...new Uint8Array(response.clientDataJSON));
        const challengeIndex = clientDataJSON.indexOf('"challenge"');
        const typeIndex = clientDataJSON.indexOf('"type"');
        const signature = parseAsn1Signature((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$webauthn$2d$p256$2f$_esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["base64UrlToBytes"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$webauthn$2d$p256$2f$_esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToBase64Url"])(new Uint8Array(response.signature))));
        return {
            signature: serializeSignature(signature),
            webauthn: {
                authenticatorData: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$webauthn$2d$p256$2f$_esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(new Uint8Array(response.authenticatorData)),
                clientDataJSON,
                challengeIndex,
                typeIndex,
                userVerificationRequired: options.publicKey.userVerification === 'required'
            },
            raw: credential
        };
    } catch (error) {
        throw new Error('credential request failed.', {
            cause: error
        });
    }
}
function getCredentialSignRequestOptions(parameters) {
    const { credentialId, hash, rpId = window.location.hostname, userVerification = 'required' } = parameters;
    const challenge = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$webauthn$2d$p256$2f$_esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["base64UrlToBytes"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$webauthn$2d$p256$2f$_esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToBase64Url"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$webauthn$2d$p256$2f$_esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(hash)));
    return {
        publicKey: {
            ...credentialId ? {
                allowCredentials: [
                    {
                        id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$webauthn$2d$p256$2f$_esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["base64UrlToBytes"])(credentialId),
                        type: 'public-key'
                    }
                ]
            } : {},
            challenge,
            rpId,
            userVerification
        }
    };
}
function parseAsn1Signature(bytes) {
    const r_start = bytes[4] === 0 ? 5 : 4;
    const r_end = r_start + 32;
    const s_start = bytes[r_end + 2] === 0 ? r_end + 3 : r_end + 2;
    const r = BigInt((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$webauthn$2d$p256$2f$_esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(bytes.slice(r_start, r_end)));
    const s = BigInt((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$webauthn$2d$p256$2f$_esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(bytes.slice(s_start)));
    const n = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$p256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p256"].CURVE.n;
    return {
        r,
        s: s > n / 2n ? n - s : s
    };
}
function parseSignature(signature) {
    const bytes = typeof signature === 'string' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$webauthn$2d$p256$2f$_esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(signature) : signature;
    const r = bytes.slice(0, 32);
    const s = bytes.slice(32, 64);
    return {
        r: BigInt((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$webauthn$2d$p256$2f$_esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(r)),
        s: BigInt((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$webauthn$2d$p256$2f$_esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(s))
    };
}
function serializeSignature(signature, options = {}) {
    const { to = 'hex' } = options;
    const result = new Uint8Array([
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["numberToBytesBE"])(signature.r, 32),
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["numberToBytesBE"])(signature.s, 32)
    ]);
    return to === 'hex' ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$webauthn$2d$p256$2f$_esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(result) : result;
} //# sourceMappingURL=sign.js.map
}),
"[project]/node_modules/@metamask/delegation-deployments/dist/index.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CHAIN_ID",
    ()=>CHAIN_ID,
    "DELEGATOR_CONTRACTS",
    ()=>DELEGATOR_CONTRACTS
]);
// src/contractAddresses.ts
var deployments_1_3_0 = {
    DelegationManager: "0xdb9B1e94B5b69Df7e401DDbedE43491141047dB3",
    EntryPoint: "0x0000000071727De22E5E9d8BAf0edAc6f37da032",
    SimpleFactory: "0x69Aa2f9fe1572F1B640E1bbc512f5c3a734fc77c",
    // Implementations
    MultiSigDeleGatorImpl: "0x56a9EdB16a0105eb5a4C54f4C062e2868844f3A7",
    HybridDeleGatorImpl: "0x48dBe696A4D990079e039489bA2053B36E8FFEC4",
    EIP7702StatelessDeleGatorImpl: "0x63c0c19a282a1B52b07dD5a65b58948A07DAE32B",
    // Caveat Enforcers
    AllowedCalldataEnforcer: "0xc2b0d624c1c4319760C96503BA27C347F3260f55",
    AllowedMethodsEnforcer: "0x2c21fD0Cb9DC8445CB3fb0DC5E7Bb0Aca01842B5",
    AllowedTargetsEnforcer: "0x7F20f61b1f09b08D970938F6fa563634d65c4EeB",
    BlockNumberEnforcer: "0x5d9818dF0AE3f66e9c3D0c5029DAF99d1823ca6c",
    DeployedEnforcer: "0x24ff2AA430D53a8CD6788018E902E098083dcCd2",
    ERC20BalanceChangeEnforcer: "0xcdF6aB796408598Cea671d79506d7D48E97a5437",
    ERC20TransferAmountEnforcer: "0xf100b0819427117EcF76Ed94B358B1A5b5C6D2Fc",
    ERC20PeriodTransferEnforcer: "0x474e3Ae7E169e940607cC624Da8A15Eb120139aB",
    ERC20StreamingEnforcer: "0x56c97aE02f233B29fa03502Ecc0457266d9be00e",
    ERC721BalanceChangeEnforcer: "0x8aFdf96eDBbe7e1eD3f5Cd89C7E084841e12A09e",
    ERC721TransferEnforcer: "0x3790e6B7233f779b09DA74C72b6e94813925b9aF",
    ERC1155BalanceChangeEnforcer: "0x63c322732695cAFbbD488Fc6937A0A7B66fC001A",
    ExactCalldataBatchEnforcer: "0x982FD5C86BBF425d7d1451f974192d4525113DfD",
    ExactCalldataEnforcer: "0x99F2e9bF15ce5eC84685604836F71aB835DBBdED",
    ExactExecutionBatchEnforcer: "0x1e141e455d08721Dd5BCDA1BaA6Ea5633Afd5017",
    ExactExecutionEnforcer: "0x146713078D39eCC1F5338309c28405ccf85Abfbb",
    IdEnforcer: "0xC8B5D93463c893401094cc70e66A206fb5987997",
    LimitedCallsEnforcer: "0x04658B29F6b82ed55274221a06Fc97D318E25416",
    NativeBalanceChangeEnforcer: "0xbD7B277507723490Cd50b12EaaFe87C616be6880",
    ArgsEqualityCheckEnforcer: "0x44B8C6ae3C304213c3e298495e12497Ed3E56E41",
    NativeTokenPaymentEnforcer: "0x4803a326ddED6dDBc60e659e5ed12d85c7582811",
    NativeTokenTransferAmountEnforcer: "0xF71af580b9c3078fbc2BBF16FbB8EEd82b330320",
    NativeTokenStreamingEnforcer: "0xD10b97905a320b13a0608f7E9cC506b56747df19",
    NativeTokenPeriodTransferEnforcer: "0x9BC0FAf4Aca5AE429F4c06aEEaC517520CB16BD9",
    NonceEnforcer: "0xDE4f2FAC4B3D87A1d9953Ca5FC09FCa7F366254f",
    OwnershipTransferEnforcer: "0x7EEf9734E7092032B5C56310Eb9BbD1f4A524681",
    RedeemerEnforcer: "0xE144b0b2618071B4E56f746313528a669c7E65c5",
    SpecificActionERC20TransferBatchEnforcer: "0x00e0251aaA263dfE3B3541B758A82D1CBA1c3B6D",
    TimestampEnforcer: "0x1046bb45C8d673d4ea75321280DB34899413c069",
    ValueLteEnforcer: "0x92Bf12322527cAA612fd31a0e810472BBB106A8F",
    MultiTokenPeriodEnforcer: "0xFB2f1a9BD76d3701B730E5d69C3219D42D80eBb7"
};
var deployments_1_1_0 = {
    DelegationManager: "0x56D56e07e3d6Ee5a24e30203A37a0a460f42D7A3",
    EntryPoint: "0x0000000071727De22E5E9d8BAf0edAc6f37da032",
    SimpleFactory: "0x6ff518884f21168c30c58CB21184D6AdBC18Ad90",
    // Implementations
    MultiSigDeleGatorImpl: "0xd1f421EDbA5e3FA9efe3874827114b20C5BEC40C",
    HybridDeleGatorImpl: "0x941f3a016F8726d5643Ce62452d0D78492D42b42",
    // Caveat Enforcers
    AllowedCalldataEnforcer: "0xff71d60f3208469cBCE0859717B5198042DCB3F3",
    AllowedMethodsEnforcer: "0xe32C2561792e8446Abe73B9f557B881C13906186",
    AllowedTargetsEnforcer: "0x06aaE4c67EEA95277c46Bf79b1583d4a01772D22",
    BlockNumberEnforcer: "0x8E470D2Ae278457b42d2405E0B8Cd4BE21Ed9045",
    DeployedEnforcer: "0xf9088f013dBD9ebb7Cebd66fEB48253c6Ac5a820",
    ERC20BalanceGteEnforcer: "0xB7B6f32ec6343261D814e55Ed8C5925d91Cab861",
    ERC20TransferAmountEnforcer: "0x9A069b18032B31429A363AeCFb1B6A0564b44471",
    IdEnforcer: "0x91015c3b9D9523966eD2399885e5Df7A567f916c",
    LimitedCallsEnforcer: "0xe694bFfffEA3E85923b1210b37e6a0175e910863",
    NonceEnforcer: "0xE83BCFD8bBE672A96747e831050a91cf44F4F87A",
    TimestampEnforcer: "0x550FdD13eEBC1f22ea2a2480024BacBF0Ad7e5CE",
    ValueLteEnforcer: "0xBE32a6DB7471F63BB168C088c57Db01AfAe87967",
    NativeTokenTransferAmountEnforcer: "0x5eD3833d7B957A8DB8A461c3AF2d668Ec25382E0",
    NativeBalanceGteEnforcer: "0x376a98860E210DdEda3689fb39565592c563cB0A",
    ArgsEqualityCheckEnforcer: "0x7378dE585998d3E18Ce147867C335C25B3dB8Ee5",
    NativeTokenPaymentEnforcer: "0x87Fe18EbF99e42fcE8A03a25F1d20E119407f8e7",
    RedeemerEnforcer: "0x926672b130D1EF60A9d6b11D2048d121b30f40C1"
};
var deployments_1_0_0 = {
    DelegationManager: "0xbe4138886cb096bdc1b930f2f0ca7892aa234d78",
    EntryPoint: "0x0000000071727De22E5E9d8BAf0edAc6f37da032",
    SimpleFactory: "0x6ff518884f21168c30c58CB21184D6AdBC18Ad90",
    // Implementations
    MultiSigDeleGatorImpl: "0x11f555af5844d85bfcf5d61d2a22866527eb585a",
    HybridDeleGatorImpl: "0xd6edd1256deccb2b06bdecef92dc16bcf26e531b",
    // Caveat Enforcers
    AllowedCalldataEnforcer: "0x48db3835a873d64a4af2c09f014052407c003bd7",
    AllowedMethodsEnforcer: "0xfd731951bf1c52afccee3e6f14ab656475b76dd4",
    AllowedTargetsEnforcer: "0xbc8673c0afa52d86d991c06881e55b2966920564",
    BlockNumberEnforcer: "0xc15faffa0d879b9263c15a46ce31eacfa2e0e8ae",
    DeployedEnforcer: "0x5accb9559b56a6c1e3f90e342c85c42d93720d43",
    ERC20BalanceGteEnforcer: "0xb5d6b1ec6d868a3bae5b7f48178eaa2686a7a087",
    ERC20TransferAmountEnforcer: "0x92ac423b9c111962179a6242e1adb58d02c103be",
    IdEnforcer: "0x34152d9f3f8f74338d50703e780389e829b4abac",
    LimitedCallsEnforcer: "0x4b3adad4a328bee8ba17b86074d92fe7372180cd",
    NonceEnforcer: "0x2f32ff3fc3086d7f63f16fe8d0065390d460b40d",
    TimestampEnforcer: "0x78e05f779490c24bf3bfa135b4112e7003b321cd",
    ValueLteEnforcer: "0xfc20ede0a1132e839fbda9d7ed3904ff3c89540f"
};
// src/index.ts
var CHAIN_ID = {
    // Mainnets
    mainnet: 1,
    optimism: 10,
    bsc: 56,
    gnosis: 100,
    polygon: 137,
    base: 8453,
    arbitrum: 42161,
    linea: 59144,
    berachain: 80094,
    unichain: 130,
    arbitrumNova: 42170,
    // Testnets
    bscTestnet: 97,
    megaEthTestnet: 6342,
    chiado: 10200,
    lineaSepolia: 59141,
    berachainBepolia: 80069,
    baseSepolia: 84532,
    arbitrumSepolia: 421614,
    sepolia: 11155111,
    optimismSepolia: 11155420,
    unichainSepolia: 1301,
    polygonAmoy: 80002,
    monadTestnet: 10143,
    // decommissioned
    lineaGoerli: 59140
};
var DELEGATOR_CONTRACTS = {
    "1.0.0": {
        // Mainnets
        [CHAIN_ID.optimism]: deployments_1_0_0,
        [CHAIN_ID.polygon]: deployments_1_0_0,
        [CHAIN_ID.base]: deployments_1_0_0,
        [CHAIN_ID.arbitrum]: deployments_1_0_0,
        [CHAIN_ID.linea]: deployments_1_0_0,
        // Testnets
        [CHAIN_ID.sepolia]: {
            ...deployments_1_0_0,
            HybridDeleGatorImpl: "0x5989F5D13DF8fc818EdA65e417AED90459fD67F7"
        },
        [CHAIN_ID.lineaSepolia]: {
            ...deployments_1_0_0,
            HybridDeleGatorImpl: "0x5989F5D13DF8fc818EdA65e417AED90459fD67F7"
        }
    },
    "1.1.0": {
        // Mainnets
        [CHAIN_ID.arbitrum]: deployments_1_1_0,
        [CHAIN_ID.base]: deployments_1_1_0,
        [CHAIN_ID.linea]: deployments_1_1_0,
        [CHAIN_ID.optimism]: deployments_1_1_0,
        [CHAIN_ID.polygon]: deployments_1_1_0,
        // Testnets
        [CHAIN_ID.sepolia]: deployments_1_1_0,
        [CHAIN_ID.lineaSepolia]: deployments_1_1_0,
        [CHAIN_ID.baseSepolia]: {
            ...deployments_1_1_0,
            SimpleFactory: "0xE8eA1DE8D6AfE400B7C8C1A81B7C29B7876b4d02"
        }
    },
    "1.3.0": {
        // Mainnets
        [CHAIN_ID.mainnet]: deployments_1_3_0,
        [CHAIN_ID.polygon]: deployments_1_3_0,
        [CHAIN_ID.bsc]: deployments_1_3_0,
        [CHAIN_ID.optimism]: deployments_1_3_0,
        [CHAIN_ID.arbitrum]: deployments_1_3_0,
        [CHAIN_ID.linea]: deployments_1_3_0,
        [CHAIN_ID.base]: deployments_1_3_0,
        [CHAIN_ID.gnosis]: deployments_1_3_0,
        [CHAIN_ID.berachain]: deployments_1_3_0,
        [CHAIN_ID.unichain]: deployments_1_3_0,
        [CHAIN_ID.arbitrumNova]: deployments_1_3_0,
        // Testnets
        [CHAIN_ID.sepolia]: deployments_1_3_0,
        [CHAIN_ID.lineaSepolia]: deployments_1_3_0,
        [CHAIN_ID.baseSepolia]: deployments_1_3_0,
        [CHAIN_ID.megaEthTestnet]: deployments_1_3_0,
        [CHAIN_ID.chiado]: deployments_1_3_0,
        [CHAIN_ID.bscTestnet]: deployments_1_3_0,
        [CHAIN_ID.optimismSepolia]: deployments_1_3_0,
        [CHAIN_ID.arbitrumSepolia]: deployments_1_3_0,
        [CHAIN_ID.berachainBepolia]: deployments_1_3_0,
        [CHAIN_ID.unichainSepolia]: deployments_1_3_0,
        [CHAIN_ID.polygonAmoy]: deployments_1_3_0,
        [CHAIN_ID.monadTestnet]: deployments_1_3_0
    }
};
;
 //# sourceMappingURL=index.mjs.map
}),
];

//# sourceMappingURL=node_modules_da12ec4a._.js.map