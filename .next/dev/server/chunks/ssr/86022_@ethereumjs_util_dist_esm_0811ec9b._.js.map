{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/errors.js","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40web3auth/no-modal/node_modules/%40ethereumjs/util/src/errors.ts"],"sourcesContent":["import {\n  DEFAULT_ERROR_CODE,\n  EthereumJSError,\n  type EthereumJSErrorMetaData,\n  type EthereumJSErrorObject,\n  EthereumJSErrorWithoutCode,\n} from '@ethereumjs/rlp'\n\nexport {\n  DEFAULT_ERROR_CODE,\n  EthereumJSError,\n  EthereumJSErrorWithoutCode,\n  type EthereumJSErrorMetaData,\n  type EthereumJSErrorObject,\n}\n\n// Below here: specific monorepo-wide errors (examples and commented out)\n\n/*export enum UsageErrorType {\n  UNSUPPORTED_FEATURE = 'unsupported feature',\n}*\n\n/**\n * Error along API Usage\n *\n * Use directly or in a subclassed context for error comparison (`e instanceof UsageError`)\n */\n//export class UsageError extends EthereumJSError<{ code: UsageErrorType }> {}\n"],"names":[],"mappings":";;AAAA,OAAO,EACL,kBAAkB,EAClB,eAAe,EAGf,0BAA0B,GAC3B,MAAM,iBAAiB,CAAA;;;CAUxB,yEAAyE;CAEzE;;;;;;;;GAQG,EACH,8EAA8E"}},
    {"offset": {"line": 24, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/internal.js","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40web3auth/no-modal/node_modules/%40ethereumjs/util/src/internal.ts"],"sourcesContent":["/*\nThe MIT License\n\nCopyright (c) 2016 Nick Dodson. nickdodson.com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE\n */\n\nimport { bytesToUnprefixedHex, utf8ToBytes } from './bytes.ts'\nimport { EthereumJSErrorWithoutCode } from './errors.ts'\n\nimport type { PrefixedHexString } from './types.ts'\n\n/**\n * Returns a boolean on whether or not the the input starts with '0x' and matches the optional length\n * @param {string} value the string input value\n * @param {number|undefined} length the optional length of the hex string in bytes\n * @returns {boolean} Whether or not the string is a valid PrefixedHexString matching the optional length\n */\nexport function isHexString(value: string, length?: number): value is PrefixedHexString {\n  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) return false\n\n  if (typeof length !== 'undefined' && length > 0 && value.length !== 2 + 2 * length) return false\n\n  return true\n}\n\n/**\n * Removes '0x' from a given `String` if present\n * @param str the string value\n * @returns the string without 0x prefix\n */\nexport const stripHexPrefix = (str: string): string => {\n  if (typeof str !== 'string')\n    throw EthereumJSErrorWithoutCode(\n      `[stripHexPrefix] input must be type 'string', received ${typeof str}`,\n    )\n\n  return isHexString(str) ? str.slice(2) : str\n}\n\n/**\n * Pads a `String` to have an even length\n * @param value\n * @return output\n */\nexport function padToEven(value: string): string {\n  let a = value\n\n  if (typeof a !== 'string') {\n    throw EthereumJSErrorWithoutCode(\n      `[padToEven] value must be type 'string', received ${typeof a}`,\n    )\n  }\n\n  if (a.length % 2) a = `0${a}`\n\n  return a\n}\n\n/**\n * Get the binary size of a string\n * @param str\n * @returns the number of bytes contained within the string\n */\nexport function getBinarySize(str: string) {\n  if (typeof str !== 'string') {\n    throw EthereumJSErrorWithoutCode(\n      `[getBinarySize] method requires input type 'string', received ${typeof str}`,\n    )\n  }\n\n  return utf8ToBytes(str).byteLength\n}\n\n/**\n * Returns TRUE if the first specified array contains all elements\n * from the second one. FALSE otherwise.\n *\n * @param superset\n * @param subset\n *\n */\nexport function arrayContainsArray(\n  superset: unknown[],\n  subset: unknown[],\n  some?: boolean,\n): boolean {\n  if (Array.isArray(superset) !== true) {\n    throw EthereumJSErrorWithoutCode(\n      `[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof superset}'`,\n    )\n  }\n  if (Array.isArray(subset) !== true) {\n    throw EthereumJSErrorWithoutCode(\n      `[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof subset}'`,\n    )\n  }\n\n  return subset[some === true ? 'some' : 'every']((value) => superset.indexOf(value) >= 0)\n}\n\n/**\n * Should be called to get ascii from its hex representation\n *\n * @param string in hex\n * @returns ascii string representation of hex value\n */\nexport function toAscii(hex: string): string {\n  let str = ''\n  let i = 0\n  const l = hex.length\n\n  if (hex.substring(0, 2) === '0x') i = 2\n\n  for (; i < l; i += 2) {\n    const code = parseInt(hex.substr(i, 2), 16)\n    str += String.fromCharCode(code)\n  }\n\n  return str\n}\n\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string.\n * Strips leading and trailing 0's.\n *\n * @param string\n * @param optional padding\n * @returns hex representation of input string\n */\nexport function fromUtf8(stringValue: string) {\n  const str = utf8ToBytes(stringValue)\n\n  return `0x${padToEven(bytesToUnprefixedHex(str)).replace(/^0+|0+$/g, '')}`\n}\n\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n *\n * @param  string\n * @param  optional padding\n * @returns  hex representation of input string\n */\nexport function fromAscii(stringValue: string) {\n  let hex = ''\n  for (let i = 0; i < stringValue.length; i++) {\n    const code = stringValue.charCodeAt(i)\n    const n = code.toString(16)\n    hex += n.length < 2 ? `0${n}` : n\n  }\n\n  return `0x${hex}`\n}\n\n/**\n * Returns the keys from an array of objects.\n * @example\n * ```js\n * getKeys([{a: '1', b: '2'}, {a: '3', b: '4'}], 'a') => ['1', '3']\n *````\n * @param  params\n * @param  key\n * @param  allowEmpty\n * @returns output just a simple array of output keys\n */\nexport function getKeys(params: Record<string, string>[], key: string, allowEmpty?: boolean) {\n  if (!Array.isArray(params)) {\n    throw EthereumJSErrorWithoutCode(\n      `[getKeys] method expects input 'params' to be an array, got ${typeof params}`,\n    )\n  }\n  if (typeof key !== 'string') {\n    throw EthereumJSErrorWithoutCode(\n      `[getKeys] method expects input 'key' to be type 'string', got ${typeof params}`,\n    )\n  }\n\n  const result = []\n\n  for (let i = 0; i < params.length; i++) {\n    let value = params[i][key]\n    if (allowEmpty === true && !value) {\n      value = ''\n    } else if (typeof value !== 'string') {\n      throw EthereumJSErrorWithoutCode(\n        `invalid abi - expected type 'string', received ${typeof value}`,\n      )\n    }\n    result.push(value)\n  }\n\n  return result\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 151, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/helpers.js","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40web3auth/no-modal/node_modules/%40ethereumjs/util/src/helpers.ts"],"sourcesContent":["import { EthereumJSErrorWithoutCode } from './errors.ts'\nimport { isHexString } from './internal.ts'\n\n/**\n * Throws if a string is not hex prefixed\n * @param {string} input string to check hex prefix of\n */\nexport const assertIsHexString = function (input: string): void {\n  if (!isHexString(input)) {\n    const msg = `This method only supports 0x-prefixed hex strings but input was: ${input}`\n    throw EthereumJSErrorWithoutCode(msg)\n  }\n}\n\n/**\n * Throws if input is not a buffer\n * @param {Buffer} input value to check\n */\nexport const assertIsBytes = function (input: Uint8Array): void {\n  if (!(input instanceof Uint8Array)) {\n    const msg = `This method only supports Uint8Array but input was: ${input}`\n    throw EthereumJSErrorWithoutCode(msg)\n  }\n}\n\n/**\n * Throws if input is not an array\n * @param {number[]} input value to check\n */\nexport const assertIsArray = function (input: number[]): void {\n  if (!Array.isArray(input)) {\n    const msg = `This method only supports number arrays but input was: ${input}`\n    throw EthereumJSErrorWithoutCode(msg)\n  }\n}\n\n/**\n * Throws if input is not a string\n * @param {string} input value to check\n */\nexport const assertIsString = function (input: string): void {\n  if (typeof input !== 'string') {\n    const msg = `This method only supports strings but input was: ${input}`\n    throw EthereumJSErrorWithoutCode(msg)\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAAA,OAAO,EAAE,0BAA0B,EAAE,MAAM,aAAa,CAAA;AACxD,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAA;;;AAMpC,MAAM,iBAAiB,GAAG,SAAU,KAAa;IACtD,IAAI,KAAC,2NAAW,EAAC,KAAK,CAAC,EAAE,CAAC;QACxB,MAAM,GAAG,GAAG,CAAA,iEAAA,EAAoE,KAAK,EAAE,CAAA;QACvF,UAAM,uOAA0B,EAAC,GAAG,CAAC,CAAA;IACvC,CAAC;AACH,CAAC,CAAA;AAMM,MAAM,aAAa,GAAG,SAAU,KAAiB;IACtD,IAAI,CAAC,CAAC,KAAK,YAAY,UAAU,CAAC,EAAE,CAAC;QACnC,MAAM,GAAG,GAAG,CAAA,oDAAA,EAAuD,KAAK,EAAE,CAAA;QAC1E,UAAM,uOAA0B,EAAC,GAAG,CAAC,CAAA;IACvC,CAAC;AACH,CAAC,CAAA;AAMM,MAAM,aAAa,GAAG,SAAU,KAAe;IACpD,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;QAC1B,MAAM,GAAG,GAAG,CAAA,uDAAA,EAA0D,KAAK,EAAE,CAAA;QAC7E,UAAM,uOAA0B,EAAC,GAAG,CAAC,CAAA;IACvC,CAAC;AACH,CAAC,CAAA;AAMM,MAAM,cAAc,GAAG,SAAU,KAAa;IACnD,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;QAC9B,MAAM,GAAG,GAAG,CAAA,iDAAA,EAAoD,KAAK,EAAE,CAAA;QACvE,UAAM,uOAA0B,EAAC,GAAG,CAAC,CAAA;IACvC,CAAC;AACH,CAAC,CAAA"}},
    {"offset": {"line": 194, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/bytes.js","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40web3auth/no-modal/node_modules/%40ethereumjs/util/src/bytes.ts"],"sourcesContent":["import { getRandomBytesSync } from 'ethereum-cryptography/random.js'\n\nimport {\n  bytesToHex as _bytesToUnprefixedHex,\n  hexToBytes as nobleH2B,\n} from 'ethereum-cryptography/utils.js'\n\nimport { EthereumJSErrorWithoutCode } from './errors.ts'\nimport { assertIsArray, assertIsBytes, assertIsHexString } from './helpers.ts'\nimport { isHexString, padToEven, stripHexPrefix } from './internal.ts'\n\nimport type { PrefixedHexString, TransformableToBytes } from './types.ts'\n\nconst BIGINT_0 = BigInt(0)\n\n/**\n * @deprecated\n */\nexport const bytesToUnprefixedHex = _bytesToUnprefixedHex\n\n/**\n * Converts a {@link PrefixedHexString} to a {@link Uint8Array}\n * @param {PrefixedHexString} hex The 0x-prefixed hex string to convert\n * @returns {Uint8Array} The converted bytes\n * @throws If the input is not a valid 0x-prefixed hex string\n */\nexport const hexToBytes = (hex: PrefixedHexString): Uint8Array => {\n  if (!hex.startsWith('0x')) throw EthereumJSErrorWithoutCode('input string must be 0x prefixed')\n  return nobleH2B(padToEven(stripHexPrefix(hex)))\n}\n\nexport const unprefixedHexToBytes = (hex: string): Uint8Array => {\n  if (hex.startsWith('0x')) throw EthereumJSErrorWithoutCode('input string cannot be 0x prefixed')\n  return nobleH2B(padToEven(hex))\n}\n\n/**\n * Converts a {@link Uint8Array} to a {@link PrefixedHexString}\n * @param {Uint8Array} bytes the bytes to convert\n * @returns {PrefixedHexString} the hex string\n * @dev Returns `0x` if provided an empty Uint8Array\n */\nexport const bytesToHex = (bytes: Uint8Array): PrefixedHexString => {\n  const unprefixedHex = bytesToUnprefixedHex(bytes)\n  return `0x${unprefixedHex}`\n}\n\n// BigInt cache for the numbers 0 - 256*256-1 (two-byte bytes)\nconst BIGINT_CACHE: bigint[] = []\nfor (let i = 0; i <= 256 * 256 - 1; i++) {\n  BIGINT_CACHE[i] = BigInt(i)\n}\n\n/**\n * Converts a {@link Uint8Array} to a {@link bigint}\n * @param {Uint8Array} bytes the bytes to convert\n * @returns {bigint}\n */\nexport const bytesToBigInt = (bytes: Uint8Array, littleEndian = false): bigint => {\n  if (littleEndian) {\n    bytes.reverse()\n  }\n  const hex = bytesToHex(bytes)\n  if (hex === '0x') {\n    return BIGINT_0\n  }\n  if (hex.length === 4) {\n    // If the byte length is 1 (this is faster than checking `bytes.length === 1`)\n    return BIGINT_CACHE[bytes[0]]\n  }\n  if (hex.length === 6) {\n    return BIGINT_CACHE[bytes[0] * 256 + bytes[1]]\n  }\n  return BigInt(hex)\n}\n\n/**\n * Converts a {@link Uint8Array} to a {@link number}.\n * @param {Uint8Array} bytes the bytes to convert\n * @return  {number}\n * @throws If the input number exceeds 53 bits.\n */\nexport const bytesToInt = (bytes: Uint8Array): number => {\n  const res = Number(bytesToBigInt(bytes))\n  if (!Number.isSafeInteger(res)) throw EthereumJSErrorWithoutCode('Number exceeds 53 bits')\n  return res\n}\n\n/******************************************/\n\n/**\n * Converts a {@link number} into a {@link PrefixedHexString}\n * @param {number} i\n * @return {PrefixedHexString}\n */\nexport const intToHex = (i: number): PrefixedHexString => {\n  if (!Number.isSafeInteger(i) || i < 0) {\n    throw EthereumJSErrorWithoutCode(`Received an invalid integer type: ${i}`)\n  }\n  return `0x${i.toString(16)}`\n}\n\n/**\n * Converts an {@link number} to a {@link Uint8Array}\n * @param {Number} i\n * @return {Uint8Array}\n */\nexport const intToBytes = (i: number): Uint8Array => {\n  const hex = intToHex(i)\n  return hexToBytes(hex)\n}\n\n/**\n * Converts a {@link bigint} to a {@link Uint8Array}\n *  * @param {bigint} num the bigint to convert\n * @returns {Uint8Array}\n */\nexport const bigIntToBytes = (num: bigint, littleEndian = false): Uint8Array => {\n  const bytes = hexToBytes(`0x${padToEven(num.toString(16))}`)\n\n  return littleEndian ? bytes.reverse() : bytes\n}\n\n/**\n * Pads a `Uint8Array` with zeros till it has `length` bytes.\n * Truncates the beginning or end of input if its length exceeds `length`.\n * @param {Uint8Array} msg the value to pad\n * @param {number} length the number of bytes the output should be\n * @param {boolean} right whether to start padding form the left or right\n * @return {Uint8Array}\n */\nconst setLength = (msg: Uint8Array, length: number, right: boolean): Uint8Array => {\n  if (right) {\n    if (msg.length < length) {\n      return new Uint8Array([...msg, ...new Uint8Array(length - msg.length)])\n    }\n    return msg.subarray(0, length)\n  } else {\n    if (msg.length < length) {\n      return new Uint8Array([...new Uint8Array(length - msg.length), ...msg])\n    }\n    return msg.subarray(-length)\n  }\n}\n\n/**\n * Left Pads a `Uint8Array` with leading zeros till it has `length` bytes.\n * Or it truncates the beginning if it exceeds.\n * @param {Uint8Array} msg the value to pad\n * @param {number} length the number of bytes the output should be\n * @return {Uint8Array}\n */\nexport const setLengthLeft = (msg: Uint8Array, length: number): Uint8Array => {\n  assertIsBytes(msg)\n  return setLength(msg, length, false)\n}\n\n/**\n * Right Pads a `Uint8Array` with trailing zeros till it has `length` bytes.\n * it truncates the end if it exceeds.\n * @param {Uint8Array} msg the value to pad\n * @param {number} length the number of bytes the output should be\n * @return {Uint8Array}\n */\nexport const setLengthRight = (msg: Uint8Array, length: number): Uint8Array => {\n  assertIsBytes(msg)\n  return setLength(msg, length, true)\n}\n\n/**\n * Trims leading zeros from a `Uint8Array`, `number[]` or `string`.\n * @param {Uint8Array|number[]|string} a\n * @return {Uint8Array|number[]|string}\n */\nconst stripZeros = <T extends Uint8Array | number[] | string = Uint8Array | number[] | string>(\n  a: T,\n): T => {\n  let first = a[0]\n  while (a.length > 0 && first.toString() === '0') {\n    a = a.slice(1) as T\n    first = a[0]\n  }\n  return a\n}\n\n/**\n * Trims leading zeros from a `Uint8Array`.\n * @param {Uint8Array} a\n * @return {Uint8Array}\n */\nexport const unpadBytes = (a: Uint8Array): Uint8Array => {\n  assertIsBytes(a)\n  return stripZeros(a)\n}\n\n/**\n * Trims leading zeros from an `Array` (of numbers).\n * @param  {number[]} a\n * @return {number[]}\n */\nexport const unpadArray = (a: number[]): number[] => {\n  assertIsArray(a)\n  return stripZeros(a)\n}\n\n/**\n * Trims leading zeros from a `PrefixedHexString`.\n * @param {PrefixedHexString} a\n * @return {PrefixedHexString}\n */\nexport const unpadHex = (a: PrefixedHexString): PrefixedHexString => {\n  assertIsHexString(a)\n  return `0x${stripZeros(stripHexPrefix(a))}`\n}\n\nexport type ToBytesInputTypes =\n  | PrefixedHexString\n  | number\n  | bigint\n  | Uint8Array\n  | number[]\n  | TransformableToBytes\n  | null\n  | undefined\n\n/**\n * Attempts to turn a value into a `Uint8Array`.\n * Inputs supported: `Buffer`, `Uint8Array`, `String` (hex-prefixed), `Number`, null/undefined, `BigInt` and other objects\n * with a `toArray()` or `toBytes()` method.\n * @param {ToBytesInputTypes} v the value\n * @return {Uint8Array}\n */\n\nexport const toBytes = (v: ToBytesInputTypes): Uint8Array => {\n  if (v === null || v === undefined) {\n    return new Uint8Array()\n  }\n\n  if (Array.isArray(v) || v instanceof Uint8Array) {\n    return Uint8Array.from(v)\n  }\n\n  if (typeof v === 'string') {\n    if (!isHexString(v)) {\n      throw EthereumJSErrorWithoutCode(\n        `Cannot convert string to Uint8Array. toBytes only supports 0x-prefixed hex strings and this string was given: ${v}`,\n      )\n    }\n    return hexToBytes(v)\n  }\n\n  if (typeof v === 'number') {\n    return intToBytes(v)\n  }\n\n  if (typeof v === 'bigint') {\n    if (v < BIGINT_0) {\n      throw EthereumJSErrorWithoutCode(`Cannot convert negative bigint to Uint8Array. Given: ${v}`)\n    }\n    let n = v.toString(16)\n    if (n.length % 2) n = '0' + n\n    return unprefixedHexToBytes(n)\n  }\n\n  if (v.toBytes !== undefined) {\n    // converts a `TransformableToBytes` object to a Uint8Array\n    return v.toBytes()\n  }\n\n  throw EthereumJSErrorWithoutCode('invalid type')\n}\n\n/**\n * Interprets a `Uint8Array` as a signed integer and returns a `BigInt`. Assumes 256-bit numbers.\n * @param {Uint8Array} num Signed integer value\n * @returns {bigint}\n */\nexport const fromSigned = (num: Uint8Array): bigint => {\n  return BigInt.asIntN(256, bytesToBigInt(num))\n}\n\n/**\n * Converts a `BigInt` to an unsigned integer and returns it as a `Uint8Array`. Assumes 256-bit numbers.\n * @param {bigint} num\n * @returns {Uint8Array}\n */\nexport const toUnsigned = (num: bigint): Uint8Array => {\n  return bigIntToBytes(BigInt.asUintN(256, num))\n}\n\n/**\n * Adds \"0x\" to a given `string` if it does not already start with \"0x\".\n * @param {string} str\n * @return {PrefixedHexString}\n */\nexport const addHexPrefix = (str: string): PrefixedHexString => {\n  if (typeof str !== 'string') {\n    return str\n  }\n\n  return isHexString(str) ? str : `0x${str}`\n}\n\n/**\n * Shortens a string  or Uint8Array's hex string representation to maxLength (default 50).\n *\n * Examples:\n *\n * Input:  '657468657265756d000000000000000000000000000000000000000000000000'\n * Output: '657468657265756d0000000000000000000000000000000000…'\n * @param {Uint8Array | string} bytes\n * @param {number} maxLength\n * @return {string}\n */\nexport const short = (bytes: Uint8Array | string, maxLength: number = 50): string => {\n  const byteStr = bytes instanceof Uint8Array ? bytesToHex(bytes) : bytes\n  const len = byteStr.slice(0, 2) === '0x' ? maxLength + 2 : maxLength\n  if (byteStr.length <= len) {\n    return byteStr\n  }\n  return byteStr.slice(0, len) + '…'\n}\n\n/**\n * Checks provided Uint8Array for leading zeroes and throws if found.\n *\n * Examples:\n *\n * Valid values: 0x1, 0x, 0x01, 0x1234\n * Invalid values: 0x0, 0x00, 0x001, 0x0001\n *\n * Note: This method is useful for validating that RLP encoded integers comply with the rule that all\n * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes\n * @param values An object containing string keys and Uint8Array values\n * @throws if any provided value is found to have leading zero bytes\n */\nexport const validateNoLeadingZeroes = (values: { [key: string]: Uint8Array | undefined }) => {\n  for (const [k, v] of Object.entries(values)) {\n    if (v !== undefined && v.length > 0 && v[0] === 0) {\n      throw EthereumJSErrorWithoutCode(\n        `${k} cannot have leading zeroes, received: ${bytesToHex(v)}`,\n      )\n    }\n  }\n}\n\n/**\n * Converts a {@link bigint} to a `0x` prefixed hex string\n * @param {bigint} num the bigint to convert\n * @returns {PrefixedHexString}\n */\nexport const bigIntToHex = (num: bigint): PrefixedHexString => {\n  return `0x${num.toString(16)}`\n}\n\n/**\n * Calculates max bigint from an array of bigints\n * @param args array of bigints\n */\nexport const bigIntMax = (...args: bigint[]) => args.reduce((m, e) => (e > m ? e : m))\n\n/**\n * Calculates min BigInt from an array of BigInts\n * @param args array of bigints\n */\nexport const bigIntMin = (...args: bigint[]) => args.reduce((m, e) => (e < m ? e : m))\n\n/**\n * Convert value from bigint to an unpadded Uint8Array\n * (useful for RLP transport)\n * @param {bigint} value the bigint to convert\n * @returns {Uint8Array}\n */\nexport const bigIntToUnpaddedBytes = (value: bigint): Uint8Array => {\n  return unpadBytes(bigIntToBytes(value))\n}\n\nexport const bigIntToAddressBytes = (value: bigint, strict: boolean = true): Uint8Array => {\n  const addressBytes = bigIntToBytes(value)\n  if (strict && addressBytes.length > 20) {\n    throw Error(`Invalid address bytes length=${addressBytes.length} strict=${strict}`)\n  }\n\n  // setLength already slices if more than requisite length\n  return setLengthLeft(addressBytes, 20)\n}\n\n/**\n * Convert value from number to an unpadded Uint8Array\n * (useful for RLP transport)\n * @param {number} value the bigint to convert\n * @returns {Uint8Array}\n */\nexport const intToUnpaddedBytes = (value: number): Uint8Array => {\n  return unpadBytes(intToBytes(value))\n}\n\n/**\n * Compares two Uint8Arrays and returns a number indicating their order in a sorted array.\n *\n * @param {Uint8Array} value1 - The first Uint8Array to compare.\n * @param {Uint8Array} value2 - The second Uint8Array to compare.\n * @returns {number} A positive number if value1 is larger than value2,\n *                   A negative number if value1 is smaller than value2,\n *                   or 0 if value1 and value2 are equal.\n */\nexport const compareBytes = (value1: Uint8Array, value2: Uint8Array): number => {\n  const bigIntValue1 = bytesToBigInt(value1)\n  const bigIntValue2 = bytesToBigInt(value2)\n  return bigIntValue1 > bigIntValue2 ? 1 : bigIntValue1 < bigIntValue2 ? -1 : 0\n}\n\n/**\n * Generates a Uint8Array of random bytes of specified length.\n *\n * @param {number} length - The length of the Uint8Array.\n * @returns {Uint8Array} A Uint8Array of random bytes of specified length.\n */\nexport const randomBytes = (length: number): Uint8Array => {\n  return getRandomBytesSync(length)\n}\n\n/**\n * This mirrors the functionality of the `ethereum-cryptography` export except\n * it skips the check to validate that every element of `arrays` is indeed a `uint8Array`\n * Can give small performance gains on large arrays\n * @param {Uint8Array[]} arrays an array of Uint8Arrays\n * @returns {Uint8Array} one Uint8Array with all the elements of the original set\n * works like `Buffer.concat`\n */\nexport const concatBytes = (...arrays: Uint8Array[]): Uint8Array<ArrayBuffer> => {\n  if (arrays.length === 1) return arrays[0] as Uint8Array<ArrayBuffer>\n  const length = arrays.reduce((a, arr) => a + arr.length, 0)\n  const result = new Uint8Array(length) as Uint8Array<ArrayBuffer>\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i]\n    result.set(arr, pad)\n    pad += arr.length\n  }\n  return result\n}\n\n/**\n * @notice Convert a Uint8Array to a 32-bit integer\n * @param {Uint8Array} bytes The input Uint8Array from which to read the 32-bit integer.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {number} The 32-bit integer read from the input Uint8Array.\n */\nexport function bytesToInt32(bytes: Uint8Array, littleEndian: boolean = false): number {\n  if (bytes.length < 4) {\n    bytes = setLength(bytes, 4, littleEndian)\n  }\n  const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  return dataView.getUint32(0, littleEndian)\n}\n\n/**\n * @notice Convert a Uint8Array to a 64-bit bigint\n * @param {Uint8Array} bytes The input Uint8Array from which to read the 64-bit bigint.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {bigint} The 64-bit bigint read from the input Uint8Array.\n */\nexport function bytesToBigInt64(bytes: Uint8Array, littleEndian: boolean = false): bigint {\n  if (bytes.length < 8) {\n    bytes = setLength(bytes, 8, littleEndian)\n  }\n  const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  return dataView.getBigUint64(0, littleEndian)\n}\n\n/**\n * @notice Convert a 32-bit integer to a Uint8Array.\n * @param {number} value The 32-bit integer to convert.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {Uint8Array} A Uint8Array of length 4 containing the integer.\n */\nexport function int32ToBytes(value: number, littleEndian: boolean = false): Uint8Array {\n  const buffer = new ArrayBuffer(4)\n  const dataView = new DataView(buffer)\n  dataView.setUint32(0, value, littleEndian)\n  return new Uint8Array(buffer)\n}\n\n/**\n * @notice Convert a 64-bit bigint to a Uint8Array.\n * @param {bigint} value The 64-bit bigint to convert.\n * @param {boolean} littleEndian True for little-endian, undefined or false for big-endian.\n * @return {Uint8Array} A Uint8Array of length 8 containing the bigint.\n */\nexport function bigInt64ToBytes(value: bigint, littleEndian: boolean = false): Uint8Array {\n  const buffer = new ArrayBuffer(8)\n  const dataView = new DataView(buffer)\n  dataView.setBigUint64(0, value, littleEndian)\n  return new Uint8Array(buffer)\n}\n\nexport { bytesToUtf8, equalsBytes, utf8ToBytes } from 'ethereum-cryptography/utils.js'\n\nexport function hexToBigInt(input: PrefixedHexString): bigint {\n  return bytesToBigInt(hexToBytes(isHexString(input) ? input : `0x${input}`))\n}\n\n/**\n * Converts a Uint8Array of bytes into an array of bits.\n * @param {Uint8Array} bytes - The input byte array.\n * @param {number} bitLength - The number of bits to extract from the input bytes.\n * @returns {number[]} An array of bits (each 0 or 1) corresponding to the input bytes.\n */\nexport function bytesToBits(bytes: Uint8Array, bitLength?: number): number[] {\n  const bits: number[] = []\n\n  for (let i = 0; i < (bitLength ?? bytes.length * 8); i++) {\n    const byteIndex = Math.floor(i / 8)\n    const bitIndex = 7 - (i % 8)\n    bits.push((bytes[byteIndex] >> bitIndex) & 1)\n  }\n\n  return bits\n}\n\n/**\n * Converts an array of bits into a Uint8Array.\n * The input bits are grouped into sets of 8, with the first bit in each group being the most significant.\n * @param {number[]} bits - The input array of bits (each should be 0 or 1). Its length should be a multiple of 8.\n * @returns {Uint8Array} A Uint8Array constructed from the input bits.\n */\nexport function bitsToBytes(bits: number[]): Uint8Array {\n  const numBytes = Math.ceil(bits.length / 8) // Ensure partial byte storage\n  const byteData = new Uint8Array(numBytes)\n\n  for (let i = 0; i < bits.length; i++) {\n    const byteIndex = Math.floor(i / 8)\n    const bitIndex = 7 - (i % 8)\n    byteData[byteIndex] |= bits[i] << bitIndex\n  }\n\n  return byteData\n}\n\n/**\n * Compares two byte arrays and returns the count of consecutively matching items from the start.\n * @param {Uint8Array} bytes1 - The first Uint8Array to compare.\n * @param {Uint8Array} bytes2 - The second Uint8Array to compare.\n * @returns {number} The count of consecutively matching items from the start.\n */\nexport function matchingBytesLength(bytes1: Uint8Array, bytes2: Uint8Array): number {\n  let count = 0\n  const minLength = Math.min(bytes1.length, bytes2.length)\n\n  for (let i = 0; i < minLength; i++) {\n    if (bytes1[i] === bytes2[i]) {\n      count++\n    } else {\n      // Break early if a mismatch is found\n      break\n    }\n  }\n  return count\n}\n\n/**\n * Compares two arrays of bits (0 or 1) and returns the count of consecutively matching bits from the start.\n * @param {number[]} bits1 - The first array of bits, in bytes or bits.\n * @param {number[]} bits2 - The second array of bits, in bytes or bits.\n * @returns {number} The count of consecutively matching bits from the start.\n */\nexport function matchingBitsLength(bits1: number[], bits2: number[]): number {\n  let count = 0\n  const minLength = Math.min(bits1.length, bits2.length)\n  for (let i = 0; i < minLength; i++) {\n    if (bits1[i] === bits2[i]) {\n      count++\n    } else {\n      return count\n    }\n  }\n  return count\n}\n\n/**\n * Checks whether two arrays of bits are equal.\n *\n * Two arrays are considered equal if they have the same length and each corresponding element is identical.\n *\n * @param {number[]} bits1 - The first bits array.\n * @param {number[]} bits2 - The second bits array.\n * @returns {boolean} True if the arrays are equal; otherwise, false.\n */\nexport function equalsBits(bits1: number[], bits2: number[]): boolean {\n  if (bits1.length !== bits2.length) {\n    return false\n  }\n  for (let i = 0; i < bits1.length; i++) {\n    if (bits1[i] !== bits2[i]) {\n      return false\n    }\n  }\n  return true\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 582, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/constants.js","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40web3auth/no-modal/node_modules/%40ethereumjs/util/src/constants.ts"],"sourcesContent":["import { secp256k1 } from 'ethereum-cryptography/secp256k1.js'\nimport { sha256 } from 'ethereum-cryptography/sha256.js'\n\nimport { hexToBytes } from './bytes.ts'\n\n/**\n * 2^64-1\n */\nexport const MAX_UINT64 = BigInt('0xffffffffffffffff')\n\n/**\n * The max integer that the evm can handle (2^256-1)\n */\nexport const MAX_INTEGER = BigInt(\n  '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff',\n)\n\n/**\n * The max integer that the evm can handle (2^256-1) as a bigint\n * 2^256-1 equals to 340282366920938463463374607431768211455\n * We use literal value instead of calculated value for compatibility issue.\n */\nexport const MAX_INTEGER_BIGINT = BigInt(\n  '115792089237316195423570985008687907853269984665640564039457584007913129639935',\n)\n\nexport const SECP256K1_ORDER = secp256k1.CURVE.n\nexport const SECP256K1_ORDER_DIV_2 = secp256k1.CURVE.n / BigInt(2)\n\n/**\n * 2^256\n */\nexport const TWO_POW256 = BigInt(\n  '0x10000000000000000000000000000000000000000000000000000000000000000',\n)\n\n/**\n * Keccak-256 hash of null\n */\nexport const KECCAK256_NULL_S = '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\n\n/**\n * Keccak-256 hash of null\n */\nexport const KECCAK256_NULL = hexToBytes(KECCAK256_NULL_S)\n\n/**\n * Keccak-256 of an RLP of an empty array\n */\nexport const KECCAK256_RLP_ARRAY_S =\n  '0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347'\n\n/**\n * Keccak-256 of an RLP of an empty array\n */\nexport const KECCAK256_RLP_ARRAY = hexToBytes(KECCAK256_RLP_ARRAY_S)\n\n/**\n * Keccak-256 hash of the RLP of null\n */\nexport const KECCAK256_RLP_S = '0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421'\n\n/**\n * Keccak-256 hash of the RLP of null\n */\nexport const KECCAK256_RLP = hexToBytes(KECCAK256_RLP_S)\n\nexport const SHA256_NULL = sha256(new Uint8Array())\n\n/**\n *  RLP encoded empty string\n */\nexport const RLP_EMPTY_STRING = Uint8Array.from([0x80])\n\nexport const MAX_WITHDRAWALS_PER_PAYLOAD = 16\n\nexport const RIPEMD160_ADDRESS_STRING = '0000000000000000000000000000000000000003'\n\n/**\n * EIP-7934: RLP Execution Block Size Limit constants\n * Maximum RLP-encoded block size to 10 MiB, with a 2 MiB margin for beacon block sizes\n */\nexport const MAX_BLOCK_SIZE = 10_485_760 // 10 MiB\nexport const SAFETY_MARGIN = 2_097_152 // 2 MiB\nexport const MAX_RLP_BLOCK_SIZE = MAX_BLOCK_SIZE - SAFETY_MARGIN // 8 MiB\n\n/**\n * BigInt constants\n */\n\nexport const BIGINT_NEG1 = BigInt(-1)\n\nexport const BIGINT_0 = BigInt(0)\nexport const BIGINT_1 = BigInt(1)\nexport const BIGINT_2 = BigInt(2)\nexport const BIGINT_3 = BigInt(3)\nexport const BIGINT_7 = BigInt(7)\nexport const BIGINT_8 = BigInt(8)\n\nexport const BIGINT_27 = BigInt(27)\nexport const BIGINT_28 = BigInt(28)\nexport const BIGINT_31 = BigInt(31)\nexport const BIGINT_32 = BigInt(32)\nexport const BIGINT_64 = BigInt(64)\n\nexport const BIGINT_128 = BigInt(128)\nexport const BIGINT_255 = BigInt(255)\nexport const BIGINT_256 = BigInt(256)\n\nexport const BIGINT_96 = BigInt(96)\nexport const BIGINT_100 = BigInt(100)\nexport const BIGINT_160 = BigInt(160)\nexport const BIGINT_224 = BigInt(224)\nexport const BIGINT_2EXP96 = BigInt(79228162514264337593543950336)\nexport const BIGINT_2EXP160 = BigInt(1461501637330902918203684832716283019655932542976)\nexport const BIGINT_2EXP224 =\n  BigInt(26959946667150639794667015087019630673637144422540572481103610249216)\nexport const BIGINT_2EXP256 = BIGINT_2 ** BIGINT_256\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 723, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/units.js","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40web3auth/no-modal/node_modules/%40ethereumjs/util/src/units.ts"],"sourcesContent":["import { BIGINT_0, BIGINT_1 } from './constants.ts'\nimport { EthereumJSErrorWithoutCode } from './errors.ts'\n\n/** Conversion constants to wei */\nexport const GWEI_TO_WEI = BigInt(10 ** 9) // Multiplier to convert from Gwei to Wei\nexport const ETHER_TO_WEI = BigInt(10 ** 18) // Multiplier to convert from Ether to Wei\n\nexport function formatBigDecimal(\n  numerator: bigint,\n  denominator: bigint,\n  maxDecimalFactor: bigint,\n): string {\n  if (denominator === BIGINT_0) {\n    denominator = BIGINT_1\n  }\n\n  const full = numerator / denominator\n  const fraction = ((numerator - full * denominator) * maxDecimalFactor) / denominator\n\n  // zeros to be added post decimal are number of zeros in maxDecimalFactor - number of digits in fraction\n  const zerosPostDecimal = String(maxDecimalFactor).length - 1 - String(fraction).length\n  return `${full}.${'0'.repeat(zerosPostDecimal)}${fraction}`\n}\n\nexport class Units {\n  static validateInput(amount: number | bigint): void {\n    if (typeof amount === 'number' && !Number.isInteger(amount)) {\n      throw EthereumJSErrorWithoutCode('Input must be an integer number')\n    }\n    if (BigInt(amount) < 0) {\n      throw EthereumJSErrorWithoutCode('Input must be a positive number')\n    }\n  }\n\n  /**\n   * Convert a number or bigint input of ether to wei\n   *\n   * @param {number | bigint} amount amount of units of ether to convert to wei\n   * @returns {bigint} amount of units in wei\n   */\n  static ether(amount: number | bigint): bigint {\n    Units.validateInput(amount)\n    return BigInt(amount) * ETHER_TO_WEI\n  }\n\n  /**\n   * Convert a number or bigint input of gwei to wei\n   *\n   * @param amount amount of units of gwei to convert to wei\n   * @returns {bigint} amount of units in wei\n   */\n  static gwei(amount: number | bigint): bigint {\n    Units.validateInput(amount)\n    return BigInt(amount) * GWEI_TO_WEI\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,gBAAgB,CAAA;;AACnD,OAAO,EAAE,0BAA0B,EAAE,MAAM,aAAa,CAAA;;;AAGjD,MAAM,WAAW,GAAG,MAAM,CAAC,EAAE,IAAI,CAAC,CAAC,CAAA,CAAC,yCAAyC;AAC7E,MAAM,YAAY,GAAG,MAAM,CAAC,EAAE,IAAI,EAAE,CAAC,CAAA,CAAC,0CAA0C;AAEjF,SAAU,gBAAgB,CAC9B,SAAiB,EACjB,WAAmB,EACnB,gBAAwB;IAExB,IAAI,WAAW,KAAK,yNAAQ,EAAE,CAAC;QAC7B,WAAW,GAAG,yNAAQ,CAAA;IACxB,CAAC;IAED,MAAM,IAAI,GAAG,SAAS,GAAG,WAAW,CAAA;IACpC,MAAM,QAAQ,GAAG,AAAC,CAAC,SAAS,GAAG,IAAI,GAAG,WAAW,CAAC,GAAG,gBAAgB,CAAC,EAAG,WAAW,CAAA;IAEpF,wGAAwG;IACxG,MAAM,gBAAgB,GAAG,MAAM,CAAC,gBAAgB,CAAC,CAAC,MAAM,GAAG,CAAC,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAA;IACtF,OAAO,GAAG,IAAI,CAAA,CAAA,EAAI,GAAG,CAAC,MAAM,CAAC,gBAAgB,CAAC,GAAG,QAAQ,EAAE,CAAA;AAC7D,CAAC;AAEK,MAAO,KAAK;IAChB,MAAM,CAAC,aAAa,CAAC,MAAuB,EAAA;QAC1C,IAAI,OAAO,MAAM,KAAK,QAAQ,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC;YAC5D,UAAM,uOAA0B,EAAC,iCAAiC,CAAC,CAAA;QACrE,CAAC;QACD,IAAI,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,CAAC;YACvB,UAAM,uOAA0B,EAAC,iCAAiC,CAAC,CAAA;QACrE,CAAC;IACH,CAAC;IAED;;;;;OAKG,CACH,MAAM,CAAC,KAAK,CAAC,MAAuB,EAAA;QAClC,KAAK,CAAC,aAAa,CAAC,MAAM,CAAC,CAAA;QAC3B,OAAO,MAAM,CAAC,MAAM,CAAC,GAAG,YAAY,CAAA;IACtC,CAAC;IAED;;;;;OAKG,CACH,MAAM,CAAC,IAAI,CAAC,MAAuB,EAAA;QACjC,KAAK,CAAC,aAAa,CAAC,MAAM,CAAC,CAAA;QAC3B,OAAO,MAAM,CAAC,MAAM,CAAC,GAAG,WAAW,CAAA;IACrC,CAAC;CACF"}},
    {"offset": {"line": 782, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/account.js","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40web3auth/no-modal/node_modules/%40ethereumjs/util/src/account.ts"],"sourcesContent":["import { RLP } from '@ethereumjs/rlp'\nimport { keccak256 } from 'ethereum-cryptography/keccak.js'\nimport { secp256k1 } from 'ethereum-cryptography/secp256k1.js'\n\nimport {\n  bigIntToUnpaddedBytes,\n  bytesToBigInt,\n  bytesToHex,\n  bytesToInt,\n  concatBytes,\n  equalsBytes,\n  hexToBytes,\n  intToUnpaddedBytes,\n  toBytes,\n  utf8ToBytes,\n} from './bytes.ts'\nimport { BIGINT_0, KECCAK256_NULL, KECCAK256_RLP } from './constants.ts'\nimport { EthereumJSErrorWithoutCode } from './errors.ts'\nimport { assertIsBytes, assertIsHexString, assertIsString } from './helpers.ts'\nimport { stripHexPrefix } from './internal.ts'\n\nimport type { BigIntLike, BytesLike, NestedUint8Array, PrefixedHexString } from './types.ts'\n\nexport interface AccountData {\n  nonce?: BigIntLike\n  balance?: BigIntLike\n  storageRoot?: BytesLike\n  codeHash?: BytesLike\n}\n\nexport interface PartialAccountData {\n  nonce?: BigIntLike | null\n  balance?: BigIntLike | null\n  storageRoot?: BytesLike | null\n  codeHash?: BytesLike | null\n  codeSize?: BigIntLike | null\n  version?: BigIntLike | null\n}\n\nexport type AccountBodyBytes = [Uint8Array, Uint8Array, Uint8Array, Uint8Array]\n\n/**\n * Handles the null indicator for RLP encoded accounts\n * @returns {null} is the null indicator is 0\n * @returns The unchanged value is the null indicator is 1\n * @throws if the null indicator is > 1\n * @throws if the length of values is < 2\n * @param value The value to convert\n * @returns The converted value\n */\nfunction handleNullIndicator(values: NestedUint8Array | Uint8Array): Uint8Array | null {\n  // Needed if some values are not provided to the array (e.g. partial account RLP)\n  if (values[0] === undefined) {\n    return null\n  }\n\n  const nullIndicator = bytesToInt(values[0] as Uint8Array)\n\n  if (nullIndicator === 0) {\n    return null\n  }\n  if (nullIndicator > 1) {\n    throw EthereumJSErrorWithoutCode(`Invalid isNullIndicator=${nullIndicator}`)\n  }\n  if (values.length < 2) {\n    throw EthereumJSErrorWithoutCode(`Invalid values length=${values.length}`)\n  }\n  return values[1] as Uint8Array\n}\n\n/**\n * Account class to load and maintain the  basic account objects.\n * Supports partial loading and access required for stateless with null\n * as the placeholder.\n *\n * Note: passing undefined in constructor is different from null\n * While undefined leads to default assignment, null is retained\n * to track the information not available/loaded because of partial\n * witness access\n */\nexport class Account {\n  _nonce: bigint | null = null\n  _balance: bigint | null = null\n  _storageRoot: Uint8Array | null = null\n  _codeHash: Uint8Array | null = null\n  // codeSize and version is separately stored in VKT\n  _codeSize: number | null = null\n  _version: number | null = null\n\n  get version() {\n    if (this._version !== null) {\n      return this._version\n    } else {\n      throw Error(`version=${this._version} not loaded`)\n    }\n  }\n  set version(_version: number) {\n    this._version = _version\n  }\n\n  get nonce() {\n    if (this._nonce !== null) {\n      return this._nonce\n    } else {\n      throw Error(`nonce=${this._nonce} not loaded`)\n    }\n  }\n  set nonce(_nonce: bigint) {\n    this._nonce = _nonce\n  }\n\n  get balance() {\n    if (this._balance !== null) {\n      return this._balance\n    } else {\n      throw Error(`balance=${this._balance} not loaded`)\n    }\n  }\n  set balance(_balance: bigint) {\n    this._balance = _balance\n  }\n\n  get storageRoot() {\n    if (this._storageRoot !== null) {\n      return this._storageRoot\n    } else {\n      throw Error(`storageRoot=${this._storageRoot} not loaded`)\n    }\n  }\n  set storageRoot(_storageRoot: Uint8Array) {\n    this._storageRoot = _storageRoot\n  }\n\n  get codeHash() {\n    if (this._codeHash !== null) {\n      return this._codeHash\n    } else {\n      throw Error(`codeHash=${this._codeHash} not loaded`)\n    }\n  }\n  set codeHash(_codeHash: Uint8Array) {\n    this._codeHash = _codeHash\n  }\n\n  get codeSize() {\n    if (this._codeSize !== null) {\n      return this._codeSize\n    } else {\n      throw Error(`codeSize=${this._codeSize} not loaded`)\n    }\n  }\n  set codeSize(_codeSize: number) {\n    this._codeSize = _codeSize\n  }\n\n  /**\n   * This constructor assigns and validates the values.\n   * It is not recommended to use this constructor directly. Instead use the static\n   * factory methods to assist in creating an Account from varying data types.\n   * undefined get assigned with the defaults, but null args are retained as is\n   * @deprecated\n   */\n  constructor(\n    nonce: bigint | null = BIGINT_0,\n    balance: bigint | null = BIGINT_0,\n    storageRoot: Uint8Array | null = KECCAK256_RLP,\n    codeHash: Uint8Array | null = KECCAK256_NULL,\n    codeSize: number | null = 0,\n    version: number | null = 0,\n  ) {\n    this._nonce = nonce\n    this._balance = balance\n    this._storageRoot = storageRoot\n    this._codeHash = codeHash\n\n    if (codeSize === null && codeHash !== null && !this.isContract()) {\n      codeSize = 0\n    }\n    this._codeSize = codeSize\n    this._version = version\n\n    this._validate()\n  }\n\n  private _validate() {\n    if (this._nonce !== null && this._nonce < BIGINT_0) {\n      throw EthereumJSErrorWithoutCode('nonce must be greater than zero')\n    }\n    if (this._balance !== null && this._balance < BIGINT_0) {\n      throw EthereumJSErrorWithoutCode('balance must be greater than zero')\n    }\n    if (this._storageRoot !== null && this._storageRoot.length !== 32) {\n      throw EthereumJSErrorWithoutCode('storageRoot must have a length of 32')\n    }\n    if (this._codeHash !== null && this._codeHash.length !== 32) {\n      throw EthereumJSErrorWithoutCode('codeHash must have a length of 32')\n    }\n    if (this._codeSize !== null && this._codeSize < BIGINT_0) {\n      throw EthereumJSErrorWithoutCode('codeSize must be greater than zero')\n    }\n  }\n\n  /**\n   * Returns an array of Uint8Arrays of the raw bytes for the account, in order.\n   */\n  raw(): Uint8Array[] {\n    return [\n      bigIntToUnpaddedBytes(this.nonce),\n      bigIntToUnpaddedBytes(this.balance),\n      this.storageRoot,\n      this.codeHash,\n    ]\n  }\n\n  /**\n   * Returns the RLP serialization of the account as a `Uint8Array`.\n   */\n  serialize(): Uint8Array {\n    return RLP.encode(this.raw())\n  }\n\n  serializeWithPartialInfo(): Uint8Array {\n    const partialData = []\n    const zeroEncoded = intToUnpaddedBytes(0)\n    const oneEncoded = intToUnpaddedBytes(1)\n\n    if (this._nonce !== null) {\n      partialData.push([oneEncoded, bigIntToUnpaddedBytes(this._nonce)])\n    } else {\n      partialData.push([zeroEncoded])\n    }\n\n    if (this._balance !== null) {\n      partialData.push([oneEncoded, bigIntToUnpaddedBytes(this._balance)])\n    } else {\n      partialData.push([zeroEncoded])\n    }\n\n    if (this._storageRoot !== null) {\n      partialData.push([oneEncoded, this._storageRoot])\n    } else {\n      partialData.push([zeroEncoded])\n    }\n\n    if (this._codeHash !== null) {\n      partialData.push([oneEncoded, this._codeHash])\n    } else {\n      partialData.push([zeroEncoded])\n    }\n\n    if (this._codeSize !== null) {\n      partialData.push([oneEncoded, intToUnpaddedBytes(this._codeSize)])\n    } else {\n      partialData.push([zeroEncoded])\n    }\n\n    if (this._version !== null) {\n      partialData.push([oneEncoded, intToUnpaddedBytes(this._version)])\n    } else {\n      partialData.push([zeroEncoded])\n    }\n\n    return RLP.encode(partialData)\n  }\n\n  /**\n   * Returns a `Boolean` determining if the account is a contract.\n   */\n  isContract(): boolean {\n    if (this._codeHash === null && this._codeSize === null) {\n      throw Error(`Insufficient data as codeHash=null and codeSize=null`)\n    }\n    return (\n      (this._codeHash !== null && !equalsBytes(this._codeHash, KECCAK256_NULL)) ||\n      (this._codeSize !== null && this._codeSize !== 0)\n    )\n  }\n\n  /**\n   * Returns a `Boolean` determining if the account is empty complying to the definition of\n   * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n   * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n   */\n  isEmpty(): boolean {\n    // helpful for determination in partial accounts\n    if (\n      (this._balance !== null && this.balance !== BIGINT_0) ||\n      (this._nonce === null && this.nonce !== BIGINT_0) ||\n      (this._codeHash !== null && !equalsBytes(this.codeHash, KECCAK256_NULL))\n    ) {\n      return false\n    }\n\n    return (\n      this.balance === BIGINT_0 &&\n      this.nonce === BIGINT_0 &&\n      equalsBytes(this.codeHash, KECCAK256_NULL)\n    )\n  }\n}\n\n// Account constructors\n\nexport function createAccount(accountData: AccountData) {\n  const { nonce, balance, storageRoot, codeHash } = accountData\n  if (nonce === null || balance === null || storageRoot === null || codeHash === null) {\n    throw Error(`Partial fields not supported in fromAccountData`)\n  }\n\n  return new Account(\n    nonce !== undefined ? bytesToBigInt(toBytes(nonce)) : undefined,\n    balance !== undefined ? bytesToBigInt(toBytes(balance)) : undefined,\n    storageRoot !== undefined ? toBytes(storageRoot) : undefined,\n    codeHash !== undefined ? toBytes(codeHash) : undefined,\n  )\n}\n\nexport function createAccountFromBytesArray(values: Uint8Array[]) {\n  const [nonce, balance, storageRoot, codeHash] = values\n\n  return new Account(bytesToBigInt(nonce), bytesToBigInt(balance), storageRoot, codeHash)\n}\n\nexport function createPartialAccount(partialAccountData: PartialAccountData) {\n  const { nonce, balance, storageRoot, codeHash, codeSize, version } = partialAccountData\n\n  if (\n    nonce === null &&\n    balance === null &&\n    storageRoot === null &&\n    codeHash === null &&\n    codeSize === null &&\n    version === null\n  ) {\n    throw Error(`All partial fields null`)\n  }\n\n  return new Account(\n    nonce !== undefined && nonce !== null ? bytesToBigInt(toBytes(nonce)) : nonce,\n    balance !== undefined && balance !== null ? bytesToBigInt(toBytes(balance)) : balance,\n    storageRoot !== undefined && storageRoot !== null ? toBytes(storageRoot) : storageRoot,\n    codeHash !== undefined && codeHash !== null ? toBytes(codeHash) : codeHash,\n    codeSize !== undefined && codeSize !== null ? bytesToInt(toBytes(codeSize)) : codeSize,\n    version !== undefined && version !== null ? bytesToInt(toBytes(version)) : version,\n  )\n}\n\nexport function createAccountFromRLP(serialized: Uint8Array) {\n  const values = RLP.decode(serialized) as Uint8Array[]\n\n  if (!Array.isArray(values)) {\n    throw EthereumJSErrorWithoutCode('Invalid serialized account input. Must be array')\n  }\n\n  return createAccountFromBytesArray(values)\n}\n\nexport function createPartialAccountFromRLP(serialized: Uint8Array) {\n  const values = RLP.decode(serialized)\n\n  if (!Array.isArray(values)) {\n    throw EthereumJSErrorWithoutCode('Invalid serialized account input. Must be array')\n  }\n\n  for (const value of values) {\n    // Ensure that each array item is an array\n    if (!Array.isArray(value)) {\n      throw EthereumJSErrorWithoutCode('Invalid partial encoding. Each item must be an array')\n    }\n  }\n\n  const [nonceRaw, balanceRaw, storageRoot, codeHash, codeSizeRaw, versionRaw] =\n    values.map(handleNullIndicator)\n\n  const nonce = nonceRaw === null ? null : bytesToBigInt(nonceRaw)\n  const balance = balanceRaw === null ? null : bytesToBigInt(balanceRaw)\n  const codeSize = codeSizeRaw === null ? null : bytesToInt(codeSizeRaw)\n  const version = versionRaw === null ? null : bytesToInt(versionRaw)\n\n  return createPartialAccount({ balance, nonce, storageRoot, codeHash, codeSize, version })\n}\n\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nexport const isValidAddress = function (hexAddress: string): hexAddress is PrefixedHexString {\n  try {\n    assertIsString(hexAddress)\n  } catch {\n    return false\n  }\n\n  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress)\n}\n\n/**\n * Returns a checksummed address.\n *\n * If an eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ and the EIP-1191 checksum is not\n * backwards compatible to the original widely adopted checksum format standard introduced in\n * [EIP-55](https://eips.ethereum.org/EIPS/eip-55), so this will break in existing applications.\n * Usage of this EIP is therefore discouraged unless you have a very targeted use case.\n */\nexport const toChecksumAddress = function (\n  hexAddress: string,\n  eip1191ChainId?: BigIntLike,\n): PrefixedHexString {\n  assertIsHexString(hexAddress)\n  const address = stripHexPrefix(hexAddress).toLowerCase()\n\n  let prefix = ''\n  if (eip1191ChainId !== undefined) {\n    const chainId = bytesToBigInt(toBytes(eip1191ChainId))\n    prefix = chainId.toString() + '0x'\n  }\n\n  const bytes = utf8ToBytes(prefix + address)\n  const hash = bytesToHex(keccak256(bytes)).slice(2)\n  let ret = ''\n\n  for (let i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase()\n    } else {\n      ret += address[i]\n    }\n  }\n\n  return `0x${ret}`\n}\n\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nexport const isValidChecksumAddress = function (\n  hexAddress: string,\n  eip1191ChainId?: BigIntLike,\n): boolean {\n  return isValidAddress(hexAddress) && toChecksumAddress(hexAddress, eip1191ChainId) === hexAddress\n}\n\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nexport const generateAddress = function (from: Uint8Array, nonce: Uint8Array): Uint8Array {\n  assertIsBytes(from)\n  assertIsBytes(nonce)\n\n  if (bytesToBigInt(nonce) === BIGINT_0) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return keccak256(RLP.encode([from, Uint8Array.from([])])).subarray(-20)\n  }\n\n  // Only take the lower 160bits of the hash\n  return keccak256(RLP.encode([from, nonce])).subarray(-20)\n}\n\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nexport const generateAddress2 = function (\n  from: Uint8Array,\n  salt: Uint8Array,\n  initCode: Uint8Array,\n): Uint8Array {\n  assertIsBytes(from)\n  assertIsBytes(salt)\n  assertIsBytes(initCode)\n\n  if (from.length !== 20) {\n    throw EthereumJSErrorWithoutCode('Expected from to be of length 20')\n  }\n  if (salt.length !== 32) {\n    throw EthereumJSErrorWithoutCode('Expected salt to be of length 32')\n  }\n\n  const address = keccak256(concatBytes(hexToBytes('0xff'), from, salt, keccak256(initCode)))\n\n  return address.subarray(-20)\n}\n\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nexport const isValidPrivate = function (privateKey: Uint8Array): boolean {\n  return secp256k1.utils.isValidPrivateKey(privateKey)\n}\n\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexport const isValidPublic = function (publicKey: Uint8Array, sanitize: boolean = false): boolean {\n  assertIsBytes(publicKey)\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    // Automatically checks whether point is on curve\n    try {\n      secp256k1.ProjectivePoint.fromHex(concatBytes(Uint8Array.from([4]), publicKey))\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  if (!sanitize) {\n    return false\n  }\n\n  try {\n    secp256k1.ProjectivePoint.fromHex(publicKey)\n    return true\n  } catch {\n    return false\n  }\n}\n\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexport const pubToAddress = function (pubKey: Uint8Array, sanitize: boolean = false): Uint8Array {\n  assertIsBytes(pubKey)\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1)\n  }\n  if (pubKey.length !== 64) {\n    throw EthereumJSErrorWithoutCode('Expected pubKey to be of length 64')\n  }\n  // Only take the lower 160bits of the hash\n  return keccak256(pubKey).subarray(-20)\n}\nexport const publicToAddress = pubToAddress\n\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexport const privateToPublic = function (privateKey: Uint8Array): Uint8Array {\n  assertIsBytes(privateKey)\n  // skip the type flag and use the X, Y points\n  return secp256k1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(false).slice(1)\n}\n\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexport const privateToAddress = function (privateKey: Uint8Array): Uint8Array {\n  return publicToAddress(privateToPublic(privateKey))\n}\n\n/**\n * Converts a public key to the Ethereum format.\n */\nexport const importPublic = function (publicKey: Uint8Array): Uint8Array {\n  assertIsBytes(publicKey)\n  if (publicKey.length !== 64) {\n    publicKey = secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(false).slice(1)\n  }\n  return publicKey\n}\n\n/**\n * Returns the zero address.\n */\nexport const zeroAddress = function (): PrefixedHexString {\n  return bytesToHex(new Uint8Array(20))\n}\n\n/**\n * Checks if a given address is the zero address.\n */\nexport const isZeroAddress = function (hexAddress: string): boolean {\n  try {\n    assertIsString(hexAddress)\n  } catch {\n    return false\n  }\n\n  const zeroAddr = zeroAddress()\n  return zeroAddr === hexAddress\n}\n\nexport function accountBodyFromSlim(body: AccountBodyBytes) {\n  const [nonce, balance, storageRoot, codeHash] = body\n  return [\n    nonce,\n    balance,\n    storageRoot.length === 0 ? KECCAK256_RLP : storageRoot,\n    codeHash.length === 0 ? KECCAK256_NULL : codeHash,\n  ]\n}\n\nconst emptyUint8Arr = new Uint8Array(0)\nexport function accountBodyToSlim(body: AccountBodyBytes) {\n  const [nonce, balance, storageRoot, codeHash] = body\n  return [\n    nonce,\n    balance,\n    equalsBytes(storageRoot, KECCAK256_RLP) ? emptyUint8Arr : storageRoot,\n    equalsBytes(codeHash, KECCAK256_NULL) ? emptyUint8Arr : codeHash,\n  ]\n}\n\n/**\n * Converts a slim account (per snap protocol spec) to the RLP encoded version of the account\n * @param body Array of 4 Uint8Array-like items to represent the account\n * @returns RLP encoded version of the account\n */\nexport function accountBodyToRLP(body: AccountBodyBytes, couldBeSlim = true) {\n  const accountBody = couldBeSlim ? accountBodyFromSlim(body) : body\n  return RLP.encode(accountBody)\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1283, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/address.js","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40web3auth/no-modal/node_modules/%40ethereumjs/util/src/address.ts"],"sourcesContent":["import {\n  generateAddress,\n  generateAddress2,\n  isValidAddress,\n  privateToAddress,\n  pubToAddress,\n} from './account.ts'\nimport {\n  bigIntToBytes,\n  bytesToBigInt,\n  bytesToHex,\n  equalsBytes,\n  hexToBytes,\n  setLengthLeft,\n} from './bytes.ts'\nimport { BIGINT_0 } from './constants.ts'\nimport { EthereumJSErrorWithoutCode } from './errors.ts'\n\nimport type { PrefixedHexString } from './types.ts'\n\n/**\n * Handling and generating Ethereum addresses\n */\nexport class Address {\n  public readonly bytes: Uint8Array\n\n  constructor(bytes: Uint8Array) {\n    if (bytes.length !== 20) {\n      throw EthereumJSErrorWithoutCode('Invalid address length')\n    }\n    this.bytes = bytes\n  }\n\n  /**\n   * Is address equal to another.\n   */\n  equals(address: Address): boolean {\n    return equalsBytes(this.bytes, address.bytes)\n  }\n\n  /**\n   * Is address zero.\n   */\n  isZero(): boolean {\n    return this.equals(new Address(new Uint8Array(20)))\n  }\n\n  /**\n   * True if address is in the address range defined\n   * by EIP-1352\n   */\n  isPrecompileOrSystemAddress(): boolean {\n    const address = bytesToBigInt(this.bytes)\n    const rangeMin = BIGINT_0\n    const rangeMax = BigInt('0xffff')\n    return address >= rangeMin && address <= rangeMax\n  }\n\n  /**\n   * Returns hex encoding of address.\n   */\n  toString(): PrefixedHexString {\n    return bytesToHex(this.bytes)\n  }\n\n  /**\n   * Returns a new Uint8Array representation of address.\n   */\n  toBytes(): Uint8Array {\n    return new Uint8Array(this.bytes)\n  }\n}\n\n/**\n * Returns the zero address.\n */\nexport function createZeroAddress(): Address {\n  return new Address(new Uint8Array(20))\n}\n\n/**\n * Returns an Address object from a bigint address (they are stored as bigints on the stack)\n * @param value The bigint address\n */\nexport function createAddressFromBigInt(value: bigint): Address {\n  const bytes = bigIntToBytes(value)\n  if (bytes.length > 20) {\n    throw EthereumJSErrorWithoutCode(`Invalid address, too long: ${bytes.length}`)\n  }\n  return new Address(setLengthLeft(bytes, 20))\n}\n\n/**\n * Returns an Address object from a hex-encoded string.\n * @param str - Hex-encoded address\n */\nexport function createAddressFromString(str: string): Address {\n  if (!isValidAddress(str)) {\n    throw EthereumJSErrorWithoutCode(`Invalid address input=${str}`)\n  }\n  return new Address(hexToBytes(str))\n}\n\n/**\n * Returns an address for a given public key.\n * @param pubKey The two points of an uncompressed key\n */\nexport function createAddressFromPublicKey(pubKey: Uint8Array): Address {\n  if (!(pubKey instanceof Uint8Array)) {\n    throw EthereumJSErrorWithoutCode('Public key should be Uint8Array')\n  }\n  const bytes = pubToAddress(pubKey)\n  return new Address(bytes)\n}\n\n/**\n * Returns an address for a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexport function createAddressFromPrivateKey(privateKey: Uint8Array): Address {\n  if (!(privateKey instanceof Uint8Array)) {\n    throw EthereumJSErrorWithoutCode('Private key should be Uint8Array')\n  }\n  const bytes = privateToAddress(privateKey)\n  return new Address(bytes)\n}\n\n/**\n * Generates an address for a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nexport function createContractAddress(from: Address, nonce: bigint): Address {\n  if (typeof nonce !== 'bigint') {\n    throw EthereumJSErrorWithoutCode('Expected nonce to be a bigint')\n  }\n  return new Address(generateAddress(from.bytes, bigIntToBytes(nonce)))\n}\n\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nexport function createContractAddress2(\n  from: Address,\n  salt: Uint8Array,\n  initCode: Uint8Array,\n): Address {\n  if (!(salt instanceof Uint8Array)) {\n    throw EthereumJSErrorWithoutCode('Expected salt to be a Uint8Array')\n  }\n  if (!(initCode instanceof Uint8Array)) {\n    throw EthereumJSErrorWithoutCode('Expected initCode to be a Uint8Array')\n  }\n  return new Address(generateAddress2(from.bytes, salt, initCode))\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1397, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/db.js","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40web3auth/no-modal/node_modules/%40ethereumjs/util/src/db.ts"],"sourcesContent":["export type DBObject = {\n  [key: string]: string | string[] | number\n}\nexport type BatchDBOp<\n  TKey extends Uint8Array | string | number = Uint8Array,\n  TValue extends Uint8Array | string | DBObject = Uint8Array,\n> = PutBatch<TKey, TValue> | DelBatch<TKey>\n\nexport type KeyEncoding = (typeof KeyEncoding)[keyof typeof KeyEncoding]\n\nexport const KeyEncoding = {\n  String: 'string',\n  Bytes: 'view',\n  Number: 'number',\n} as const\n\nexport type ValueEncoding = (typeof ValueEncoding)[keyof typeof ValueEncoding]\n\nexport const ValueEncoding = {\n  String: 'string',\n  Bytes: 'view',\n  JSON: 'json',\n} as const\n\nexport type EncodingOpts = {\n  keyEncoding?: KeyEncoding\n  valueEncoding?: ValueEncoding\n}\nexport interface PutBatch<\n  TKey extends Uint8Array | string | number = Uint8Array,\n  TValue extends Uint8Array | string | DBObject = Uint8Array,\n> {\n  type: 'put'\n  key: TKey\n  value: TValue\n  opts?: EncodingOpts\n}\n\nexport interface DelBatch<TKey extends Uint8Array | string | number = Uint8Array> {\n  type: 'del'\n  key: TKey\n  opts?: EncodingOpts\n}\n\nexport interface DB<\n  TKey extends Uint8Array | string | number = Uint8Array,\n  TValue extends Uint8Array | string | DBObject = Uint8Array,\n> {\n  /**\n   * Retrieves a raw value from db.\n   * @param key\n   * @returns A Promise that resolves to `Uint8Array` if a value is found or `undefined` if no value is found.\n   */\n  get(key: TKey, opts?: EncodingOpts): Promise<TValue | undefined>\n\n  /**\n   * Writes a value directly to db.\n   * @param key The key as a `TValue`\n   * @param value The value to be stored\n   */\n  put(key: TKey, val: TValue, opts?: EncodingOpts): Promise<void>\n\n  /**\n   * Removes a raw value in the underlying db.\n   * @param keys\n   */\n  del(key: TKey, opts?: EncodingOpts): Promise<void>\n\n  /**\n   * Performs a batch operation on db.\n   * @param opStack A stack of levelup operations\n   */\n  batch(opStack: BatchDBOp<TKey, TValue>[]): Promise<void>\n\n  /**\n   * Returns a copy of the DB instance, with a reference\n   * to the **same** underlying db instance.\n   */\n  shallowCopy(): DB<TKey, TValue>\n\n  /**\n   * Opens the database -- if applicable\n   */\n  open(): Promise<void>\n  // TODO - decide if we actually need open/close - it's not required for maps and Level automatically opens the DB when you instantiate it\n}\n"],"names":[],"mappings":";;;;;;AAUO,MAAM,WAAW,GAAG;IACzB,MAAM,EAAE,QAAQ;IAChB,KAAK,EAAE,MAAM;IACb,MAAM,EAAE,QAAQ;CACR,CAAA;AAIH,MAAM,aAAa,GAAG;IAC3B,MAAM,EAAE,QAAQ;IAChB,KAAK,EAAE,MAAM;IACb,IAAI,EAAE,MAAM;CACJ,CAAA"}},
    {"offset": {"line": 1417, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/types.js","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40web3auth/no-modal/node_modules/%40ethereumjs/util/src/types.ts"],"sourcesContent":["import { bytesToBigInt, bytesToHex, toBytes } from './bytes.ts'\nimport { EthereumJSErrorWithoutCode } from './errors.ts'\nimport { isHexString } from './internal.ts'\n\nimport type { Address } from './address.ts'\nimport type { ToBytesInputTypes } from './bytes.ts'\n\n/*\n * A type that represents an input that can be converted to a BigInt.\n */\nexport type BigIntLike = bigint | PrefixedHexString | number | Uint8Array\n\n/*\n * A type that represents an input that can be converted to a Uint8Array.\n */\nexport type BytesLike =\n  | Uint8Array\n  | number[]\n  | number\n  | bigint\n  | TransformableToBytes\n  | PrefixedHexString\n\n/*\n * A type that represents a number-like string.\n */\nexport type NumericString = `${number}`\n\n/*\n * A type that represents a `0x`-prefixed hex string.\n */\nexport type PrefixedHexString = `0x${string}`\n\n/**\n * A type that represents an input that can be converted to an Address.\n */\nexport type AddressLike = Address | Uint8Array | PrefixedHexString\n\nexport interface TransformableToBytes {\n  toBytes?(): Uint8Array\n}\n\nexport type NestedUint8Array = Array<Uint8Array | NestedUint8Array>\n\nexport function isNestedUint8Array(value: unknown): value is NestedUint8Array {\n  if (!Array.isArray(value)) {\n    return false\n  }\n  for (const item of value) {\n    if (Array.isArray(item)) {\n      if (!isNestedUint8Array(item)) {\n        return false\n      }\n    } else if (!(item instanceof Uint8Array)) {\n      return false\n    }\n  }\n  return true\n}\n\nexport type TypeOutput = (typeof TypeOutput)[keyof typeof TypeOutput]\n\nexport const TypeOutput = {\n  Number: 0,\n  BigInt: 1,\n  Uint8Array: 2,\n  PrefixedHexString: 3,\n} as const\n\nexport type TypeOutputReturnType = {\n  [TypeOutput.Number]: number\n  [TypeOutput.BigInt]: bigint\n  [TypeOutput.Uint8Array]: Uint8Array\n  [TypeOutput.PrefixedHexString]: PrefixedHexString\n}\n\n/**\n * Convert an input to a specified type.\n * Input of null/undefined returns null/undefined regardless of the output type.\n * @param input value to convert\n * @param outputType type to output\n */\nexport function toType<T extends TypeOutput>(input: null, outputType: T): null\nexport function toType<T extends TypeOutput>(input: undefined, outputType: T): undefined\nexport function toType<T extends TypeOutput>(\n  input: ToBytesInputTypes,\n  outputType: T,\n): TypeOutputReturnType[T]\nexport function toType<T extends TypeOutput>(\n  input: ToBytesInputTypes,\n  outputType: T,\n): TypeOutputReturnType[T] | undefined | null {\n  if (input === null) {\n    return null\n  }\n  if (input === undefined) {\n    return undefined\n  }\n\n  if (typeof input === 'string' && !isHexString(input)) {\n    throw EthereumJSErrorWithoutCode(`A string must be provided with a 0x-prefix, given: ${input}`)\n  } else if (typeof input === 'number' && !Number.isSafeInteger(input)) {\n    throw EthereumJSErrorWithoutCode(\n      'The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)',\n    )\n  }\n\n  const output = toBytes(input)\n\n  switch (outputType) {\n    case TypeOutput.Uint8Array:\n      return output as TypeOutputReturnType[T]\n    case TypeOutput.BigInt:\n      return bytesToBigInt(output) as TypeOutputReturnType[T]\n    case TypeOutput.Number: {\n      const bigInt = bytesToBigInt(output)\n      if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {\n        throw EthereumJSErrorWithoutCode(\n          'The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)',\n        )\n      }\n      return Number(bigInt) as TypeOutputReturnType[T]\n    }\n    case TypeOutput.PrefixedHexString:\n      return bytesToHex(output) as TypeOutputReturnType[T]\n    default:\n      throw EthereumJSErrorWithoutCode('unknown outputType')\n  }\n}\n\n/**\n * EIP-7702 Authorization list types\n */\nexport type EOACode7702AuthorizationListItemUnsigned = {\n  chainId: PrefixedHexString\n  address: PrefixedHexString\n  nonce: PrefixedHexString\n}\n\nexport type EOACode7702AuthorizationListItem = {\n  yParity: PrefixedHexString\n  r: PrefixedHexString\n  s: PrefixedHexString\n} & EOACode7702AuthorizationListItemUnsigned\n\n// Tuple of [chain_id, address, nonce, y_parity, r, s]\nexport type EOACode7702AuthorizationListBytesItem = [\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n  Uint8Array,\n]\nexport type EOACode7702AuthorizationListBytes = EOACode7702AuthorizationListBytesItem[]\nexport type EOACode7702AuthorizationList = EOACode7702AuthorizationListItem[]\n\nexport type EOACode7702AuthorizationListBytesItemUnsigned = [Uint8Array, Uint8Array, Uint8Array]\n\nexport function isEOACode7702AuthorizationListBytes(\n  input: EOACode7702AuthorizationListBytes | EOACode7702AuthorizationList,\n): input is EOACode7702AuthorizationListBytes {\n  if (input.length === 0) {\n    return true\n  }\n  const firstItem = input[0]\n  if (Array.isArray(firstItem)) {\n    return true\n  }\n  return false\n}\n\nexport function isEOACode7702AuthorizationList(\n  input: EOACode7702AuthorizationListBytes | EOACode7702AuthorizationList,\n): input is EOACode7702AuthorizationList {\n  return !isEOACode7702AuthorizationListBytes(input) // This is exactly the same method, except the output is negated.\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1506, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/withdrawal.js","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40web3auth/no-modal/node_modules/%40ethereumjs/util/src/withdrawal.ts"],"sourcesContent":["import { Address } from './address.ts'\nimport { bigIntToHex, bytesToHex, toBytes } from './bytes.ts'\nimport { BIGINT_0 } from './constants.ts'\nimport { TypeOutput, toType } from './types.ts'\n\nimport type { AddressLike, BigIntLike, PrefixedHexString } from './types.ts'\n\n/**\n * Flexible input data type for EIP-4895 withdrawal data with amount in Gwei to\n * match CL representation and for eventual ssz withdrawalsRoot\n */\nexport type WithdrawalData = {\n  index: BigIntLike\n  validatorIndex: BigIntLike\n  address: AddressLike\n  amount: BigIntLike\n}\n\n/**\n * JSON RPC interface for EIP-4895 withdrawal data with amount in Gwei to\n * match CL representation and for eventual ssz withdrawalsRoot\n */\nexport interface JSONRPCWithdrawal {\n  index: PrefixedHexString // QUANTITY - bigint 8 bytes\n  validatorIndex: PrefixedHexString // QUANTITY - bigint 8 bytes\n  address: PrefixedHexString // DATA, 20 Bytes  address to withdraw to\n  amount: PrefixedHexString // QUANTITY - bigint amount in Gwei 8 bytes\n}\n\nexport type WithdrawalBytes = [Uint8Array, Uint8Array, Uint8Array, Uint8Array]\n/**\n * Convert a withdrawal to a byte array\n * @param withdrawal the withdrawal to convert\n * @returns byte array of the withdrawal\n */\nexport function withdrawalToBytesArray(withdrawal: Withdrawal | WithdrawalData): WithdrawalBytes {\n  const { index, validatorIndex, address, amount } = withdrawal\n  const indexBytes =\n    toType(index, TypeOutput.BigInt) === BIGINT_0\n      ? new Uint8Array()\n      : toType(index, TypeOutput.Uint8Array)\n  const validatorIndexBytes =\n    toType(validatorIndex, TypeOutput.BigInt) === BIGINT_0\n      ? new Uint8Array()\n      : toType(validatorIndex, TypeOutput.Uint8Array)\n  const addressBytes =\n    address instanceof Address ? address.bytes : toType(address, TypeOutput.Uint8Array)\n\n  const amountBytes =\n    toType(amount, TypeOutput.BigInt) === BIGINT_0\n      ? new Uint8Array()\n      : toType(amount, TypeOutput.Uint8Array)\n\n  return [indexBytes, validatorIndexBytes, addressBytes, amountBytes]\n}\n/**\n * Representation of EIP-4895 withdrawal data\n */\nexport class Withdrawal {\n  public readonly index: bigint\n  public readonly validatorIndex: bigint\n  public readonly address: Address\n  public readonly amount: bigint\n\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating a Withdrawal object from varying data types.\n   * Its amount is in Gwei to match CL representation and for eventual ssz withdrawalsRoot\n   */\n  constructor(index: bigint, validatorIndex: bigint, address: Address, amount: bigint) {\n    this.index = index\n    this.validatorIndex = validatorIndex\n    this.address = address\n    this.amount = amount\n  }\n\n  raw() {\n    return withdrawalToBytesArray(this)\n  }\n\n  toValue() {\n    return {\n      index: this.index,\n      validatorIndex: this.validatorIndex,\n      address: this.address.bytes,\n      amount: this.amount,\n    }\n  }\n\n  toJSON() {\n    return {\n      index: bigIntToHex(this.index),\n      validatorIndex: bigIntToHex(this.validatorIndex),\n      address: bytesToHex(this.address.bytes),\n      amount: bigIntToHex(this.amount),\n    }\n  }\n}\n\n/**\n * Creates a validator withdrawal request to be submitted to the consensus layer\n * @param withdrawalData the consensus layer index and validator index values for the\n * validator requesting the withdrawal and the address and withdrawal amount of the request\n * @returns a {@link Withdrawal} object\n */\nexport function createWithdrawal(withdrawalData: WithdrawalData) {\n  const {\n    index: indexData,\n    validatorIndex: validatorIndexData,\n    address: addressData,\n    amount: amountData,\n  } = withdrawalData\n  const index = toType(indexData, TypeOutput.BigInt)\n  const validatorIndex = toType(validatorIndexData, TypeOutput.BigInt)\n  const address = addressData instanceof Address ? addressData : new Address(toBytes(addressData))\n  const amount = toType(amountData, TypeOutput.BigInt)\n\n  return new Withdrawal(index, validatorIndex, address, amount)\n}\n\n/**\n * Creates a validator withdrawal request to be submitted to the consensus layer from\n * an RLP list\n * @param withdrawalArray decoded RLP list of withdrawal data elements\n * @returns a {@link Withdrawal} object\n */\nexport function createWithdrawalFromBytesArray(withdrawalArray: WithdrawalBytes) {\n  if (withdrawalArray.length !== 4) {\n    throw Error(`Invalid withdrawalArray length expected=4 actual=${withdrawalArray.length}`)\n  }\n  const [index, validatorIndex, address, amount] = withdrawalArray\n  return createWithdrawal({ index, validatorIndex, address, amount })\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1592, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/signature.js","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40web3auth/no-modal/node_modules/%40ethereumjs/util/src/signature.ts"],"sourcesContent":["import { keccak256 } from 'ethereum-cryptography/keccak.js'\nimport { secp256k1 } from 'ethereum-cryptography/secp256k1.js'\n\nimport {\n  bigIntToBytes,\n  bytesToBigInt,\n  bytesToHex,\n  bytesToInt,\n  concatBytes,\n  hexToBytes,\n  setLengthLeft,\n  utf8ToBytes,\n} from './bytes.ts'\nimport {\n  BIGINT_0,\n  BIGINT_1,\n  BIGINT_2,\n  BIGINT_27,\n  SECP256K1_ORDER,\n  SECP256K1_ORDER_DIV_2,\n} from './constants.ts'\nimport { EthereumJSErrorWithoutCode } from './errors.ts'\nimport { assertIsBytes } from './helpers.ts'\n\nimport type { PrefixedHexString } from './types.ts'\n\nexport function calculateSigRecovery(v: bigint, chainId?: bigint): bigint {\n  if (v === BIGINT_0 || v === BIGINT_1) return v\n\n  if (chainId === undefined) {\n    return v - BIGINT_27\n  }\n  return v - (chainId * BIGINT_2 + BigInt(35))\n}\n\nfunction isValidSigRecovery(recovery: bigint): boolean {\n  return recovery === BIGINT_0 || recovery === BIGINT_1\n}\n\n/**\n * ECDSA public key recovery from signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Recovered public key\n */\nexport const ecrecover = function (\n  msgHash: Uint8Array,\n  v: bigint,\n  r: Uint8Array,\n  s: Uint8Array,\n  chainId?: bigint,\n): Uint8Array {\n  const signature = concatBytes(setLengthLeft(r, 32), setLengthLeft(s, 32))\n  const recovery = calculateSigRecovery(v, chainId)\n  if (!isValidSigRecovery(recovery)) {\n    throw EthereumJSErrorWithoutCode('Invalid signature v value')\n  }\n\n  const sig = secp256k1.Signature.fromCompact(signature).addRecoveryBit(Number(recovery))\n  const senderPubKey = sig.recoverPublicKey(msgHash)\n  return senderPubKey.toRawBytes(false).slice(1)\n}\n\n/**\n * Convert signature parameters into the format of `eth_sign` RPC method.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */\nexport const toRPCSig = function (\n  v: bigint,\n  r: Uint8Array,\n  s: Uint8Array,\n  chainId?: bigint,\n): string {\n  const recovery = calculateSigRecovery(v, chainId)\n  if (!isValidSigRecovery(recovery)) {\n    throw EthereumJSErrorWithoutCode('Invalid signature v value')\n  }\n\n  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin\n\n  return bytesToHex(concatBytes(setLengthLeft(r, 32), setLengthLeft(s, 32), bigIntToBytes(v)))\n}\n\n/**\n * Convert signature parameters into the format of Compact Signature Representation (EIP-2098).\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @returns Signature\n */\nexport const toCompactSig = function (\n  v: bigint,\n  r: Uint8Array,\n  s: Uint8Array,\n  chainId?: bigint,\n): string {\n  const recovery = calculateSigRecovery(v, chainId)\n  if (!isValidSigRecovery(recovery)) {\n    throw EthereumJSErrorWithoutCode('Invalid signature v value')\n  }\n\n  const ss = Uint8Array.from([...s])\n  if ((v > BigInt(28) && v % BIGINT_2 === BIGINT_1) || v === BIGINT_1 || v === BigInt(28)) {\n    ss[0] |= 0x80\n  }\n\n  return bytesToHex(concatBytes(setLengthLeft(r, 32), setLengthLeft(ss, 32)))\n}\n\n/**\n * Convert signature format of the `eth_sign` RPC method to signature parameters\n *\n * NOTE: For an extracted `v` value < 27 (see Geth bug https://github.com/ethereum/go-ethereum/issues/2053)\n * `v + 27` is returned for the `v` value\n * NOTE: After EIP1559, `v` could be `0` or `1` but this function assumes\n * it's a signed message (EIP-191 or EIP-712) adding `27` at the end. Remove if needed.\n */\nexport const fromRPCSig = function (sig: PrefixedHexString): {\n  v: bigint\n  r: Uint8Array\n  s: Uint8Array\n} {\n  const bytes: Uint8Array = hexToBytes(sig)\n\n  let r: Uint8Array\n  let s: Uint8Array\n  let v: bigint\n  if (bytes.length >= 65) {\n    r = bytes.subarray(0, 32)\n    s = bytes.subarray(32, 64)\n    v = bytesToBigInt(bytes.subarray(64))\n  } else if (bytes.length === 64) {\n    // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)\n    r = bytes.subarray(0, 32)\n    s = bytes.subarray(32, 64)\n    v = BigInt(bytesToInt(bytes.subarray(32, 33)) >> 7)\n    s[0] &= 0x7f\n  } else {\n    throw EthereumJSErrorWithoutCode('Invalid signature length')\n  }\n\n  // support both versions of `eth_sign` responses\n  if (v < 27) {\n    // TODO: verify this behavior, and verify in which context this method (`fromRPCSig`) is used\n    v = v + BIGINT_27\n  }\n\n  return {\n    v,\n    r,\n    s,\n  }\n}\n\n/**\n * Validate a ECDSA signature.\n * NOTE: Accepts `v === 0 | v === 1` for EIP1559 transactions\n * @param homesteadOrLater Indicates whether this is being used on either the homestead hardfork or a later one\n */\nexport const isValidSignature = function (\n  v: bigint,\n  r: Uint8Array,\n  s: Uint8Array,\n  homesteadOrLater: boolean = true,\n  chainId?: bigint,\n): boolean {\n  if (r.length !== 32 || s.length !== 32) {\n    return false\n  }\n\n  if (!isValidSigRecovery(calculateSigRecovery(v, chainId))) {\n    return false\n  }\n\n  const rBigInt = bytesToBigInt(r)\n  const sBigInt = bytesToBigInt(s)\n\n  if (\n    rBigInt === BIGINT_0 ||\n    rBigInt >= SECP256K1_ORDER ||\n    sBigInt === BIGINT_0 ||\n    sBigInt >= SECP256K1_ORDER\n  ) {\n    return false\n  }\n\n  if (homesteadOrLater && sBigInt >= SECP256K1_ORDER_DIV_2) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.\n * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`\n * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key\n * used to produce the signature.\n */\nexport const hashPersonalMessage = function (message: Uint8Array): Uint8Array {\n  assertIsBytes(message)\n  const prefix = utf8ToBytes(`\\u0019Ethereum Signed Message:\\n${message.length}`)\n  return keccak256(concatBytes(prefix, message))\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1719, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/authorization.js","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40web3auth/no-modal/node_modules/%40ethereumjs/util/src/authorization.ts"],"sourcesContent":["// Utility helpers to convert authorization lists from the byte format and JSON format and vice versa\n\nimport { EthereumJSErrorWithoutCode, RLP } from '@ethereumjs/rlp'\nimport { keccak256 } from 'ethereum-cryptography/keccak.js'\nimport { secp256k1 } from 'ethereum-cryptography/secp256k1.js'\nimport { publicToAddress } from './account.ts'\nimport { Address } from './address.ts'\nimport {\n  bigIntToUnpaddedBytes,\n  bytesToBigInt,\n  bytesToHex,\n  concatBytes,\n  hexToBytes,\n  setLengthLeft,\n  unpadBytes,\n} from './bytes.ts'\nimport { ecrecover } from './signature.ts'\nimport type {\n  EOACode7702AuthorizationListBytesItem,\n  EOACode7702AuthorizationListBytesItemUnsigned,\n  EOACode7702AuthorizationListItem,\n  EOACode7702AuthorizationListItemUnsigned,\n} from './types.ts'\n\nexport const EOA_CODE_7702_AUTHORITY_SIGNING_MAGIC = hexToBytes('0x05')\n\n/**\n * Converts an authorization list to a JSON format\n * @param authorizationList\n * @returns authorizationList in JSON format\n */\nexport function eoaCode7702AuthorizationListBytesItemToJSON(\n  authorizationList: EOACode7702AuthorizationListBytesItem,\n): EOACode7702AuthorizationListItem {\n  const [chainId, address, nonce, yParity, r, s] = authorizationList\n  return {\n    chainId: bytesToHex(chainId),\n    address: bytesToHex(address),\n    nonce: bytesToHex(nonce),\n    yParity: bytesToHex(yParity),\n    r: bytesToHex(r),\n    s: bytesToHex(s),\n  }\n}\n\n/**\n * Converts an authority list in JSON to a bytes format\n * @param authorizationList\n * @returns bytes format of the authority list\n */\nexport function eoaCode7702AuthorizationListJSONItemToBytes(\n  authorizationList: EOACode7702AuthorizationListItem,\n): EOACode7702AuthorizationListBytesItem {\n  const requiredFields = ['chainId', 'address', 'nonce', 'yParity', 'r', 's'] as const\n\n  // Validate all required fields are present\n  for (const field of requiredFields) {\n    if (authorizationList[field] === undefined) {\n      throw EthereumJSErrorWithoutCode(\n        `EIP-7702 authorization list invalid: ${field} is not defined`,\n      )\n    }\n  }\n\n  return [\n    hexToBytes(authorizationList.chainId),\n    hexToBytes(authorizationList.address),\n    hexToBytes(authorizationList.nonce),\n    hexToBytes(authorizationList.yParity),\n    hexToBytes(authorizationList.r),\n    hexToBytes(authorizationList.s),\n  ]\n}\n\n/** Authorization signing utility methods */\nfunction unsignedAuthorizationListToBytes(input: EOACode7702AuthorizationListItemUnsigned) {\n  const { chainId: chainIdHex, address: addressHex, nonce: nonceHex } = input\n  const chainId = hexToBytes(chainIdHex)\n  const address = setLengthLeft(hexToBytes(addressHex), 20)\n  const nonce = hexToBytes(nonceHex)\n  return [chainId, address, nonce]\n}\n\n/**\n * Returns the bytes (RLP-encoded) to sign\n * @param input Either the bytes or the object format of the authorization list item\n * @returns\n */\nexport function eoaCode7702AuthorizationMessageToSign(\n  input: EOACode7702AuthorizationListItemUnsigned | EOACode7702AuthorizationListBytesItemUnsigned,\n) {\n  if (Array.isArray(input)) {\n    // The address is validated, the chainId and nonce will be `unpadBytes` such that these are valid\n    const [chainId, address, nonce] = input\n    if (address.length !== 20) {\n      throw EthereumJSErrorWithoutCode('Cannot sign authority: address length should be 20 bytes')\n    }\n    return concatBytes(\n      EOA_CODE_7702_AUTHORITY_SIGNING_MAGIC,\n      RLP.encode([unpadBytes(chainId), address, unpadBytes(nonce)]),\n    )\n  } else {\n    const [chainId, address, nonce] = unsignedAuthorizationListToBytes(input)\n    return concatBytes(EOA_CODE_7702_AUTHORITY_SIGNING_MAGIC, RLP.encode([chainId, address, nonce]))\n  }\n}\n\n/**\n * Hashes the RLP-encoded message to sign\n * @param input\n * @returns\n */\nexport function eoaCode7702AuthorizationHashedMessageToSign(\n  input: EOACode7702AuthorizationListItemUnsigned | EOACode7702AuthorizationListBytesItemUnsigned,\n) {\n  return keccak256(eoaCode7702AuthorizationMessageToSign(input))\n}\n\n/**\n * Signs an authorization list item and returns it in `bytes` format.\n * To get the JSON format, use `authorizationListBytesToJSON([signed])[0] to convert it`\n * @param input\n * @param privateKey\n * @param ecSign\n * @returns\n */\nexport function eoaCode7702SignAuthorization(\n  input: EOACode7702AuthorizationListItemUnsigned | EOACode7702AuthorizationListBytesItemUnsigned,\n  privateKey: Uint8Array,\n  ecSign?: (\n    msg: Uint8Array,\n    pk: Uint8Array,\n    ecSignOpts?: { extraEntropy?: Uint8Array | boolean },\n  ) => Pick<ReturnType<typeof secp256k1.sign>, 'recovery' | 'r' | 's'>,\n): EOACode7702AuthorizationListBytesItem {\n  const msgHash = eoaCode7702AuthorizationHashedMessageToSign(input)\n  const secp256k1Sign = ecSign ?? secp256k1.sign\n  const signed = secp256k1Sign(msgHash, privateKey)\n  const [chainId, address, nonce] = Array.isArray(input)\n    ? input\n    : unsignedAuthorizationListToBytes(input)\n\n  return [\n    chainId,\n    address,\n    nonce,\n    bigIntToUnpaddedBytes(BigInt(signed.recovery)),\n    bigIntToUnpaddedBytes(signed.r),\n    bigIntToUnpaddedBytes(signed.s),\n  ]\n}\n\nexport function eoaCode7702RecoverAuthority(\n  input: EOACode7702AuthorizationListItem | EOACode7702AuthorizationListBytesItem,\n): Address {\n  const inputBytes = Array.isArray(input)\n    ? input\n    : eoaCode7702AuthorizationListJSONItemToBytes(input)\n  const [chainId, address, nonce, yParity, r, s] = inputBytes\n  const msgHash = eoaCode7702AuthorizationHashedMessageToSign([chainId, address, nonce])\n  const pubKey = ecrecover(msgHash, bytesToBigInt(yParity), r, s)\n  return new Address(publicToAddress(pubKey))\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1852, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/binaryTree.js","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40web3auth/no-modal/node_modules/%40ethereumjs/util/src/binaryTree.ts"],"sourcesContent":["import {\n  bigIntToBytes,\n  bytesToBigInt,\n  bytesToInt32,\n  concatBytes,\n  int32ToBytes,\n  intToBytes,\n  setLengthLeft,\n  setLengthRight,\n} from './bytes.ts'\n\nimport type { Account } from './account.ts'\nimport type { Address } from './address.ts'\nimport type { PrefixedHexString } from './types.ts'\n\n/**\n * @dev Returns the 31-bytes binary tree stem for a given address and tree index.\n * @param hashFunction The hashFunction for the binary tree\n * @param {Address} address The address to generate the tree key for.\n * @param treeIndex The index of the tree to generate the key for. Defaults to 0.\n * @return The 31-bytes binary tree stem as a Uint8Array.\n */\nexport function getBinaryTreeStem(\n  hashFunction: (value: Uint8Array) => Uint8Array,\n  address: Address,\n  treeIndex: number | bigint = 0,\n): Uint8Array {\n  const address32 = setLengthLeft(address.toBytes(), 32)\n\n  let treeIndexBytes: Uint8Array\n  if (typeof treeIndex === 'number') {\n    treeIndexBytes = setLengthRight(int32ToBytes(Number(treeIndex), true), 32)\n  } else {\n    treeIndexBytes = setLengthRight(bigIntToBytes(BigInt(treeIndex), true).slice(0, 32), 32)\n  }\n\n  const treeStem = hashFunction(concatBytes(address32, treeIndexBytes)).slice(0, 31)\n\n  return treeStem\n}\n\nexport interface BinaryTreeStateDiff {\n  stem: PrefixedHexString\n  suffixDiffs: {\n    currentValue: PrefixedHexString | null\n    newValue: PrefixedHexString | null\n    suffix: number | string\n  }[]\n}\n\n// TODO: This is a placeholder type, the actual type is not yet defined\nexport type BinaryTreeProof = any\n\n/**\n * Experimental, object format could eventual change.\n * An object that provides the state and proof necessary for binary tree stateless execution\n * */\nexport interface BinaryTreeExecutionWitness {\n  /**\n   * The stateRoot of the parent block\n   */\n  parentStateRoot: PrefixedHexString\n  /**\n   * An array of state diffs.\n   * Each item corresponding to state accesses or state modifications of the block.\n   * In the current design, it also contains the resulting state of the block execution (post-state).\n   */\n  stateDiff: BinaryTreeStateDiff[]\n  /**\n   * The proof for the block.\n   * Proves that the provided stateDiff belongs to the canonical binary tree.\n   */\n  proof: BinaryTreeProof\n}\n\nexport type BinaryTreeLeafType = (typeof BinaryTreeLeafType)[keyof typeof BinaryTreeLeafType]\n\nexport const BinaryTreeLeafType = {\n  BasicData: 0,\n  CodeHash: 1,\n} as const\n\nexport type BinaryTreeLeafBasicData = {\n  version: number\n  nonce: bigint\n  balance: bigint\n  codeSize: number\n}\n\nexport const BINARY_TREE_VERSION_OFFSET = 0\nexport const BINARY_TREE_CODE_SIZE_OFFSET = 5\nexport const BINARY_TREE_NONCE_OFFSET = 8\nexport const BINARY_TREE_BALANCE_OFFSET = 16\n\nexport const BINARY_TREE_VERSION_BYTES_LENGTH = 1\nexport const BINARY_TREE_CODE_SIZE_BYTES_LENGTH = 3\nexport const BINARY_TREE_NONCE_BYTES_LENGTH = 8\nexport const BINARY_TREE_BALANCE_BYTES_LENGTH = 16\n\nexport const BINARY_TREE_BASIC_DATA_LEAF_KEY = intToBytes(BinaryTreeLeafType.BasicData)\nexport const BINARY_TREE_CODE_HASH_LEAF_KEY = intToBytes(BinaryTreeLeafType.CodeHash)\n\nexport const BINARY_TREE_CODE_CHUNK_SIZE = 31\nexport const BINARY_TREE_HEADER_STORAGE_OFFSET = 64\nexport const BINARY_TREE_CODE_OFFSET = 128\nexport const BINARY_TREE_NODE_WIDTH = 256\nexport const BINARY_TREE_MAIN_STORAGE_OFFSET = BigInt(256) ** BigInt(BINARY_TREE_CODE_CHUNK_SIZE)\n\n/**\n * @dev Returns the tree key for a given binary tree stem, and sub index.\n * @dev Assumes that the tree node width = 256\n * @param stem The 31-bytes binary tree stem as a Uint8Array.\n * @param subIndex The sub index of the tree to generate the key for as a Uint8Array.\n * @return The tree key as a Uint8Array.\n */\nexport const getBinaryTreeKey = (stem: Uint8Array, leaf: BinaryTreeLeafType | Uint8Array) => {\n  switch (leaf) {\n    case BinaryTreeLeafType.BasicData:\n      return concatBytes(stem, BINARY_TREE_BASIC_DATA_LEAF_KEY)\n    case BinaryTreeLeafType.CodeHash:\n      return concatBytes(stem, BINARY_TREE_CODE_HASH_LEAF_KEY)\n    default:\n      return concatBytes(stem, leaf)\n  }\n}\n\n/**\n * Calculates the position of the storage key in the BinaryTree tree, determining\n * both the tree index (the node in the tree) and the subindex (the position within the node).\n * @param {bigint} storageKey - The key representing a specific storage slot.\n * @returns {Object} - An object containing the tree index and subindex\n */\nexport function getBinaryTreeIndicesForStorageSlot(storageKey: bigint): {\n  treeIndex: bigint\n  subIndex: number\n} {\n  let position: bigint\n  if (storageKey < BINARY_TREE_CODE_OFFSET - BINARY_TREE_HEADER_STORAGE_OFFSET) {\n    position = BigInt(BINARY_TREE_HEADER_STORAGE_OFFSET) + storageKey\n  } else {\n    position = BINARY_TREE_MAIN_STORAGE_OFFSET + storageKey\n  }\n\n  const treeIndex = position / BigInt(BINARY_TREE_NODE_WIDTH)\n  const subIndex = Number(position % BigInt(BINARY_TREE_NODE_WIDTH))\n\n  return { treeIndex, subIndex }\n}\n\n/**\n * Calculates the position of the code chunks in the BinaryTree tree, determining\n * both the tree index (the node in the tree) and the subindex (the position within the node).\n * @param {bigint} chunkId - The ID representing a specific chunk.\n * @returns {Object} - An object containing the tree index and subindex\n */\nexport function getBinaryTreeIndicesForCodeChunk(chunkId: number) {\n  const treeIndex = Math.floor((BINARY_TREE_CODE_OFFSET + chunkId) / BINARY_TREE_NODE_WIDTH)\n  const subIndex = (BINARY_TREE_CODE_OFFSET + chunkId) % BINARY_TREE_NODE_WIDTH\n  return { treeIndex, subIndex }\n}\n\n/**\n * Asynchronously calculates the BinaryTree tree key for the specified code chunk ID.\n * @param {Address} address - The account address to access code for.\n * @param {number} chunkId - The ID of the code chunk to retrieve.\n * @param hashFunction - The hash function used for BinaryTree-related operations.\n * @returns {Uint8Array} - The BinaryTree tree key as a byte array.\n */\nexport const getBinaryTreeKeyForCodeChunk = (\n  address: Address,\n  chunkId: number,\n  hashFunction: (input: Uint8Array) => Uint8Array,\n) => {\n  const { treeIndex, subIndex } = getBinaryTreeIndicesForCodeChunk(chunkId)\n  return concatBytes(getBinaryTreeStem(hashFunction, address, treeIndex), intToBytes(subIndex))\n}\n\n// This code was written by robots based on the reference implementation in EIP-7864\nexport const chunkifyBinaryTreeCode = (code: Uint8Array) => {\n  const PUSH1 = 0x60 // Assuming PUSH1 is defined as 0x60\n  const PUSH32 = 0x7f // Assuming PUSH32 is defined as 0x7f\n  const PUSH_OFFSET = 0x5f // Assuming PUSH_OFFSET is defined as 0x5f\n\n  // Calculate padding length\n  const paddingLength = (31 - (code.length % 31)) % 31\n  const paddedCode = new Uint8Array(code.length + paddingLength)\n  paddedCode.set(code)\n\n  // Pre-allocate the bytesToExecData array\n  const bytesToExecData = new Uint8Array(paddedCode.length + 32)\n\n  let pos = 0\n  while (pos < paddedCode.length) {\n    let pushdataBytes = 0\n    if (PUSH1 <= paddedCode[pos] && paddedCode[pos] <= PUSH32) {\n      pushdataBytes = paddedCode[pos] - PUSH_OFFSET\n    }\n    pos += 1\n    for (let x = 0; x < pushdataBytes; x++) {\n      bytesToExecData[pos + x] = pushdataBytes - x\n    }\n    pos += pushdataBytes\n  }\n\n  // Pre-allocate the chunks array\n  const numChunks = Math.ceil(paddedCode.length / 31)\n  const chunks = new Array<Uint8Array>(numChunks)\n\n  for (let i = 0, pos = 0; i < numChunks; i++, pos += 31) {\n    const chunk = new Uint8Array(32)\n    chunk[0] = Math.min(bytesToExecData[pos], 31)\n    chunk.set(paddedCode.subarray(pos, pos + 31), 1)\n    chunks[i] = chunk\n  }\n\n  return chunks\n}\n\n/**\n * Asynchronously calculates the BinaryTree tree key for the specified storage slot.\n * @param {Address} address - The account address to access code for.\n * @param {bigint} storageKey - The storage slot key to retrieve the key for.\n * @param hashFunction - The hash function used in the Binary Tree.\n * @returns {Uint8Array} - The BinaryTree tree key as a byte array.\n */\nexport const getBinaryTreeKeyForStorageSlot = (\n  address: Address,\n  storageKey: bigint,\n  hashFunction: (input: Uint8Array) => Uint8Array,\n) => {\n  const { treeIndex, subIndex } = getBinaryTreeIndicesForStorageSlot(storageKey)\n\n  return concatBytes(getBinaryTreeStem(hashFunction, address, treeIndex), intToBytes(subIndex))\n}\n\n/**\n * This function extracts and decodes account header elements (version, nonce, code size, and balance)\n * from an encoded `Uint8Array` representation of raw BinaryTree leaf-node basic data. Each component is sliced\n * from the `encodedBasicData` array based on predefined offsets and lengths, and then converted\n * to its appropriate type (integer or BigInt).\n * @param {Uint8Array} encodedBasicData - The encoded BinaryTree leaf basic data containing the version, nonce,\n * code size, and balance in a compact Uint8Array format.\n * @returns {BinaryTreeLeafBasicData} - An object containing the decoded version, nonce, code size, and balance.\n */\nexport function decodeBinaryTreeLeafBasicData(\n  encodedBasicData: Uint8Array,\n): BinaryTreeLeafBasicData {\n  const versionBytes = encodedBasicData.slice(0, BINARY_TREE_VERSION_BYTES_LENGTH)\n  const nonceBytes = encodedBasicData.slice(\n    BINARY_TREE_NONCE_OFFSET,\n    BINARY_TREE_NONCE_OFFSET + BINARY_TREE_NONCE_BYTES_LENGTH,\n  )\n  const codeSizeBytes = encodedBasicData.slice(\n    BINARY_TREE_CODE_SIZE_OFFSET,\n    BINARY_TREE_CODE_SIZE_OFFSET + BINARY_TREE_CODE_SIZE_BYTES_LENGTH,\n  )\n  const balanceBytes = encodedBasicData.slice(\n    BINARY_TREE_BALANCE_OFFSET,\n    BINARY_TREE_BALANCE_OFFSET + BINARY_TREE_BALANCE_BYTES_LENGTH,\n  )\n\n  const version = bytesToInt32(versionBytes)\n  const nonce = bytesToBigInt(nonceBytes)\n  const codeSize = bytesToInt32(codeSizeBytes)\n  const balance = bytesToBigInt(balanceBytes)\n\n  return { version, nonce, codeSize, balance }\n}\n\n/**\n * This function takes a `BinaryTreeLeafBasicData` object and encodes its properties\n * (version, nonce, code size, and balance) into a compact `Uint8Array` format. Each\n * property is serialized and padded to match the required byte lengths defined by\n * EIP-7864. Additionally, 4 bytes are reserved for future use as specified\n * in EIP-7864.\n * @param {Account} account - An object containing the version, nonce,\n *   code size, and balance to be encoded.\n * @returns {Uint8Array} - A compact bytes representation of the account header basic data.\n */\nexport function encodeBinaryTreeLeafBasicData(account: Account): Uint8Array {\n  const encodedVersion = setLengthLeft(\n    int32ToBytes(account.version),\n    BINARY_TREE_VERSION_BYTES_LENGTH,\n  )\n  // Per EIP-7864, bytes 1-4 are reserved for future use\n  const reservedBytes = new Uint8Array([0, 0, 0, 0])\n  const encodedNonce = setLengthLeft(bigIntToBytes(account.nonce), BINARY_TREE_NONCE_BYTES_LENGTH)\n  const encodedCodeSize = setLengthLeft(\n    int32ToBytes(account.codeSize),\n    BINARY_TREE_CODE_SIZE_BYTES_LENGTH,\n  )\n  const encodedBalance = setLengthLeft(\n    bigIntToBytes(account.balance),\n    BINARY_TREE_BALANCE_BYTES_LENGTH,\n  )\n  return concatBytes(encodedVersion, reservedBytes, encodedCodeSize, encodedNonce, encodedBalance)\n}\n\n/**\n * Helper method to generate the suffixes for code chunks for putting code\n * @param numChunks number of chunks to generate suffixes for\n * @returns number[] - an array of numbers corresponding to the code chunks being put\n */\nexport const generateBinaryTreeChunkSuffixes = (numChunks: number) => {\n  if (numChunks === 0) return []\n  const chunkSuffixes: number[] = new Array<number>(numChunks)\n  let currentSuffix = BINARY_TREE_CODE_OFFSET\n  for (let x = 0; x < numChunks; x++) {\n    chunkSuffixes[x] = currentSuffix\n    currentSuffix++\n    // Reset suffix to 0 if exceeds BINARY_TREE_NODE_WIDTH\n    if (currentSuffix >= BINARY_TREE_NODE_WIDTH) currentSuffix = 0\n  }\n\n  return chunkSuffixes\n}\n\n/**\n * Helper method for generating the code stems necessary for putting code\n * @param numChunks the number of code chunks to be put\n * @param address the address of the account getting the code\n * @param hashFunction an initialized {@link BinaryTreeCrypto} object\n * @returns an array of stems for putting code\n */\nexport function generateBinaryTreeCodeStems(\n  numChunks: number,\n  address: Address,\n  hashFunction: (input: Uint8Array) => Uint8Array,\n): Uint8Array[] {\n  // The maximum number of chunks is 793 (maxCodeSize - 24576) / (bytes per chunk 31) + (round up - 1)\n  // Code is stored in chunks starting at leaf index 128 of the leaf node corresponding to the stem of the code's address\n  // Code chunks beyond the initial 128 are stored in additional leaf nodes in batches up of up to 256 chunks per leaf node\n  // so the maximum number of leaf nodes that can hold contract code for a specific address is 4 leaf nodes (128 chunks in\n  // the first leaf node and 256 chunks in up to 3 additional leaf nodes)\n  // So, instead of computing every single leaf key (which is a heavy operation), we just compute the stem for the first\n  // chunk in each leaf node and can then know that the chunks in between have tree keys in monotonically increasing order\n  const numStems =\n    numChunks > BINARY_TREE_CODE_OFFSET ? Math.ceil(numChunks / BINARY_TREE_NODE_WIDTH) + 1 : 1\n  const chunkStems = new Array<Uint8Array>(numStems)\n  // Compute the stem for the initial set of code chunks\n  chunkStems[0] = getBinaryTreeKeyForCodeChunk(address, 0, hashFunction).slice(0, 31)\n\n  for (let stemNum = 0; stemNum < numStems - 1; stemNum++) {\n    // Generate additional stems\n    const firstChunkKey = getBinaryTreeKeyForCodeChunk(\n      address,\n      BINARY_TREE_CODE_OFFSET + stemNum * BINARY_TREE_NODE_WIDTH,\n      hashFunction,\n    )\n    chunkStems[stemNum + 1] = firstChunkKey.slice(0, 31)\n  }\n  return chunkStems\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2078, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/blobs.js","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40web3auth/no-modal/node_modules/%40ethereumjs/util/src/blobs.ts"],"sourcesContent":["import { sha256 } from 'ethereum-cryptography/sha256.js'\n\nimport { bytesToHex, hexToBytes, utf8ToBytes } from './bytes.ts'\n\nimport type { KZG } from './kzg.ts'\nimport type { PrefixedHexString } from './types.ts'\n\n/**\n * These utilities for constructing blobs are borrowed from https://github.com/Inphi/eip4844-interop.git\n */\nconst BYTES_PER_FIELD_ELEMENT = 32 // EIP-4844\nconst FIELD_ELEMENTS_PER_BLOB = 4096 // EIP-4844\nconst BLOB_SIZE = BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB\n\nconst MAX_BLOBS_PER_TX = 6 // EIP-7691: Blob throughput increase, Pectra HF\nconst MAX_BLOB_BYTES_PER_TX = BLOB_SIZE * MAX_BLOBS_PER_TX - 1\n\nexport const CELLS_PER_EXT_BLOB = 128 // EIP-4844, Consensus Spec, 2 * FIELD_ELEMENTS_PER_BLOB // 64 (FIELD_ELEMENTS_PER_CELL)\n\n/**\n * Pads input data to blob boundaries with 0x80 marker and zeros.\n * @param data Input data to pad\n * @param blobs_len Number of blobs the data should span\n * @returns Padded data aligned to blob boundaries\n */\nfunction getPadded(data: Uint8Array, blobs_len: number): Uint8Array {\n  const pData = new Uint8Array(blobs_len * BLOB_SIZE)\n  pData.set(data)\n  pData[data.byteLength] = 0x80\n  return pData\n}\n\n/**\n * Converts arbitrary byte data into EIP-4844 blob format.\n * Splits data into 4096 field elements of 32 bytes each, with proper alignment.\n * @param data Input data (must be exactly BLOB_SIZE bytes)\n * @returns Hex-prefixed blob string\n */\nfunction getBlob(data: Uint8Array): PrefixedHexString {\n  const blob = new Uint8Array(BLOB_SIZE)\n  for (let i = 0; i < FIELD_ELEMENTS_PER_BLOB; i++) {\n    const chunk = new Uint8Array(32)\n    chunk.set(data.subarray(i * 31, (i + 1) * 31), 0)\n    blob.set(chunk, i * 32)\n  }\n\n  return bytesToHex(blob)\n}\n\n/**\n * EIP-4844: Converts UTF-8 string(s) into EIP-4844 blob format.\n *\n * Each input string is converted to UTF-8 bytes, padded with 0x80 followed by zeros\n * to align with blob boundaries, and encoded as one or more blobs depending on size.\n * Multiple inputs are processed sequentially, with each input contributing its own blob(s).\n *\n * @param input Single UTF-8 string or array of UTF-8 strings to encode\n * @throws Error with message 'invalid blob data' if any input string is empty\n * @throws Error with message 'blob data is too large' if any single input exceeds MAX_USEFUL_BYTES_PER_TX\n * @returns Array of hex-prefixed blob strings (0x...), one blob per 131,071 useful bytes per input\n */\nexport const getBlobs = (input: string | string[]) => {\n  const inputArray = Array.isArray(input) ? input : [input]\n  const blobs: PrefixedHexString[] = []\n\n  for (const input of inputArray) {\n    const data = utf8ToBytes(input)\n    const len = data.byteLength\n    if (len === 0) {\n      throw Error('invalid blob data (0 bytes)')\n    }\n    if (len > MAX_BLOB_BYTES_PER_TX) {\n      throw Error(`blob data is too large (${len} bytes > ${MAX_BLOB_BYTES_PER_TX} bytes)`)\n    }\n\n    const blobs_len = Math.ceil(len / BLOB_SIZE)\n\n    const pData = getPadded(data, blobs_len)\n\n    for (let i = 0; i < blobs_len; i++) {\n      const chunk = pData.subarray(i * BLOB_SIZE, (i + 1) * BLOB_SIZE)\n      const blob = getBlob(chunk)\n      blobs.push(blob)\n    }\n  }\n\n  return blobs\n}\n\n/**\n * EIP-4844: Computes KZG commitments for a set of blobs.\n * @param kzg KZG implementation used to compute commitments\n * @param blobs Array of blob data as hex-prefixed strings\n * @returns Array of lowercase hex-prefixed KZG commitments (one per blob)\n */\nexport const blobsToCommitments = (kzg: KZG, blobs: PrefixedHexString[]) => {\n  const commitments: PrefixedHexString[] = []\n  for (const blob of blobs) {\n    commitments.push(kzg.blobToKzgCommitment(blob).toLowerCase() as PrefixedHexString)\n  }\n  return commitments\n}\n\n/**\n * EIP-4844: Computes KZG proofs for each blob/commitment pair.\n * @param kzg KZG implementation used to compute proofs\n * @param blobs Array of blob data as hex-prefixed strings\n * @param commitments Array of corresponding blob commitments\n * @returns Array of lowercase hex-prefixed proofs (aligned with input order)\n */\nexport const blobsToProofs = (\n  kzg: KZG,\n  blobs: PrefixedHexString[],\n  commitments: PrefixedHexString[],\n) => {\n  const proofs = blobs.map((blob, ctx) =>\n    kzg.computeBlobProof(blob, commitments[ctx]).toLowerCase(),\n  ) as PrefixedHexString[]\n\n  return proofs\n}\n\n/**\n * EIP-4844: Converts a vector commitment for a given data blob to its versioned hash.  For 4844, this version\n * number will be 0x01 for KZG vector commitments but could be different if future vector commitment\n * types are introduced\n * @param commitment a vector commitment to a blob\n * @param blobCommitmentVersion the version number corresponding to the type of vector commitment\n * @returns a versioned hash corresponding to a given blob vector commitment\n */\nexport const computeVersionedHash = (\n  commitment: PrefixedHexString,\n  blobCommitmentVersion: number,\n) => {\n  const computedVersionedHash = new Uint8Array(32)\n  computedVersionedHash.set([blobCommitmentVersion], 0)\n  computedVersionedHash.set(sha256(hexToBytes(commitment)).subarray(1), 1)\n  return bytesToHex(computedVersionedHash)\n}\n\n/**\n * EIP-4844: Generate an array of versioned hashes from corresponding kzg commitments\n * @param commitments array of kzg commitments\n * @returns array of versioned hashes\n * Note: assumes KZG commitments (version 1 version hashes)\n */\nexport const commitmentsToVersionedHashes = (commitments: PrefixedHexString[]) => {\n  const hashes: PrefixedHexString[] = []\n  for (const commitment of commitments) {\n    hashes.push(computeVersionedHash(commitment, 0x01))\n  }\n  return hashes\n}\n\n/**\n * EIP-7594: Expands blobs into their extended cells using the provided KZG implementation.\n * @param kzg KZG implementation capable of computing cells\n * @param blobs Array of blob data as hex-prefixed strings\n * @returns Tuple of [cells, indices], where cells are hex strings and indices are 0..127\n */\nexport const blobsToCells = (\n  kzg: KZG,\n  blobs: PrefixedHexString[],\n): [PrefixedHexString[], number[]] => {\n  const cells = blobs.reduce((acc, elem) => {\n    return [...acc, ...(kzg.computeCells(elem) as PrefixedHexString[])]\n  }, [] as PrefixedHexString[])\n  const indices = Array.from({ length: CELLS_PER_EXT_BLOB }, (_, i) => i)\n\n  return [cells, indices]\n}\n\n/**\n * EIP-7594: Computes extended cells and corresponding proofs for the given blobs.\n * @param kzg KZG implementation capable of computing cells and proofs\n * @param blobs Array of blob data as hex-prefixed strings\n * @returns Tuple of [cells, proofs, indices]; indices are 0..127\n */\nexport const blobsToCellsAndProofs = (\n  kzg: KZG,\n  blobs: PrefixedHexString[],\n): [PrefixedHexString[], PrefixedHexString[], number[]] => {\n  const blobsAndCells = blobs.reduce(\n    ([cellsAcc, proofsAcc], elem) => {\n      const blobCellsAndProofs = kzg.computeCellsAndProofs(elem) as [\n        PrefixedHexString[],\n        PrefixedHexString[],\n      ]\n      return [\n        [...cellsAcc, ...blobCellsAndProofs[0]],\n        [...proofsAcc, ...blobCellsAndProofs[1]],\n      ]\n    },\n    [[] as PrefixedHexString[], [] as PrefixedHexString[]],\n  )\n\n  const indices = Array.from({ length: CELLS_PER_EXT_BLOB }, (_, i) => i)\n  return [...blobsAndCells, indices] as [PrefixedHexString[], PrefixedHexString[], number[]]\n}\n\n/**\n * EIP-7594: Computes cell proofs for the given blobs.\n * @param kzg KZG implementation capable of computing cell proofs\n * @param blobs Array of blob data as hex-prefixed strings\n * @returns Array of lowercase hex-prefixed cell proofs (aligned with input order)\n */\nexport const blobsToCellProofs = (kzg: KZG, blobs: PrefixedHexString[]): PrefixedHexString[] => {\n  return blobsToCellsAndProofs(kzg, blobs)[1] as PrefixedHexString[]\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2233, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/kzg.js","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40web3auth/no-modal/node_modules/%40ethereumjs/util/src/kzg.ts"],"sourcesContent":["/**\n * Interface for an externally provided kzg library used when creating blob transactions\n */\nexport interface KZG {\n  // eip-4844\n  blobToKzgCommitment(blob: string): string\n  computeBlobProof(blob: string, commitment: string): string\n  verifyProof(polynomialKZG: string, z: string, y: string, KZGProof: string): boolean\n  verifyBlobProofBatch(\n    blobs: string[],\n    expectedKZGCommitments: string[],\n    KZGProofs: string[],\n  ): boolean\n  // eip-7594\n  computeCells(blob: string): string[]\n  computeCellsAndProofs(blob: string): [string[], string[]]\n  recoverCellsAndProofs(indices: number[], cells: string[]): [string[], string[]]\n  verifyCellKzgProofBatch(\n    commitments: string[],\n    indices: number[],\n    cells: string[],\n    proofs: string[],\n  ): boolean\n}\n"],"names":[],"mappings":""}},
    {"offset": {"line": 2240, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/lock.js","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40web3auth/no-modal/node_modules/%40ethereumjs/util/src/lock.ts"],"sourcesContent":["// Based on https://github.com/jsoendermann/semaphore-async-await/blob/master/src/Semaphore.ts\nexport class Lock {\n  private permits: number = 1\n  private promiseResolverQueue: Array<(v: boolean) => void> = []\n\n  /**\n   * Returns a promise used to wait for a permit to become available. This method should be awaited on.\n   * @returns  A promise that gets resolved when execution is allowed to proceed.\n   */\n  public async acquire(): Promise<boolean> {\n    if (this.permits > 0) {\n      this.permits -= 1\n      return Promise.resolve(true)\n    }\n\n    // If there is no permit available, we return a promise that resolves once the semaphore gets\n    // signaled enough times that permits is equal to one.\n    return new Promise<boolean>((resolver) => this.promiseResolverQueue.push(resolver))\n  }\n\n  /**\n   * Increases the number of permits by one. If there are other functions waiting, one of them will\n   * continue to execute in a future iteration of the event loop.\n   */\n  public release(): void {\n    this.permits += 1\n\n    if (this.permits > 1 && this.promiseResolverQueue.length > 0) {\n      // eslint-disable-next-line no-console\n      console.warn('Lock.permits should never be > 0 when there is someone waiting.')\n    } else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {\n      // If there is someone else waiting, immediately consume the permit that was released\n      // at the beginning of this function and let the waiting function resume.\n      this.permits -= 1\n\n      const nextResolver = this.promiseResolverQueue.shift()\n      if (nextResolver) {\n        nextResolver(true)\n      }\n    }\n  }\n}\n"],"names":[],"mappings":"AAAA,8FAA8F;;;;;AACxF,MAAO,IAAI;IAAjB,aAAA;QACU,IAAA,CAAA,OAAO,GAAW,CAAC,CAAA;QACnB,IAAA,CAAA,oBAAoB,GAAgC,EAAE,CAAA;IAsChE,CAAC;IApCC;;;OAGG,CACI,KAAK,CAAC,OAAO,GAAA;QAClB,IAAI,IAAI,CAAC,OAAO,GAAG,CAAC,EAAE,CAAC;YACrB,IAAI,CAAC,OAAO,IAAI,CAAC,CAAA;YACjB,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA;QAC9B,CAAC;QAED,6FAA6F;QAC7F,sDAAsD;QACtD,OAAO,IAAI,OAAO,CAAU,CAAC,QAAQ,EAAE,CAAG,CAAD,GAAK,CAAC,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAA;IACrF,CAAC;IAED;;;OAGG,CACI,OAAO,GAAA;QACZ,IAAI,CAAC,OAAO,IAAI,CAAC,CAAA;QAEjB,IAAI,IAAI,CAAC,OAAO,GAAG,CAAC,IAAI,IAAI,CAAC,oBAAoB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAC7D,sCAAsC;YACtC,OAAO,CAAC,IAAI,CAAC,iEAAiE,CAAC,CAAA;QACjF,CAAC,MAAM,IAAI,IAAI,CAAC,OAAO,KAAK,CAAC,IAAI,IAAI,CAAC,oBAAoB,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACtE,qFAAqF;YACrF,yEAAyE;YACzE,IAAI,CAAC,OAAO,IAAI,CAAC,CAAA;YAEjB,MAAM,YAAY,GAAG,IAAI,CAAC,oBAAoB,CAAC,KAAK,EAAE,CAAA;YACtD,IAAI,YAAY,EAAE,CAAC;gBACjB,YAAY,CAAC,IAAI,CAAC,CAAA;YACpB,CAAC;QACH,CAAC;IACH,CAAC;CACF"}},
    {"offset": {"line": 2285, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/mapDB.js","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40web3auth/no-modal/node_modules/%40ethereumjs/util/src/mapDB.ts"],"sourcesContent":["import { bytesToUnprefixedHex } from './bytes.ts'\n\nimport type { BatchDBOp, DB, DBObject } from './db.ts'\n\nexport class MapDB<\n  TKey extends Uint8Array | string | number,\n  TValue extends Uint8Array | string | DBObject,\n> implements DB<TKey, TValue>\n{\n  _database: Map<TKey, TValue>\n\n  constructor(database?: Map<TKey, TValue>) {\n    this._database = database ?? new Map<TKey, TValue>()\n  }\n\n  async get(key: TKey): Promise<TValue | undefined> {\n    const dbKey = key instanceof Uint8Array ? bytesToUnprefixedHex(key) : key.toString()\n    return this._database.get(dbKey as TKey)\n  }\n\n  async put(key: TKey, val: TValue): Promise<void> {\n    const dbKey = key instanceof Uint8Array ? bytesToUnprefixedHex(key) : key.toString()\n    this._database.set(dbKey as TKey, val)\n  }\n\n  async del(key: TKey): Promise<void> {\n    const dbKey = key instanceof Uint8Array ? bytesToUnprefixedHex(key) : key.toString()\n    this._database.delete(dbKey as TKey)\n  }\n\n  async batch(opStack: BatchDBOp<TKey, TValue>[]): Promise<void> {\n    for (const op of opStack) {\n      if (op.type === 'del') {\n        await this.del(op.key)\n      }\n\n      if (op.type === 'put') {\n        await this.put(op.key, op.value)\n      }\n    }\n  }\n\n  /**\n   * Note that the returned shallow copy will share the underlying database with the original\n   *\n   * @returns DB\n   */\n  shallowCopy(): DB<TKey, TValue> {\n    return new MapDB<TKey, TValue>(this._database)\n  }\n\n  open() {\n    return Promise.resolve()\n  }\n}\n"],"names":[],"mappings":";;;;AAAA,OAAO,EAAE,oBAAoB,EAAE,MAAM,YAAY,CAAA;;AAI3C,MAAO,KAAK;IAOhB,YAAY,QAA4B,CAAA;QACtC,IAAI,CAAC,SAAS,GAAG,QAAQ,IAAI,IAAI,GAAG,EAAgB,CAAA;IACtD,CAAC;IAED,KAAK,CAAC,GAAG,CAAC,GAAS,EAAA;QACjB,MAAM,KAAK,GAAG,GAAG,YAAY,UAAU,CAAC,CAAC,KAAC,iPAAoB,EAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAA;QACpF,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,KAAa,CAAC,CAAA;IAC1C,CAAC;IAED,KAAK,CAAC,GAAG,CAAC,GAAS,EAAE,GAAW,EAAA;QAC9B,MAAM,KAAK,GAAG,GAAG,YAAY,UAAU,CAAC,CAAC,KAAC,iPAAoB,EAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAA;QACpF,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,KAAa,EAAE,GAAG,CAAC,CAAA;IACxC,CAAC;IAED,KAAK,CAAC,GAAG,CAAC,GAAS,EAAA;QACjB,MAAM,KAAK,GAAG,GAAG,YAAY,UAAU,CAAC,CAAC,KAAC,iPAAoB,EAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAA;QACpF,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,KAAa,CAAC,CAAA;IACtC,CAAC;IAED,KAAK,CAAC,KAAK,CAAC,OAAkC,EAAA;QAC5C,KAAK,MAAM,EAAE,IAAI,OAAO,CAAE,CAAC;YACzB,IAAI,EAAE,CAAC,IAAI,KAAK,KAAK,EAAE,CAAC;gBACtB,MAAM,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAA;YACxB,CAAC;YAED,IAAI,EAAE,CAAC,IAAI,KAAK,KAAK,EAAE,CAAC;gBACtB,MAAM,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,KAAK,CAAC,CAAA;YAClC,CAAC;QACH,CAAC;IACH,CAAC;IAED;;;;OAIG,CACH,WAAW,GAAA;QACT,OAAO,IAAI,KAAK,CAAe,IAAI,CAAC,SAAS,CAAC,CAAA;IAChD,CAAC;IAED,IAAI,GAAA;QACF,OAAO,OAAO,CAAC,OAAO,EAAE,CAAA;IAC1B,CAAC;CACF"}},
    {"offset": {"line": 2332, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/provider.js","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40web3auth/no-modal/node_modules/%40ethereumjs/util/src/provider.ts"],"sourcesContent":["import { EthereumJSErrorWithoutCode } from './errors.ts'\n\ntype rpcParams = {\n  method: string\n  params: (string | string[] | boolean | number)[]\n}\n\n/**\n * Makes a simple RPC call to a remote Ethereum JSON-RPC provider and passes through the response.\n * No parameter or response validation is done.\n *\n * @param url the URL for the JSON RPC provider\n * @param params the parameters for the JSON-RPC method - refer to\n * https://ethereum.org/en/developers/docs/apis/json-rpc/ for details on RPC methods\n * @returns the `result` field from the JSON-RPC response\n * @example\n * ```ts\n * const provider = 'https://mainnet.infura.io/v3/...'\n * const params = {\n *   method: 'eth_getBlockByNumber',\n *   params: ['latest', false],\n * }\n * const block = await fetchFromProvider(provider, params)\n * ```\n */\nexport const fetchFromProvider = async (url: string, params: rpcParams) => {\n  const data = JSON.stringify({\n    method: params.method,\n    params: params.params,\n    jsonrpc: '2.0',\n    id: 1,\n  })\n\n  const res = await fetch(url, {\n    headers: {\n      'content-type': 'application/json',\n    },\n    method: 'POST',\n    body: data,\n  })\n  if (!res.ok) {\n    throw EthereumJSErrorWithoutCode(\n      `JSONRPCError: ${JSON.stringify(\n        {\n          method: params.method,\n          status: res.status,\n          message: await res.text().catch(() => {\n            return 'Could not parse error message likely because of a network error'\n          }),\n        },\n        null,\n        2,\n      )}`,\n    )\n  }\n  const json = await res.json()\n  // TODO we should check json.error here\n  return json.result\n}\n\n/**\n *\n * @param provider a URL string or {@link EthersProvider}\n * @returns the extracted URL string for the JSON-RPC Provider\n */\nexport const getProvider = (provider: string | EthersProvider) => {\n  if (typeof provider === 'string') {\n    return provider\n  } else if (typeof provider === 'object' && provider._getConnection !== undefined) {\n    return provider._getConnection().url\n  } else {\n    throw EthereumJSErrorWithoutCode('Must provide valid provider URL or Web3Provider')\n  }\n}\n\n/**\n * A partial interface for an `ethers` `JSONRPCProvider`\n * We only use the url string since we do raw `fetch` calls to\n * retrieve the necessary data\n */\nexport interface EthersProvider {\n  _getConnection: () => {\n    url: string\n  }\n}\n"],"names":[],"mappings":";;;;;;;AAAA,OAAO,EAAE,0BAA0B,EAAE,MAAM,aAAa,CAAA;;AAyBjD,MAAM,iBAAiB,GAAG,KAAK,EAAE,GAAW,EAAE,MAAiB,EAAE,EAAE;IACxE,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC;QAC1B,MAAM,EAAE,MAAM,CAAC,MAAM;QACrB,MAAM,EAAE,MAAM,CAAC,MAAM;QACrB,OAAO,EAAE,KAAK;QACd,EAAE,EAAE,CAAC;KACN,CAAC,CAAA;IAEF,MAAM,GAAG,GAAG,MAAM,KAAK,CAAC,GAAG,EAAE;QAC3B,OAAO,EAAE;YACP,cAAc,EAAE,kBAAkB;SACnC;QACD,MAAM,EAAE,MAAM;QACd,IAAI,EAAE,IAAI;KACX,CAAC,CAAA;IACF,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC;QACZ,UAAM,uOAA0B,EAC9B,CAAA,cAAA,EAAiB,IAAI,CAAC,SAAS,CAC7B;YACE,MAAM,EAAE,MAAM,CAAC,MAAM;YACrB,MAAM,EAAE,GAAG,CAAC,MAAM;YAClB,OAAO,EAAE,MAAM,GAAG,CAAC,IAAI,EAAE,CAAC,KAAK,CAAC,GAAG,EAAE;gBACnC,OAAO,iEAAiE,CAAA;YAC1E,CAAC,CAAC;SACH,EACD,IAAI,EACJ,CAAC,CACF,EAAE,CACJ,CAAA;IACH,CAAC;IACD,MAAM,IAAI,GAAG,MAAM,GAAG,CAAC,IAAI,EAAE,CAAA;IAC7B,uCAAuC;IACvC,OAAO,IAAI,CAAC,MAAM,CAAA;AACpB,CAAC,CAAA;AAOM,MAAM,WAAW,GAAG,CAAC,QAAiC,EAAE,EAAE;IAC/D,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE,CAAC;QACjC,OAAO,QAAQ,CAAA;IACjB,CAAC,MAAM,IAAI,OAAO,QAAQ,KAAK,QAAQ,IAAI,QAAQ,CAAC,cAAc,KAAK,SAAS,EAAE,CAAC;QACjF,OAAO,QAAQ,CAAC,cAAc,EAAE,CAAC,GAAG,CAAA;IACtC,CAAC,MAAM,CAAC;QACN,UAAM,uOAA0B,EAAC,iDAAiD,CAAC,CAAA;IACrF,CAAC;AACH,CAAC,CAAA"}},
    {"offset": {"line": 2381, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/request.js","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40web3auth/no-modal/node_modules/%40ethereumjs/util/src/request.ts"],"sourcesContent":["import { concatBytes } from './bytes.ts'\n\nimport type { PrefixedHexString } from './types.ts'\n\nexport type RequestBytes = Uint8Array\n\nexport type CLRequestType = (typeof CLRequestType)[keyof typeof CLRequestType]\n\nexport const CLRequestType = {\n  Deposit: 0,\n  Withdrawal: 1,\n  Consolidation: 2,\n} as const\n\nexport interface RequestJSON {\n  type: PrefixedHexString\n  data: PrefixedHexString\n}\n\nexport class CLRequest<T extends CLRequestType> {\n  // for easy use\n  public readonly bytes: Uint8Array\n\n  get type() {\n    return this.bytes[0] as T\n  }\n\n  get data() {\n    return this.bytes.subarray(1)\n  }\n\n  constructor(requestType: T, requestData: Uint8Array) {\n    this.bytes = concatBytes(new Uint8Array([requestType]), requestData)\n  }\n}\n\nexport function createCLRequest(bytes: Uint8Array): CLRequest<CLRequestType> {\n  switch (bytes[0]) {\n    case CLRequestType.Deposit:\n      return new CLRequest(CLRequestType.Deposit, bytes.subarray(1))\n    case CLRequestType.Withdrawal:\n      return new CLRequest(CLRequestType.Withdrawal, bytes.subarray(1))\n    case CLRequestType.Consolidation:\n      return new CLRequest(CLRequestType.Consolidation, bytes.subarray(1))\n    default:\n      throw Error(`Invalid request type=${bytes[0]}`)\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAAA,OAAO,EAAE,WAAW,EAAE,MAAM,YAAY,CAAA;;AAQjC,MAAM,aAAa,GAAG;IAC3B,OAAO,EAAE,CAAC;IACV,UAAU,EAAE,CAAC;IACb,aAAa,EAAE,CAAC;CACR,CAAA;AAOJ,MAAO,SAAS;IAIpB,IAAI,IAAI,GAAA;QACN,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,CAAM,CAAA;IAC3B,CAAC;IAED,IAAI,IAAI,GAAA;QACN,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAA;IAC/B,CAAC;IAED,YAAY,WAAc,EAAE,WAAuB,CAAA;QACjD,IAAI,CAAC,KAAK,OAAG,wOAAW,EAAC,IAAI,UAAU,CAAC;YAAC,WAAW;SAAC,CAAC,EAAE,WAAW,CAAC,CAAA;IACtE,CAAC;CACF;AAEK,SAAU,eAAe,CAAC,KAAiB;IAC/C,OAAQ,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC;QACjB,KAAK,aAAa,CAAC,OAAO;YACxB,OAAO,IAAI,SAAS,CAAC,aAAa,CAAC,OAAO,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAA;QAChE,KAAK,aAAa,CAAC,UAAU;YAC3B,OAAO,IAAI,SAAS,CAAC,aAAa,CAAC,UAAU,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAA;QACnE,KAAK,aAAa,CAAC,aAAa;YAC9B,OAAO,IAAI,SAAS,CAAC,aAAa,CAAC,aAAa,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAA;QACtE;YACE,MAAM,KAAK,CAAC,CAAA,qBAAA,EAAwB,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAA;IACnD,CAAC;AACH,CAAC"}},
    {"offset": {"line": 2425, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/tasks.js","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40web3auth/no-modal/node_modules/%40ethereumjs/util/src/tasks.ts"],"sourcesContent":["interface Task {\n  priority: number\n  fn: Function\n}\n\nexport class PrioritizedTaskExecutor {\n  /** The maximum size of the pool */\n  private maxPoolSize: number\n  /** The current size of the pool */\n  private currentPoolSize: number\n  /** The task queue */\n  private queue: Task[]\n\n  /**\n   * Executes tasks up to maxPoolSize at a time, other items are put in a priority queue.\n   * @class PrioritizedTaskExecutor\n   * @private\n   * @param maxPoolSize The maximum size of the pool\n   */\n  constructor(maxPoolSize: number) {\n    this.maxPoolSize = maxPoolSize\n    this.currentPoolSize = 0\n    this.queue = []\n  }\n\n  /**\n   * Executes the task or queues it if no spots are available.\n   * When a task is added, check if there are spots left in the pool.\n   * If a spot is available, claim that spot and give back the spot once the asynchronous task has been resolved.\n   * When no spots are available, add the task to the task queue. The task will be executed at some point when another task has been resolved.\n   * @private\n   * @param priority The priority of the task\n   * @param fn The function that accepts the callback, which must be called upon the task completion.\n   */\n  executeOrQueue(priority: number, fn: Function) {\n    if (this.currentPoolSize < this.maxPoolSize) {\n      this.currentPoolSize++\n      fn(() => {\n        this.currentPoolSize--\n        if (this.queue.length > 0) {\n          this.queue.sort((a, b) => b.priority - a.priority)\n          const item = this.queue.shift()\n          this.executeOrQueue(item!.priority, item!.fn)\n        }\n      })\n    } else {\n      this.queue.push({ priority, fn })\n    }\n  }\n\n  /**\n   * Checks if the taskExecutor is finished.\n   * @private\n   * @returns Returns `true` if the taskExecutor is finished, otherwise returns `false`.\n   */\n  finished(): boolean {\n    return this.currentPoolSize === 0\n  }\n}\n"],"names":[],"mappings":";;;;AAKM,MAAO,uBAAuB;IAQlC;;;;;OAKG,CACH,YAAY,WAAmB,CAAA;QAC7B,IAAI,CAAC,WAAW,GAAG,WAAW,CAAA;QAC9B,IAAI,CAAC,eAAe,GAAG,CAAC,CAAA;QACxB,IAAI,CAAC,KAAK,GAAG,EAAE,CAAA;IACjB,CAAC;IAED;;;;;;;;OAQG,CACH,cAAc,CAAC,QAAgB,EAAE,EAAY,EAAA;QAC3C,IAAI,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;YAC5C,IAAI,CAAC,eAAe,EAAE,CAAA;YACtB,EAAE,CAAC,GAAG,EAAE;gBACN,IAAI,CAAC,eAAe,EAAE,CAAA;gBACtB,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;oBAC1B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAG,CAAD,AAAE,CAAC,QAAQ,GAAG,CAAC,CAAC,QAAQ,CAAC,CAAA;oBAClD,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAA;oBAC/B,IAAI,CAAC,cAAc,CAAC,IAAK,CAAC,QAAQ,EAAE,IAAK,CAAC,EAAE,CAAC,CAAA;gBAC/C,CAAC;YACH,CAAC,CAAC,CAAA;QACJ,CAAC,MAAM,CAAC;YACN,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;gBAAE,QAAQ;gBAAE,EAAE;YAAA,CAAE,CAAC,CAAA;QACnC,CAAC;IACH,CAAC;IAED;;;;OAIG,CACH,QAAQ,GAAA;QACN,OAAO,IAAI,CAAC,eAAe,KAAK,CAAC,CAAA;IACnC,CAAC;CACF"}},
    {"offset": {"line": 2478, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@web3auth/no-modal/node_modules/@ethereumjs/util/dist/esm/index.js","sources":["file:///Users/yashparikh/projects/xstocks-ui/node_modules/%40web3auth/no-modal/node_modules/%40ethereumjs/util/src/index.ts"],"sourcesContent":["/**\n * Constants\n */\nexport * from './constants.ts'\n\n/**\n * Errors\n */\nexport * from './errors.ts'\n\n/**\n * Units helpers\n */\nexport * from './units.ts'\n\n/**\n * Account class and helper functions\n */\nexport * from './account.ts'\n\n/**\n * Address type\n */\nexport * from './address.ts'\n\n/**\n * DB type\n */\nexport * from './db.ts'\n\n/**\n * Withdrawal type\n */\nexport * from './withdrawal.ts'\n\n/**\n * ECDSA signature\n */\nexport * from './signature.ts'\n\n/**\n * Utilities for manipulating bytes, Uint8Arrays, etc.\n */\nexport * from './bytes.ts'\n\n/**\n * Helpful TypeScript types\n */\nexport * from './types.ts'\n\n/**\n * Export ethjs-util methods\n */\nexport * from './authorization.ts'\nexport * from './binaryTree.ts'\nexport * from './blobs.ts'\nexport {\n  arrayContainsArray,\n  fromAscii,\n  fromUtf8,\n  getBinarySize,\n  getKeys,\n  isHexString,\n  padToEven,\n  stripHexPrefix,\n  toAscii,\n} from './internal.ts'\nexport * from './kzg.ts'\nexport * from './lock.ts'\nexport * from './mapDB.ts'\nexport * from './provider.ts'\nexport * from './request.ts'\nexport * from './tasks.ts'\n"],"names":[],"mappings":";AAAA;;GAEG,CACH,cAAc,gBAAgB,CAAA;AAE9B;;GAEG,CACH,cAAc,aAAa,CAAA;AAE3B;;GAEG,CACH,cAAc,YAAY,CAAA;AAE1B;;GAEG,CACH,cAAc,cAAc,CAAA;AAE5B;;GAEG,CACH,cAAc,cAAc,CAAA;AAE5B;;GAEG,CACH,cAAc,SAAS,CAAA;AAEvB;;GAEG,CACH,cAAc,iBAAiB,CAAA;AAE/B;;GAEG,CACH,cAAc,gBAAgB,CAAA;AAE9B;;GAEG,CACH,cAAc,YAAY,CAAA;AAE1B;;GAEG,CACH,cAAc,YAAY,CAAA;AAE1B;;GAEG,CACH,cAAc,oBAAoB,CAAA;AAClC,cAAc,iBAAiB,CAAA;AAC/B,cAAc,YAAY,CAAA;AAC1B,OAAO,EACL,kBAAkB,EAClB,SAAS,EACT,QAAQ,EACR,aAAa,EACb,OAAO,EACP,WAAW,EACX,SAAS,EACT,cAAc,EACd,OAAO,GACR,MAAM,eAAe,CAAA;AACtB,cAAc,UAAU,CAAA;AACxB,cAAc,WAAW,CAAA;AACzB,cAAc,YAAY,CAAA;AAC1B,cAAc,eAAe,CAAA;AAC7B,cAAc,cAAc,CAAA;AAC5B,cAAc,YAAY,CAAA"}}]
}