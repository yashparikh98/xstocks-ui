(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,70010,e=>{"use strict";e.s([],46933),e.i(46933);var t=e.i(11577),i=e.i(24154),r=e.i(49604),n=e.i(29871),o=e.i(79383),a=e.i(67888),s=e.i(11810),c=e.i(69146);class d extends r.BaseEvmConnector{constructor(e){super(e),(0,t.default)(this,"connectorNamespace",n.CONNECTOR_NAMESPACES.EIP155),(0,t.default)(this,"currentChainNamespace",o.CHAIN_NAMESPACES.EIP155),(0,t.default)(this,"type",a.CONNECTOR_CATEGORY.EXTERNAL),(0,t.default)(this,"name",void 0),(0,t.default)(this,"isInjected",!0),(0,t.default)(this,"status",a.CONNECTOR_STATUS.NOT_READY),(0,t.default)(this,"injectedProvider",null),this.name=e.name,this.injectedProvider=e.provider,this.icon=e.icon}get provider(){return this.status!==a.CONNECTOR_STATUS.NOT_READY&&this.injectedProvider?this.injectedProvider:null}set provider(e){throw Error("Not implemented")}async init(e){await super.init(e);let t=this.coreOptions.chains.find(t=>t.chainId===e.chainId);super.checkInitializationRequirements({chainConfig:t}),this.status=a.CONNECTOR_STATUS.READY,this.emit(a.CONNECTOR_EVENTS.READY,this.name);try{if(s.log.debug(`initializing ${this.name} injected connector`),e.autoConnect&&(this.rehydrated=!0,!await this.connect({chainId:e.chainId,getIdentityToken:e.getIdentityToken})))throw this.rehydrated=!1,c.WalletLoginError.connectionError("Failed to rehydrate.")}catch(e){this.emit(a.CONNECTOR_EVENTS.REHYDRATION_ERROR,e)}}async connect({chainId:e,getIdentityToken:t}){if(super.checkConnectionRequirements(),!this.injectedProvider)throw c.WalletLoginError.connectionError("Injected provider is not available");let i=this.coreOptions.chains.find(t=>t.chainId===e);if(!i)throw c.WalletLoginError.connectionError("Chain config is not available");this.status=a.CONNECTOR_STATUS.CONNECTING,this.emit(a.CONNECTOR_EVENTS.CONNECTING,{connector:this.name});try{let e;if(await this.injectedProvider.request({method:"eth_requestAccounts"}),this.injectedProvider.chainId!==i.chainId)try{await this.switchChain(i,!0)}catch{await this.addChain(i,!0),await this.switchChain(i,!0)}this.status=a.CONNECTOR_STATUS.CONNECTED;let r=e=>{if(0===e.length){var t;this.disconnect(),null!=(t=this.injectedProvider)&&t.removeListener&&this.injectedProvider.removeListener("accountsChanged",r)}};return this.injectedProvider.on("accountsChanged",r),this.emit(a.CONNECTOR_EVENTS.CONNECTED,{connector:this.name,reconnected:this.rehydrated,provider:this.injectedProvider,identityTokenInfo:e}),t&&(e=await this.getIdentityToken()),this.injectedProvider}catch(e){if(this.status=a.CONNECTOR_STATUS.READY,this.rehydrated||this.emit(a.CONNECTOR_EVENTS.ERRORED,e),this.rehydrated=!1,e instanceof c.Web3AuthError)throw e;throw c.WalletLoginError.connectionError(`Failed to login with ${this.name} injected wallet`)}}async disconnect(e={cleanup:!1}){if(!this.injectedProvider)throw c.WalletLoginError.connectionError("Injected provider is not available");await super.disconnectSession(),void 0!==this.injectedProvider.removeAllListeners&&this.injectedProvider.removeAllListeners();try{await this.injectedProvider.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]})}catch{}e.cleanup?(this.status=a.CONNECTOR_STATUS.NOT_READY,this.injectedProvider=null):this.status=a.CONNECTOR_STATUS.READY,await super.disconnect()}async getUserInfo(){if(!this.canAuthorize)throw c.WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");return{}}async addChain(e,t=!1){if(!this.injectedProvider)throw c.WalletLoginError.connectionError("Injected provider is not available");await this.injectedProvider.request({method:"wallet_addEthereumChain",params:[{chainId:e.chainId,chainName:e.displayName,rpcUrls:[e.rpcTarget],blockExplorerUrls:[e.blockExplorerUrl],nativeCurrency:{name:e.tickerName,symbol:e.ticker,decimals:e.decimals||18},iconUrls:[e.logo]}]})}async switchChain(e,t=!1){if(!this.injectedProvider)throw c.WalletLoginError.connectionError("Injected provider is not available");super.checkSwitchChainRequirements(e,t),await this.injectedProvider.request({method:"wallet_switchEthereumChain",params:[{chainId:e.chainId}]})}async enableMFA(){throw Error("Method Not implemented")}async manageMFA(){throw Error("Method Not implemented")}}let h=e=>({coreOptions:t})=>new d({name:(0,i.normalizeWalletName)(e.info.name),provider:e.provider,icon:e.info.icon,coreOptions:t});function l(){let e=new Set,t=[],i=()=>(function(e){if("undefined"==typeof window)return;let t=t=>e(t.detail);return window.addEventListener("eip6963:announceProvider",t),window.dispatchEvent(new CustomEvent("eip6963:requestProvider")),()=>window.removeEventListener("eip6963:announceProvider",t)})(i=>{t.some(({info:e})=>e.uuid===i.info.uuid)||(t=[...t,i],e.forEach(e=>e(t,{added:[i]})))}),r=i();return{_listeners:()=>e,clear(){e.forEach(e=>e([],{removed:[...t]})),t=[]},destroy(){this.clear(),e.clear(),r?.()},findProvider:({rdns:e})=>t.find(t=>t.info.rdns===e),getProviders:()=>t,reset(){this.clear(),r?.(),r=i()},subscribe:(i,{emitImmediately:r}={})=>(e.add(i),r&&i(t,{added:t}),()=>e.delete(i))}}e.s(["createMipd",()=>l,"injectedEvmConnector",()=>h],70010)}]);