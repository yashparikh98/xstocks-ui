{"version":3,"sources":["../../../../node_modules/%40toruslabs/loglevel-sentry/dist/lib.esm/loglevel-sentry.js","../../../../node_modules/%40sentry/core/src/utils/stacktrace.ts","../../../../node_modules/%40web3auth/no-modal/dist/lib.esm/base/loglevel.js","../../../../node_modules/%40sentry/core/src/utils/is.ts","../../../../node_modules/%40sentry/core/src/utils/version.ts","../../../../node_modules/%40sentry/core/src/utils/browser.ts","../../../../node_modules/%40sentry/core/src/utils/worldwide.ts","../../../../node_modules/%40sentry/core/src/debug-build.ts","../../../../node_modules/%40sentry/core/src/utils/string.ts","../../../../node_modules/%40sentry/core/src/utils/debug-logger.ts","../../../../node_modules/%40sentry/core/src/carrier.ts","../../../../node_modules/%40sentry/core/src/utils/object.ts","../../../../node_modules/%40sentry/core/src/utils/normalize.ts"],"sourcesContent":["import _objectSpread from '@babel/runtime/helpers/objectSpread2';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { normalize } from '@sentry/core';\n\nclass LoglevelSentry {\n  constructor(sentry) {\n    _defineProperty(this, \"sentry\", void 0);\n    _defineProperty(this, \"category\", void 0);\n    this.sentry = sentry;\n    this.category = \"loglevel-sentry\";\n  }\n  static async translateError(args) {\n    const index = args.findIndex(arg => arg instanceof Error);\n    const msgIndex = args.findIndex(arg => typeof arg === \"string\");\n    const apiErrorIdx = args.findIndex(arg => arg && typeof arg === \"object\" && \"status\" in arg && \"type\" in arg);\n    const axiosErrorIdx = args.findIndex(arg => arg && typeof arg === \"object\" && \"isAxiosError\" in arg && arg.isAxiosError === true);\n    let err;\n    if (apiErrorIdx !== -1) {\n      var _apiError$headers;\n      const apiError = args[apiErrorIdx];\n      const contentType = (_apiError$headers = apiError.headers) === null || _apiError$headers === void 0 ? void 0 : _apiError$headers.get(\"content-type\");\n      if (contentType.includes(\"application/json\")) {\n        const errJson = await apiError.json();\n        err = new Error((errJson === null || errJson === void 0 ? void 0 : errJson.error) || (errJson === null || errJson === void 0 ? void 0 : errJson.message) || JSON.stringify(errJson));\n      } else if (contentType.includes(\"text/plain\")) {\n        err = new Error(await apiError.text());\n      } else {\n        err = new Error(`${apiError.status} ${apiError.type.toString()} ${apiError.statusText}`);\n      }\n    } else if (axiosErrorIdx !== -1) {\n      const axiosError = args[axiosErrorIdx];\n      const errorResponse = axiosError.response;\n      if (errorResponse) {\n        var _errorResponse$header;\n        const contentType = (_errorResponse$header = errorResponse.headers) === null || _errorResponse$header === void 0 ? void 0 : _errorResponse$header[\"content-type\"];\n        if (contentType.includes(\"application/json\")) {\n          const errJson = errorResponse.data;\n          const errorMsg = \"error\" in errJson ? errJson.error : \"message\" in errJson ? errJson.message : JSON.stringify(errJson);\n          err = new Error(errorMsg);\n        } else if (contentType.includes(\"text/plain\")) {\n          err = new Error(errorResponse.data);\n        } else {\n          err = new Error(`${errorResponse.status} ${errorResponse.data.toString()}`);\n        }\n      } else {\n        err = new Error(\"Network error\");\n      }\n    } else if (index !== -1) {\n      err = args.splice(index, 1)[0];\n    } else if (msgIndex !== -1) {\n      err = new Error(args.splice(msgIndex, 1)[0]);\n    } else {\n      err = new Error(\"Unknown error\");\n    }\n    return [err, args];\n  }\n  static translateArgs(args) {\n    const msgIndex = args.findIndex(arg => typeof arg === \"string\");\n    const firstMsg = msgIndex !== -1 ? args.splice(msgIndex, 1)[0] : undefined;\n    return firstMsg ? {\n      message: firstMsg,\n      // args is already spliced\n      data: {\n        arguments: args\n      }\n    } : {\n      data: {\n        arguments: args\n      }\n    };\n  }\n  static translateLevel(level) {\n    switch (level) {\n      case \"info\":\n        return \"info\";\n      case \"warn\":\n        return \"warning\";\n      default:\n        return \"debug\";\n    }\n  }\n  install(logger) {\n    const defaultMethodFactory = logger.methodFactory;\n    logger.methodFactory = (method, level, name) => {\n      if (name) this.category = name.toString();\n      const defaultMethod = defaultMethodFactory(method, level, name);\n      const isFrontend = typeof window !== \"undefined\";\n      const overrideDefaultMethod = (...args) => {\n        var _this$sentry;\n        const currentSpan = (_this$sentry = this.sentry) === null || _this$sentry === void 0 ? void 0 : _this$sentry.getActiveSpan();\n        const {\n          traceId,\n          spanId\n        } = (currentSpan === null || currentSpan === void 0 ? void 0 : currentSpan.spanContext()) || {};\n        const isError = method === \"error\" && args.length >= 1 && args[0] instanceof Error;\n        if (isFrontend) {\n          if (isError) {\n            const error = args[0];\n            const errMsg = traceId || spanId ? `${error.message}: traceId: ${traceId} - spanId: ${spanId}` : error.message;\n            const newError = new Error(errMsg, {\n              cause: error\n            });\n            const newArgs = [newError, ...args.slice(1)];\n            if (defaultMethod) defaultMethod(...newArgs);\n            return;\n          }\n          if (defaultMethod) defaultMethod(...args);\n        } else {\n          let logData = {\n            timestamp: new Date(),\n            level: method.toUpperCase(),\n            logger: name\n          };\n          if (traceId || spanId) logData = _objectSpread(_objectSpread({}, logData), {}, {\n            traceId,\n            spanId\n          });\n          if (isError) {\n            var _error$message;\n            const error = args[0];\n            logData = _objectSpread(_objectSpread({}, logData), {}, {\n              message: (_error$message = error.message) !== null && _error$message !== void 0 ? _error$message : \"\",\n              stack: error.stack,\n              extra: args.length > 1 ? args.slice(1) : undefined\n            });\n          } else {\n            var _args$;\n            logData = _objectSpread(_objectSpread({}, logData), {}, {\n              message: (_args$ = args[0]) !== null && _args$ !== void 0 ? _args$ : \"\",\n              extra: args.length > 1 ? args.slice(1) : undefined\n            });\n          }\n          if (defaultMethod) defaultMethod(JSON.stringify(normalize(logData)));\n        }\n      };\n      switch (method) {\n        case \"error\":\n          return async (...args) => {\n            // preserve original stack trace as it's lost when using async/await\n            const {\n              stack\n            } = args.find(arg => arg instanceof Error) || new Error();\n            const [err, otherArgs] = await LoglevelSentry.translateError(args);\n            err.stack = stack;\n            this.error(err, ...otherArgs);\n            overrideDefaultMethod(err, ...otherArgs);\n          };\n        default:\n          return (...args) => {\n            this.log(LoglevelSentry.translateLevel(method), ...args);\n            // keep behavior consistent to console in browser\n            overrideDefaultMethod(...args);\n          };\n      }\n    };\n    logger.setLevel(logger.getLevel());\n  }\n  setEnabled(enabled) {\n    if (this.sentry) {\n      const options = this.sentry.getClient().getOptions();\n      if (options) {\n        options.enabled = enabled;\n      }\n    }\n  }\n  isEnabled() {\n    if (this.sentry) {\n      var _options$enabled;\n      const options = this.sentry.getClient().getOptions();\n      return (_options$enabled = options === null || options === void 0 ? void 0 : options.enabled) !== null && _options$enabled !== void 0 ? _options$enabled : false;\n    }\n    return false;\n  }\n  log(level, ...args) {\n    if (this.sentry) {\n      this.sentry.addBreadcrumb(_objectSpread(_objectSpread({}, LoglevelSentry.translateArgs(args)), {}, {\n        category: this.category,\n        level,\n        timestamp: Date.now()\n      }));\n    }\n  }\n  trace(...args) {\n    this.log(\"debug\", ...args);\n  }\n  error(err, ...args) {\n    if (this.sentry) {\n      const eventHint = {\n        data: {\n          logger: \"loglevel-sentry\",\n          \"logger.name\": this.category,\n          arguments: args\n        }\n      };\n      this.sentry.captureException(err, eventHint);\n    }\n  }\n}\n\nexport { LoglevelSentry };\n","import type { Event } from '../types-hoist/event';\nimport type { StackFrame } from '../types-hoist/stackframe';\nimport type { StackLineParser, StackParser } from '../types-hoist/stacktrace';\n\nconst STACKTRACE_FRAME_LIMIT = 50;\nexport const UNKNOWN_FUNCTION = '?';\n// Used to sanitize webpack (error: *) wrapped stack errors\nconst WEBPACK_ERROR_REGEXP = /\\(error: (.*)\\)/;\nconst STRIP_FRAME_REGEXP = /captureMessage|captureException/;\n\n/**\n * Creates a stack parser with the supplied line parsers\n *\n * StackFrames are returned in the correct order for Sentry Exception\n * frames and with Sentry SDK internal frames removed from the top and bottom\n *\n */\nexport function createStackParser(...parsers: StackLineParser[]): StackParser {\n  const sortedParsers = parsers.sort((a, b) => a[0] - b[0]).map(p => p[1]);\n\n  return (stack: string, skipFirstLines: number = 0, framesToPop: number = 0): StackFrame[] => {\n    const frames: StackFrame[] = [];\n    const lines = stack.split('\\n');\n\n    for (let i = skipFirstLines; i < lines.length; i++) {\n      const line = lines[i] as string;\n      // Ignore lines over 1kb as they are unlikely to be stack frames.\n      // Many of the regular expressions use backtracking which results in run time that increases exponentially with\n      // input size. Huge strings can result in hangs/Denial of Service:\n      // https://github.com/getsentry/sentry-javascript/issues/2286\n      if (line.length > 1024) {\n        continue;\n      }\n\n      // https://github.com/getsentry/sentry-javascript/issues/5459\n      // Remove webpack (error: *) wrappers\n      const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, '$1') : line;\n\n      // https://github.com/getsentry/sentry-javascript/issues/7813\n      // Skip Error: lines\n      if (cleanedLine.match(/\\S*Error: /)) {\n        continue;\n      }\n\n      for (const parser of sortedParsers) {\n        const frame = parser(cleanedLine);\n\n        if (frame) {\n          frames.push(frame);\n          break;\n        }\n      }\n\n      if (frames.length >= STACKTRACE_FRAME_LIMIT + framesToPop) {\n        break;\n      }\n    }\n\n    return stripSentryFramesAndReverse(frames.slice(framesToPop));\n  };\n}\n\n/**\n * Gets a stack parser implementation from Options.stackParser\n * @see Options\n *\n * If options contains an array of line parsers, it is converted into a parser\n */\nexport function stackParserFromStackParserOptions(stackParser: StackParser | StackLineParser[]): StackParser {\n  if (Array.isArray(stackParser)) {\n    return createStackParser(...stackParser);\n  }\n  return stackParser;\n}\n\n/**\n * Removes Sentry frames from the top and bottom of the stack if present and enforces a limit of max number of frames.\n * Assumes stack input is ordered from top to bottom and returns the reverse representation so call site of the\n * function that caused the crash is the last frame in the array.\n * @hidden\n */\nexport function stripSentryFramesAndReverse(stack: ReadonlyArray<StackFrame>): StackFrame[] {\n  if (!stack.length) {\n    return [];\n  }\n\n  const localStack = Array.from(stack);\n\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (/sentryWrapped/.test(getLastStackFrame(localStack).function || '')) {\n    localStack.pop();\n  }\n\n  // Reversing in the middle of the procedure allows us to just pop the values off the stack\n  localStack.reverse();\n\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || '')) {\n    localStack.pop();\n\n    // When using synthetic events, we will have a 2 levels deep stack, as `new Error('Sentry syntheticException')`\n    // is produced within the scope itself, making it:\n    //\n    //   Sentry.captureException()\n    //   scope.captureException()\n    //\n    // instead of just the top `Sentry` call itself.\n    // This forces us to possibly strip an additional frame in the exact same was as above.\n    if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || '')) {\n      localStack.pop();\n    }\n  }\n\n  return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map(frame => ({\n    ...frame,\n    filename: frame.filename || getLastStackFrame(localStack).filename,\n    function: frame.function || UNKNOWN_FUNCTION,\n  }));\n}\n\nfunction getLastStackFrame(arr: StackFrame[]): StackFrame {\n  return arr[arr.length - 1] || {};\n}\n\nconst defaultFunctionName = '<anonymous>';\n\n/**\n * Safely extract function name from itself\n */\nexport function getFunctionName(fn: unknown): string {\n  try {\n    if (!fn || typeof fn !== 'function') {\n      return defaultFunctionName;\n    }\n    return fn.name || defaultFunctionName;\n  } catch {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    return defaultFunctionName;\n  }\n}\n\n/**\n * Get's stack frames from an event without needing to check for undefined properties.\n */\nexport function getFramesFromEvent(event: Event): StackFrame[] | undefined {\n  const exception = event.exception;\n\n  if (exception) {\n    const frames: StackFrame[] = [];\n    try {\n      // @ts-expect-error Object could be undefined\n      exception.values.forEach(value => {\n        // @ts-expect-error Value could be undefined\n        if (value.stacktrace.frames) {\n          // @ts-expect-error Value could be undefined\n          frames.push(...value.stacktrace.frames);\n        }\n      });\n      return frames;\n    } catch {\n      return undefined;\n    }\n  }\n  return undefined;\n}\n","import { LoglevelSentry } from '@toruslabs/loglevel-sentry';\nimport loglevel from 'loglevel';\n\nconst log = loglevel.getLogger(\"web3auth-logger\");\nconst loglevelPlugin = new LoglevelSentry();\nloglevelPlugin.install(log);\n\nexport { log };\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport type { Primitive } from '../types-hoist/misc';\nimport type { ParameterizedString } from '../types-hoist/parameterize';\nimport type { PolymorphicEvent } from '../types-hoist/polymorphics';\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst objectToString = Object.prototype.toString;\n\n/**\n * Checks whether given value's type is one of a few Error or Error-like\n * {@link isError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isError(wat: unknown): wat is Error {\n  switch (objectToString.call(wat)) {\n    case '[object Error]':\n    case '[object Exception]':\n    case '[object DOMException]':\n    case '[object WebAssembly.Exception]':\n      return true;\n    default:\n      return isInstanceOf(wat, Error);\n  }\n}\n/**\n * Checks whether given value is an instance of the given built-in class.\n *\n * @param wat The value to be checked\n * @param className\n * @returns A boolean representing the result.\n */\nfunction isBuiltin(wat: unknown, className: string): boolean {\n  return objectToString.call(wat) === `[object ${className}]`;\n}\n\n/**\n * Checks whether given value's type is ErrorEvent\n * {@link isErrorEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isErrorEvent(wat: unknown): boolean {\n  return isBuiltin(wat, 'ErrorEvent');\n}\n\n/**\n * Checks whether given value's type is DOMError\n * {@link isDOMError}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isDOMError(wat: unknown): boolean {\n  return isBuiltin(wat, 'DOMError');\n}\n\n/**\n * Checks whether given value's type is DOMException\n * {@link isDOMException}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isDOMException(wat: unknown): boolean {\n  return isBuiltin(wat, 'DOMException');\n}\n\n/**\n * Checks whether given value's type is a string\n * {@link isString}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isString(wat: unknown): wat is string {\n  return isBuiltin(wat, 'String');\n}\n\n/**\n * Checks whether given string is parameterized\n * {@link isParameterizedString}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isParameterizedString(wat: unknown): wat is ParameterizedString {\n  return (\n    typeof wat === 'object' &&\n    wat !== null &&\n    '__sentry_template_string__' in wat &&\n    '__sentry_template_values__' in wat\n  );\n}\n\n/**\n * Checks whether given value is a primitive (undefined, null, number, boolean, string, bigint, symbol)\n * {@link isPrimitive}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isPrimitive(wat: unknown): wat is Primitive {\n  return wat === null || isParameterizedString(wat) || (typeof wat !== 'object' && typeof wat !== 'function');\n}\n\n/**\n * Checks whether given value's type is an object literal, or a class instance.\n * {@link isPlainObject}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isPlainObject(wat: unknown): wat is Record<string, unknown> {\n  return isBuiltin(wat, 'Object');\n}\n\n/**\n * Checks whether given value's type is an Event instance\n * {@link isEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isEvent(wat: unknown): wat is PolymorphicEvent {\n  return typeof Event !== 'undefined' && isInstanceOf(wat, Event);\n}\n\n/**\n * Checks whether given value's type is an Element instance\n * {@link isElement}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isElement(wat: unknown): boolean {\n  return typeof Element !== 'undefined' && isInstanceOf(wat, Element);\n}\n\n/**\n * Checks whether given value's type is an regexp\n * {@link isRegExp}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isRegExp(wat: unknown): wat is RegExp {\n  return isBuiltin(wat, 'RegExp');\n}\n\n/**\n * Checks whether given value has a then function.\n * @param wat A value to be checked.\n */\nexport function isThenable(wat: any): wat is PromiseLike<any> {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  return Boolean(wat?.then && typeof wat.then === 'function');\n}\n\n/**\n * Checks whether given value's type is a SyntheticEvent\n * {@link isSyntheticEvent}.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isSyntheticEvent(wat: unknown): boolean {\n  return isPlainObject(wat) && 'nativeEvent' in wat && 'preventDefault' in wat && 'stopPropagation' in wat;\n}\n\n/**\n * Checks whether given value's type is an instance of provided constructor.\n * {@link isInstanceOf}.\n *\n * @param wat A value to be checked.\n * @param base A constructor to be used in a check.\n * @returns A boolean representing the result.\n */\nexport function isInstanceOf(wat: any, base: any): boolean {\n  try {\n    return wat instanceof base;\n  } catch {\n    return false;\n  }\n}\n\ninterface VueViewModel {\n  // Vue3\n  __isVue?: boolean;\n  // Vue2\n  _isVue?: boolean;\n}\n/**\n * Checks whether given value's type is a Vue ViewModel.\n *\n * @param wat A value to be checked.\n * @returns A boolean representing the result.\n */\nexport function isVueViewModel(wat: unknown): boolean {\n  // Not using Object.prototype.toString because in Vue 3 it would read the instance's Symbol(Symbol.toStringTag) property.\n  return !!(typeof wat === 'object' && wat !== null && ((wat as VueViewModel).__isVue || (wat as VueViewModel)._isVue));\n}\n\n/**\n * Checks whether the given parameter is a Standard Web API Request instance.\n *\n * Returns false if Request is not available in the current runtime.\n */\nexport function isRequest(request: unknown): request is Request {\n  return typeof Request !== 'undefined' && isInstanceOf(request, Request);\n}\n","// This is a magic string replaced by rollup\ndeclare const __SENTRY_SDK_VERSION__: string;\n\nexport const SDK_VERSION = typeof __SENTRY_SDK_VERSION__ === 'string' ? __SENTRY_SDK_VERSION__ : '0.0.0-unknown.0';\n","import { isString } from './is';\nimport { GLOBAL_OBJ } from './worldwide';\n\nconst WINDOW = GLOBAL_OBJ as unknown as Window;\n\nconst DEFAULT_MAX_STRING_LENGTH = 80;\n\ntype SimpleNode = {\n  parentNode: SimpleNode;\n} | null;\n\n/**\n * Given a child DOM element, returns a query-selector statement describing that\n * and its ancestors\n * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]\n * @returns generated DOM path\n */\nexport function htmlTreeAsString(\n  elem: unknown,\n  options: string[] | { keyAttrs?: string[]; maxStringLength?: number } = {},\n): string {\n  if (!elem) {\n    return '<unknown>';\n  }\n\n  // try/catch both:\n  // - accessing event.target (see getsentry/raven-js#838, #768)\n  // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly\n  // - can throw an exception in some circumstances.\n  try {\n    let currentElem = elem as SimpleNode;\n    const MAX_TRAVERSE_HEIGHT = 5;\n    const out = [];\n    let height = 0;\n    let len = 0;\n    const separator = ' > ';\n    const sepLength = separator.length;\n    let nextStr;\n    const keyAttrs = Array.isArray(options) ? options : options.keyAttrs;\n    const maxStringLength = (!Array.isArray(options) && options.maxStringLength) || DEFAULT_MAX_STRING_LENGTH;\n\n    while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {\n      nextStr = _htmlElementAsString(currentElem, keyAttrs);\n      // bail out if\n      // - nextStr is the 'html' element\n      // - the length of the string that would be created exceeds maxStringLength\n      //   (ignore this limit if we are on the first iteration)\n      if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= maxStringLength)) {\n        break;\n      }\n\n      out.push(nextStr);\n\n      len += nextStr.length;\n      currentElem = currentElem.parentNode;\n    }\n\n    return out.reverse().join(separator);\n  } catch {\n    return '<unknown>';\n  }\n}\n\n/**\n * Returns a simple, query-selector representation of a DOM element\n * e.g. [HTMLElement] => input#foo.btn[name=baz]\n * @returns generated DOM path\n */\nfunction _htmlElementAsString(el: unknown, keyAttrs?: string[]): string {\n  const elem = el as {\n    tagName?: string;\n    id?: string;\n    className?: string;\n    getAttribute(key: string): string;\n  };\n\n  const out = [];\n\n  if (!elem?.tagName) {\n    return '';\n  }\n\n  // @ts-expect-error WINDOW has HTMLElement\n  if (WINDOW.HTMLElement) {\n    // If using the component name annotation plugin, this value may be available on the DOM node\n    if (elem instanceof HTMLElement && elem.dataset) {\n      if (elem.dataset['sentryComponent']) {\n        return elem.dataset['sentryComponent'];\n      }\n      if (elem.dataset['sentryElement']) {\n        return elem.dataset['sentryElement'];\n      }\n    }\n  }\n\n  out.push(elem.tagName.toLowerCase());\n\n  // Pairs of attribute keys defined in `serializeAttribute` and their values on element.\n  const keyAttrPairs = keyAttrs?.length\n    ? keyAttrs.filter(keyAttr => elem.getAttribute(keyAttr)).map(keyAttr => [keyAttr, elem.getAttribute(keyAttr)])\n    : null;\n\n  if (keyAttrPairs?.length) {\n    keyAttrPairs.forEach(keyAttrPair => {\n      out.push(`[${keyAttrPair[0]}=\"${keyAttrPair[1]}\"]`);\n    });\n  } else {\n    if (elem.id) {\n      out.push(`#${elem.id}`);\n    }\n\n    const className = elem.className;\n    if (className && isString(className)) {\n      const classes = className.split(/\\s+/);\n      for (const c of classes) {\n        out.push(`.${c}`);\n      }\n    }\n  }\n  const allowedAttrs = ['aria-label', 'type', 'name', 'title', 'alt'];\n  for (const k of allowedAttrs) {\n    const attr = elem.getAttribute(k);\n    if (attr) {\n      out.push(`[${k}=\"${attr}\"]`);\n    }\n  }\n\n  return out.join('');\n}\n\n/**\n * A safe form of location.href\n */\nexport function getLocationHref(): string {\n  try {\n    return WINDOW.document.location.href;\n  } catch {\n    return '';\n  }\n}\n\n/**\n * Given a DOM element, traverses up the tree until it finds the first ancestor node\n * that has the `data-sentry-component` or `data-sentry-element` attribute with `data-sentry-component` taking\n * precedence. This attribute is added at build-time by projects that have the component name annotation plugin installed.\n *\n * @returns a string representation of the component for the provided DOM element, or `null` if not found\n */\nexport function getComponentName(elem: unknown): string | null {\n  // @ts-expect-error WINDOW has HTMLElement\n  if (!WINDOW.HTMLElement) {\n    return null;\n  }\n\n  let currentElem = elem as SimpleNode;\n  const MAX_TRAVERSE_HEIGHT = 5;\n  for (let i = 0; i < MAX_TRAVERSE_HEIGHT; i++) {\n    if (!currentElem) {\n      return null;\n    }\n\n    if (currentElem instanceof HTMLElement) {\n      if (currentElem.dataset['sentryComponent']) {\n        return currentElem.dataset['sentryComponent'];\n      }\n      if (currentElem.dataset['sentryElement']) {\n        return currentElem.dataset['sentryElement'];\n      }\n    }\n\n    currentElem = currentElem.parentNode;\n  }\n\n  return null;\n}\n","/**\n * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,\n * you must either a) use `console.log` rather than the `debug` singleton, or b) put your function elsewhere.\n *\n * Note: This file was originally called `global.ts`, but was changed to unblock users which might be doing\n * string replaces with bundlers like Vite for `global` (would break imports that rely on importing from utils/src/global).\n *\n * Why worldwide?\n *\n * Why not?\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport type { Carrier } from '../carrier';\nimport type { SdkSource } from './env';\n\n/** Internal global with common properties and Sentry extensions  */\nexport type InternalGlobal = {\n  navigator?: { userAgent?: string; maxTouchPoints?: number };\n  console: Console;\n  PerformanceObserver?: any;\n  Sentry?: any;\n  onerror?: {\n    (event: object | string, source?: string, lineno?: number, colno?: number, error?: Error): any;\n    __SENTRY_INSTRUMENTED__?: true;\n  };\n  onunhandledrejection?: {\n    (event: unknown): boolean;\n    __SENTRY_INSTRUMENTED__?: true;\n  };\n  SENTRY_ENVIRONMENT?: string;\n  SENTRY_DSN?: string;\n  SENTRY_RELEASE?: {\n    id?: string;\n  };\n  SENTRY_SDK_SOURCE?: SdkSource;\n  /**\n   * Debug IDs are indirectly injected by Sentry CLI or bundler plugins to directly reference a particular source map\n   * for resolving of a source file. The injected code will place an entry into the record for each loaded bundle/JS\n   * file.\n   */\n  _sentryDebugIds?: Record<string, string>;\n  /**\n   * Raw module metadata that is injected by bundler plugins.\n   *\n   * Keys are `error.stack` strings, values are the metadata.\n   */\n  _sentryModuleMetadata?: Record<string, any>;\n  _sentryEsmLoaderHookRegistered?: boolean;\n} & Carrier;\n\n/** Get's the global object for the current JavaScript runtime */\nexport const GLOBAL_OBJ = globalThis as unknown as InternalGlobal;\n","declare const __DEBUG_BUILD__: boolean;\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nexport const DEBUG_BUILD = __DEBUG_BUILD__;\n","import { isRegExp, isString, isVueViewModel } from './is';\n\nexport { escapeStringForRegex } from '../vendor/escapeStringForRegex';\n\n/**\n * Truncates given string to the maximum characters count\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string (0 = unlimited)\n * @returns string Encoded\n */\nexport function truncate(str: string, max: number = 0): string {\n  if (typeof str !== 'string' || max === 0) {\n    return str;\n  }\n  return str.length <= max ? str : `${str.slice(0, max)}...`;\n}\n\n/**\n * This is basically just `trim_line` from\n * https://github.com/getsentry/sentry/blob/master/src/sentry/lang/javascript/processor.py#L67\n *\n * @param str An object that contains serializable values\n * @param max Maximum number of characters in truncated string\n * @returns string Encoded\n */\nexport function snipLine(line: string, colno: number): string {\n  let newLine = line;\n  const lineLength = newLine.length;\n  if (lineLength <= 150) {\n    return newLine;\n  }\n  if (colno > lineLength) {\n    // eslint-disable-next-line no-param-reassign\n    colno = lineLength;\n  }\n\n  let start = Math.max(colno - 60, 0);\n  if (start < 5) {\n    start = 0;\n  }\n\n  let end = Math.min(start + 140, lineLength);\n  if (end > lineLength - 5) {\n    end = lineLength;\n  }\n  if (end === lineLength) {\n    start = Math.max(end - 140, 0);\n  }\n\n  newLine = newLine.slice(start, end);\n  if (start > 0) {\n    newLine = `'{snip} ${newLine}`;\n  }\n  if (end < lineLength) {\n    newLine += ' {snip}';\n  }\n\n  return newLine;\n}\n\n/**\n * Join values in array\n * @param input array of values to be joined together\n * @param delimiter string to be placed in-between values\n * @returns Joined values\n */\nexport function safeJoin(input: unknown[], delimiter?: string): string {\n  if (!Array.isArray(input)) {\n    return '';\n  }\n\n  const output = [];\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of\n  for (let i = 0; i < input.length; i++) {\n    const value = input[i];\n    try {\n      // This is a hack to fix a Vue3-specific bug that causes an infinite loop of\n      // console warnings. This happens when a Vue template is rendered with\n      // an undeclared variable, which we try to stringify, ultimately causing\n      // Vue to issue another warning which repeats indefinitely.\n      // see: https://github.com/getsentry/sentry-javascript/pull/8981\n      if (isVueViewModel(value)) {\n        output.push('[VueViewModel]');\n      } else {\n        output.push(String(value));\n      }\n    } catch {\n      output.push('[value cannot be serialized]');\n    }\n  }\n\n  return output.join(delimiter);\n}\n\n/**\n * Checks if the given value matches a regex or string\n *\n * @param value The string to test\n * @param pattern Either a regex or a string against which `value` will be matched\n * @param requireExactStringMatch If true, `value` must match `pattern` exactly. If false, `value` will match\n * `pattern` if it contains `pattern`. Only applies to string-type patterns.\n */\nexport function isMatchingPattern(\n  value: string,\n  pattern: RegExp | string,\n  requireExactStringMatch: boolean = false,\n): boolean {\n  if (!isString(value)) {\n    return false;\n  }\n\n  if (isRegExp(pattern)) {\n    return pattern.test(value);\n  }\n  if (isString(pattern)) {\n    return requireExactStringMatch ? value === pattern : value.includes(pattern);\n  }\n\n  return false;\n}\n\n/**\n * Test the given string against an array of strings and regexes. By default, string matching is done on a\n * substring-inclusion basis rather than a strict equality basis\n *\n * @param testString The string to test\n * @param patterns The patterns against which to test the string\n * @param requireExactStringMatch If true, `testString` must match one of the given string patterns exactly in order to\n * count. If false, `testString` will match a string pattern if it contains that pattern.\n * @returns\n */\nexport function stringMatchesSomePattern(\n  testString: string,\n  patterns: Array<string | RegExp> = [],\n  requireExactStringMatch: boolean = false,\n): boolean {\n  return patterns.some(pattern => isMatchingPattern(testString, pattern, requireExactStringMatch));\n}\n","import { getGlobalSingleton } from '../carrier';\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { ConsoleLevel } from '../types-hoist/instrument';\nimport { GLOBAL_OBJ } from './worldwide';\n\n/**\n * A Sentry Logger instance.\n *\n * @deprecated Use {@link debug} instead with the {@link SentryDebugLogger} type.\n */\nexport interface Logger {\n  disable(): void;\n  enable(): void;\n  isEnabled(): boolean;\n  log(...args: Parameters<typeof console.log>): void;\n  info(...args: Parameters<typeof console.info>): void;\n  warn(...args: Parameters<typeof console.warn>): void;\n  error(...args: Parameters<typeof console.error>): void;\n  debug(...args: Parameters<typeof console.debug>): void;\n  assert(...args: Parameters<typeof console.assert>): void;\n  trace(...args: Parameters<typeof console.trace>): void;\n}\n\nexport interface SentryDebugLogger {\n  disable(): void;\n  enable(): void;\n  isEnabled(): boolean;\n  log(...args: Parameters<typeof console.log>): void;\n  warn(...args: Parameters<typeof console.warn>): void;\n  error(...args: Parameters<typeof console.error>): void;\n}\n\nexport const CONSOLE_LEVELS: readonly ConsoleLevel[] = [\n  'debug',\n  'info',\n  'warn',\n  'error',\n  'log',\n  'assert',\n  'trace',\n] as const;\n\n/** Prefix for logging strings */\nconst PREFIX = 'Sentry Logger ';\n\n/** This may be mutated by the console instrumentation. */\nexport const originalConsoleMethods: Partial<{\n  log(...args: Parameters<typeof console.log>): void;\n  info(...args: Parameters<typeof console.info>): void;\n  warn(...args: Parameters<typeof console.warn>): void;\n  error(...args: Parameters<typeof console.error>): void;\n  debug(...args: Parameters<typeof console.debug>): void;\n  assert(...args: Parameters<typeof console.assert>): void;\n  trace(...args: Parameters<typeof console.trace>): void;\n}> = {};\n\n/**\n * Temporarily disable sentry console instrumentations.\n *\n * @param callback The function to run against the original `console` messages\n * @returns The results of the callback\n */\nexport function consoleSandbox<T>(callback: () => T): T {\n  if (!('console' in GLOBAL_OBJ)) {\n    return callback();\n  }\n\n  const console = GLOBAL_OBJ.console as Console;\n  const wrappedFuncs: Partial<Record<ConsoleLevel, (...args: unknown[]) => void>> = {};\n\n  const wrappedLevels = Object.keys(originalConsoleMethods) as ConsoleLevel[];\n\n  // Restore all wrapped console methods\n  wrappedLevels.forEach(level => {\n    const originalConsoleMethod = originalConsoleMethods[level];\n    wrappedFuncs[level] = console[level] as (...args: unknown[]) => void;\n    console[level] = originalConsoleMethod as (...args: unknown[]) => void;\n  });\n\n  try {\n    return callback();\n  } finally {\n    // Revert restoration to wrapped state\n    wrappedLevels.forEach(level => {\n      console[level] = wrappedFuncs[level] as (...args: unknown[]) => void;\n    });\n  }\n}\n\nfunction enable(): void {\n  _getLoggerSettings().enabled = true;\n}\n\nfunction disable(): void {\n  _getLoggerSettings().enabled = false;\n}\n\nfunction isEnabled(): boolean {\n  return _getLoggerSettings().enabled;\n}\n\nfunction log(...args: Parameters<typeof console.log>): void {\n  _maybeLog('log', ...args);\n}\n\nfunction info(...args: Parameters<typeof console.info>): void {\n  _maybeLog('info', ...args);\n}\n\nfunction warn(...args: Parameters<typeof console.warn>): void {\n  _maybeLog('warn', ...args);\n}\n\nfunction error(...args: Parameters<typeof console.error>): void {\n  _maybeLog('error', ...args);\n}\n\nfunction _debug(...args: Parameters<typeof console.debug>): void {\n  _maybeLog('debug', ...args);\n}\n\nfunction assert(...args: Parameters<typeof console.assert>): void {\n  _maybeLog('assert', ...args);\n}\n\nfunction trace(...args: Parameters<typeof console.trace>): void {\n  _maybeLog('trace', ...args);\n}\n\nfunction _maybeLog(level: ConsoleLevel, ...args: Parameters<(typeof console)[typeof level]>): void {\n  if (!DEBUG_BUILD) {\n    return;\n  }\n\n  if (isEnabled()) {\n    consoleSandbox(() => {\n      GLOBAL_OBJ.console[level](`${PREFIX}[${level}]:`, ...args);\n    });\n  }\n}\n\nfunction _getLoggerSettings(): { enabled: boolean } {\n  if (!DEBUG_BUILD) {\n    return { enabled: false };\n  }\n\n  return getGlobalSingleton('loggerSettings', () => ({ enabled: false }));\n}\n\n/**\n * This is a logger singleton which either logs things or no-ops if logging is not enabled.\n * The logger is a singleton on the carrier, to ensure that a consistent logger is used throughout the SDK.\n *\n * @deprecated Use {@link debug} instead.\n */\nexport const logger = {\n  /** Enable logging. */\n  enable,\n  /** Disable logging. */\n  disable,\n  /** Check if logging is enabled. */\n  isEnabled,\n  /** Log a message. */\n  log,\n  /** Log level info */\n  info,\n  /** Log a warning. */\n  warn,\n  /** Log an error. */\n  error,\n  /** Log a debug message. */\n  debug: _debug,\n  /** Log an assertion. */\n  assert,\n  /** Log a trace. */\n  trace,\n  // eslint-disable-next-line deprecation/deprecation\n} satisfies Logger;\n\n/**\n * This is a logger singleton which either logs things or no-ops if logging is not enabled.\n */\nexport const debug = {\n  /** Enable logging. */\n  enable,\n  /** Disable logging. */\n  disable,\n  /** Check if logging is enabled. */\n  isEnabled,\n  /** Log a message. */\n  log,\n  /** Log a warning. */\n  warn,\n  /** Log an error. */\n  error,\n} satisfies SentryDebugLogger;\n","import type { AsyncContextStack } from './asyncContext/stackStrategy';\nimport type { AsyncContextStrategy } from './asyncContext/types';\nimport type { Client } from './client';\nimport type { Scope } from './scope';\nimport type { SerializedLog } from './types-hoist/log';\nimport type { Logger } from './utils/debug-logger';\nimport { SDK_VERSION } from './utils/version';\nimport { GLOBAL_OBJ } from './utils/worldwide';\n\n/**\n * An object that contains globally accessible properties and maintains a scope stack.\n * @hidden\n */\nexport interface Carrier {\n  __SENTRY__?: VersionedCarrier;\n}\n\ntype VersionedCarrier = {\n  version?: string;\n} & Record<Exclude<string, 'version'>, SentryCarrier>;\n\nexport interface SentryCarrier {\n  acs?: AsyncContextStrategy;\n  stack?: AsyncContextStack;\n\n  globalScope?: Scope;\n  defaultIsolationScope?: Scope;\n  defaultCurrentScope?: Scope;\n  /** @deprecated Logger is no longer set. Instead, we keep enabled state in loggerSettings. */\n  // eslint-disable-next-line deprecation/deprecation\n  logger?: Logger;\n  loggerSettings?: { enabled: boolean };\n  /**\n   * A map of Sentry clients to their log buffers.\n   * This is used to store logs that are sent to Sentry.\n   */\n  clientToLogBufferMap?: WeakMap<Client, Array<SerializedLog>>;\n\n  /** Overwrites TextEncoder used in `@sentry/core`, need for `react-native@0.73` and older */\n  encodePolyfill?: (input: string) => Uint8Array;\n  /** Overwrites TextDecoder used in `@sentry/core`, need for `react-native@0.73` and older */\n  decodePolyfill?: (input: Uint8Array) => string;\n}\n\n/**\n * Returns the global shim registry.\n *\n * FIXME: This function is problematic, because despite always returning a valid Carrier,\n * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check\n * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.\n **/\nexport function getMainCarrier(): Carrier {\n  // This ensures a Sentry carrier exists\n  getSentryCarrier(GLOBAL_OBJ);\n  return GLOBAL_OBJ;\n}\n\n/** Will either get the existing sentry carrier, or create a new one. */\nexport function getSentryCarrier(carrier: Carrier): SentryCarrier {\n  const __SENTRY__ = (carrier.__SENTRY__ = carrier.__SENTRY__ || {});\n\n  // For now: First SDK that sets the .version property wins\n  __SENTRY__.version = __SENTRY__.version || SDK_VERSION;\n\n  // Intentionally populating and returning the version of \"this\" SDK instance\n  // rather than what's set in .version so that \"this\" SDK always gets its carrier\n  return (__SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {});\n}\n\n/**\n * Returns a global singleton contained in the global `__SENTRY__[]` object.\n *\n * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory\n * function and added to the `__SENTRY__` object.\n *\n * @param name name of the global singleton on __SENTRY__\n * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`\n * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `GLOBAL_OBJ`'s return value\n * @returns the singleton\n */\nexport function getGlobalSingleton<Prop extends keyof SentryCarrier>(\n  name: Prop,\n  creator: () => NonNullable<SentryCarrier[Prop]>,\n  obj = GLOBAL_OBJ,\n): NonNullable<SentryCarrier[Prop]> {\n  const __SENTRY__ = (obj.__SENTRY__ = obj.__SENTRY__ || {});\n  const carrier = (__SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {});\n  // Note: We do not want to set `carrier.version` here, as this may be called before any `init` is called, e.g. for the default scopes\n  return carrier[name] || (carrier[name] = creator());\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { WrappedFunction } from '../types-hoist/wrappedfunction';\nimport { htmlTreeAsString } from './browser';\nimport { debug } from './debug-logger';\nimport { isElement, isError, isEvent, isInstanceOf, isPrimitive } from './is';\nimport { truncate } from './string';\n\n/**\n * Replace a method in an object with a wrapped version of itself.\n *\n * If the method on the passed object is not a function, the wrapper will not be applied.\n *\n * @param source An object that contains a method to be wrapped.\n * @param name The name of the method to be wrapped.\n * @param replacementFactory A higher-order function that takes the original version of the given method and returns a\n * wrapped version. Note: The function returned by `replacementFactory` needs to be a non-arrow function, in order to\n * preserve the correct value of `this`, and the original method must be called using `origMethod.call(this, <other\n * args>)` or `origMethod.apply(this, [<other args>])` (rather than being called directly), again to preserve `this`.\n * @returns void\n */\nexport function fill(source: { [key: string]: any }, name: string, replacementFactory: (...args: any[]) => any): void {\n  if (!(name in source)) {\n    return;\n  }\n\n  // explicitly casting to unknown because we don't know the type of the method initially at all\n  const original = source[name] as unknown;\n\n  if (typeof original !== 'function') {\n    return;\n  }\n\n  const wrapped = replacementFactory(original) as WrappedFunction;\n\n  // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n  // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n  if (typeof wrapped === 'function') {\n    markFunctionWrapped(wrapped, original);\n  }\n\n  try {\n    source[name] = wrapped;\n  } catch {\n    DEBUG_BUILD && debug.log(`Failed to replace method \"${name}\" in object`, source);\n  }\n}\n\n/**\n * Defines a non-enumerable property on the given object.\n *\n * @param obj The object on which to set the property\n * @param name The name of the property to be set\n * @param value The value to which to set the property\n */\nexport function addNonEnumerableProperty(obj: object, name: string, value: unknown): void {\n  try {\n    Object.defineProperty(obj, name, {\n      // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it\n      value: value,\n      writable: true,\n      configurable: true,\n    });\n  } catch {\n    DEBUG_BUILD && debug.log(`Failed to add non-enumerable property \"${name}\" to object`, obj);\n  }\n}\n\n/**\n * Remembers the original function on the wrapped function and\n * patches up the prototype.\n *\n * @param wrapped the wrapper function\n * @param original the original function that gets wrapped\n */\nexport function markFunctionWrapped(wrapped: WrappedFunction, original: WrappedFunction): void {\n  try {\n    const proto = original.prototype || {};\n    wrapped.prototype = original.prototype = proto;\n    addNonEnumerableProperty(wrapped, '__sentry_original__', original);\n  } catch {} // eslint-disable-line no-empty\n}\n\n/**\n * This extracts the original function if available.  See\n * `markFunctionWrapped` for more information.\n *\n * @param func the function to unwrap\n * @returns the unwrapped version of the function if available.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function getOriginalFunction<T extends Function>(func: WrappedFunction<T>): T | undefined {\n  return func.__sentry_original__;\n}\n\n/**\n * Transforms any `Error` or `Event` into a plain object with all of their enumerable properties, and some of their\n * non-enumerable properties attached.\n *\n * @param value Initial source that we have to transform in order for it to be usable by the serializer\n * @returns An Event or Error turned into an object - or the value argument itself, when value is neither an Event nor\n *  an Error.\n */\nexport function convertToPlainObject<V>(value: V):\n  | {\n      [ownProps: string]: unknown;\n      type: string;\n      target: string;\n      currentTarget: string;\n      detail?: unknown;\n    }\n  | {\n      [ownProps: string]: unknown;\n      message: string;\n      name: string;\n      stack?: string;\n    }\n  | V {\n  if (isError(value)) {\n    return {\n      message: value.message,\n      name: value.name,\n      stack: value.stack,\n      ...getOwnProperties(value),\n    };\n  } else if (isEvent(value)) {\n    const newObj: {\n      [ownProps: string]: unknown;\n      type: string;\n      target: string;\n      currentTarget: string;\n      detail?: unknown;\n    } = {\n      type: value.type,\n      target: serializeEventTarget(value.target),\n      currentTarget: serializeEventTarget(value.currentTarget),\n      ...getOwnProperties(value),\n    };\n\n    if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {\n      newObj.detail = value.detail;\n    }\n\n    return newObj;\n  } else {\n    return value;\n  }\n}\n\n/** Creates a string representation of the target of an `Event` object */\nfunction serializeEventTarget(target: unknown): string {\n  try {\n    return isElement(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);\n  } catch {\n    return '<unknown>';\n  }\n}\n\n/** Filters out all but an object's own properties */\nfunction getOwnProperties(obj: unknown): { [key: string]: unknown } {\n  if (typeof obj === 'object' && obj !== null) {\n    const extractedProps: { [key: string]: unknown } = {};\n    for (const property in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, property)) {\n        extractedProps[property] = (obj as Record<string, unknown>)[property];\n      }\n    }\n    return extractedProps;\n  } else {\n    return {};\n  }\n}\n\n/**\n * Given any captured exception, extract its keys and create a sorted\n * and truncated list that will be used inside the event message.\n * eg. `Non-error exception captured with keys: foo, bar, baz`\n */\nexport function extractExceptionKeysForMessage(exception: Record<string, unknown>, maxLength: number = 40): string {\n  const keys = Object.keys(convertToPlainObject(exception));\n  keys.sort();\n\n  const firstKey = keys[0];\n\n  if (!firstKey) {\n    return '[object has no keys]';\n  }\n\n  if (firstKey.length >= maxLength) {\n    return truncate(firstKey, maxLength);\n  }\n\n  for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {\n    const serialized = keys.slice(0, includedKeys).join(', ');\n    if (serialized.length > maxLength) {\n      continue;\n    }\n    if (includedKeys === keys.length) {\n      return serialized;\n    }\n    return truncate(serialized, maxLength);\n  }\n\n  return '';\n}\n\n/**\n * Given any object, return a new object having removed all fields whose value was `undefined`.\n * Works recursively on objects and arrays.\n *\n * Attention: This function keeps circular references in the returned object.\n *\n * @deprecated This function is no longer used by the SDK and will be removed in a future major version.\n */\nexport function dropUndefinedKeys<T>(inputValue: T): T {\n  // This map keeps track of what already visited nodes map to.\n  // Our Set - based memoBuilder doesn't work here because we want to the output object to have the same circular\n  // references as the input object.\n  const memoizationMap = new Map<unknown, unknown>();\n\n  // This function just proxies `_dropUndefinedKeys` to keep the `memoBuilder` out of this function's API\n  return _dropUndefinedKeys(inputValue, memoizationMap);\n}\n\nfunction _dropUndefinedKeys<T>(inputValue: T, memoizationMap: Map<unknown, unknown>): T {\n  // Early return for primitive values\n  if (inputValue === null || typeof inputValue !== 'object') {\n    return inputValue;\n  }\n\n  // Check memo map first for all object types\n  const memoVal = memoizationMap.get(inputValue);\n  if (memoVal !== undefined) {\n    return memoVal as T;\n  }\n\n  // handle arrays\n  if (Array.isArray(inputValue)) {\n    const returnValue: unknown[] = [];\n    // Store mapping to handle circular references\n    memoizationMap.set(inputValue, returnValue);\n\n    inputValue.forEach(value => {\n      returnValue.push(_dropUndefinedKeys(value, memoizationMap));\n    });\n\n    return returnValue as unknown as T;\n  }\n\n  if (isPojo(inputValue)) {\n    const returnValue: { [key: string]: unknown } = {};\n    // Store mapping to handle circular references\n    memoizationMap.set(inputValue, returnValue);\n\n    const keys = Object.keys(inputValue);\n\n    keys.forEach(key => {\n      const val = inputValue[key];\n      if (val !== undefined) {\n        returnValue[key] = _dropUndefinedKeys(val, memoizationMap);\n      }\n    });\n\n    return returnValue as T;\n  }\n\n  // For other object types, return as is\n  return inputValue;\n}\n\nfunction isPojo(input: unknown): input is Record<string, unknown> {\n  // Plain objects have Object as constructor or no constructor\n  const constructor = (input as object).constructor;\n  return constructor === Object || constructor === undefined;\n}\n\n/**\n * Ensure that something is an object.\n *\n * Turns `undefined` and `null` into `String`s and all other primitives into instances of their respective wrapper\n * classes (String, Boolean, Number, etc.). Acts as the identity function on non-primitives.\n *\n * @param wat The subject of the objectification\n * @returns A version of `wat` which can safely be used with `Object` class methods\n */\nexport function objectify(wat: unknown): typeof Object {\n  let objectified;\n  switch (true) {\n    // this will catch both undefined and null\n    case wat == undefined:\n      objectified = new String(wat);\n      break;\n\n    // Though symbols and bigints do have wrapper classes (`Symbol` and `BigInt`, respectively), for whatever reason\n    // those classes don't have constructors which can be used with the `new` keyword. We therefore need to cast each as\n    // an object in order to wrap it.\n    case typeof wat === 'symbol' || typeof wat === 'bigint':\n      objectified = Object(wat);\n      break;\n\n    // this will catch the remaining primitives: `String`, `Number`, and `Boolean`\n    case isPrimitive(wat):\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      objectified = new (wat as any).constructor(wat);\n      break;\n\n    // by process of elimination, at this point we know that `wat` must already be an object\n    default:\n      objectified = wat;\n      break;\n  }\n  return objectified;\n}\n","import type { Primitive } from '../types-hoist/misc';\nimport { isSyntheticEvent, isVueViewModel } from './is';\nimport { convertToPlainObject } from './object';\nimport { getFunctionName } from './stacktrace';\n\ntype Prototype = { constructor?: (...args: unknown[]) => unknown };\n// This is a hack to placate TS, relying on the fact that technically, arrays are objects with integer keys. Normally we\n// think of those keys as actual numbers, but `arr['0']` turns out to work just as well as `arr[0]`, and doing it this\n// way lets us use a single type in the places where behave as if we are only dealing with objects, even if some of them\n// might be arrays.\ntype ObjOrArray<T> = { [key: string]: T };\n\ntype MemoFunc = [\n  // memoize\n  (obj: object) => boolean,\n  // unmemoize\n  (obj: object) => void,\n];\n\n/**\n * Recursively normalizes the given object.\n *\n * - Creates a copy to prevent original input mutation\n * - Skips non-enumerable properties\n * - When stringifying, calls `toJSON` if implemented\n * - Removes circular references\n * - Translates non-serializable values (`undefined`/`NaN`/functions) to serializable format\n * - Translates known global objects/classes to a string representations\n * - Takes care of `Error` object serialization\n * - Optionally limits depth of final output\n * - Optionally limits number of properties/elements included in any single object/array\n *\n * @param input The object to be normalized.\n * @param depth The max depth to which to normalize the object. (Anything deeper stringified whole.)\n * @param maxProperties The max number of elements or properties to be included in any single array or\n * object in the normalized output.\n * @returns A normalized version of the object, or `\"**non-serializable**\"` if any errors are thrown during normalization.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function normalize(input: unknown, depth: number = 100, maxProperties: number = +Infinity): any {\n  try {\n    // since we're at the outermost level, we don't provide a key\n    return visit('', input, depth, maxProperties);\n  } catch (err) {\n    return { ERROR: `**non-serializable** (${err})` };\n  }\n}\n\n/** JSDoc */\nexport function normalizeToSize<T>(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  object: { [key: string]: any },\n  // Default Node.js REPL depth\n  depth: number = 3,\n  // 100kB, as 200kB is max payload size, so half sounds reasonable\n  maxSize: number = 100 * 1024,\n): T {\n  const normalized = normalize(object, depth);\n\n  if (jsonSize(normalized) > maxSize) {\n    return normalizeToSize(object, depth - 1, maxSize);\n  }\n\n  return normalized as T;\n}\n\n/**\n * Visits a node to perform normalization on it\n *\n * @param key The key corresponding to the given node\n * @param value The node to be visited\n * @param depth Optional number indicating the maximum recursion depth\n * @param maxProperties Optional maximum number of properties/elements included in any single object/array\n * @param memo Optional Memo class handling decycling\n */\nfunction visit(\n  key: string,\n  value: unknown,\n  depth: number = +Infinity,\n  maxProperties: number = +Infinity,\n  memo = memoBuilder(),\n): Primitive | ObjOrArray<unknown> {\n  const [memoize, unmemoize] = memo;\n\n  // Get the simple cases out of the way first\n  if (\n    value == null || // this matches null and undefined -> eqeq not eqeqeq\n    ['boolean', 'string'].includes(typeof value) ||\n    (typeof value === 'number' && Number.isFinite(value))\n  ) {\n    return value as Primitive;\n  }\n\n  const stringified = stringifyValue(key, value);\n\n  // Anything we could potentially dig into more (objects or arrays) will have come back as `\"[object XXXX]\"`.\n  // Everything else will have already been serialized, so if we don't see that pattern, we're done.\n  if (!stringified.startsWith('[object ')) {\n    return stringified;\n  }\n\n  // From here on, we can assert that `value` is either an object or an array.\n\n  // Do not normalize objects that we know have already been normalized. As a general rule, the\n  // \"__sentry_skip_normalization__\" property should only be used sparingly and only should only be set on objects that\n  // have already been normalized.\n  if ((value as ObjOrArray<unknown>)['__sentry_skip_normalization__']) {\n    return value as ObjOrArray<unknown>;\n  }\n\n  // We can set `__sentry_override_normalization_depth__` on an object to ensure that from there\n  // We keep a certain amount of depth.\n  // This should be used sparingly, e.g. we use it for the redux integration to ensure we get a certain amount of state.\n  const remainingDepth =\n    typeof (value as ObjOrArray<unknown>)['__sentry_override_normalization_depth__'] === 'number'\n      ? ((value as ObjOrArray<unknown>)['__sentry_override_normalization_depth__'] as number)\n      : depth;\n\n  // We're also done if we've reached the max depth\n  if (remainingDepth === 0) {\n    // At this point we know `serialized` is a string of the form `\"[object XXXX]\"`. Clean it up so it's just `\"[XXXX]\"`.\n    return stringified.replace('object ', '');\n  }\n\n  // If we've already visited this branch, bail out, as it's circular reference. If not, note that we're seeing it now.\n  if (memoize(value)) {\n    return '[Circular ~]';\n  }\n\n  // If the value has a `toJSON` method, we call it to extract more information\n  const valueWithToJSON = value as unknown & { toJSON?: () => unknown };\n  if (valueWithToJSON && typeof valueWithToJSON.toJSON === 'function') {\n    try {\n      const jsonValue = valueWithToJSON.toJSON();\n      // We need to normalize the return value of `.toJSON()` in case it has circular references\n      return visit('', jsonValue, remainingDepth - 1, maxProperties, memo);\n    } catch {\n      // pass (The built-in `toJSON` failed, but we can still try to do it ourselves)\n    }\n  }\n\n  // At this point we know we either have an object or an array, we haven't seen it before, and we're going to recurse\n  // because we haven't yet reached the max depth. Create an accumulator to hold the results of visiting each\n  // property/entry, and keep track of the number of items we add to it.\n  const normalized = (Array.isArray(value) ? [] : {}) as ObjOrArray<unknown>;\n  let numAdded = 0;\n\n  // Before we begin, convert`Error` and`Event` instances into plain objects, since some of each of their relevant\n  // properties are non-enumerable and otherwise would get missed.\n  const visitable = convertToPlainObject(value as ObjOrArray<unknown>);\n\n  for (const visitKey in visitable) {\n    // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.\n    if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {\n      continue;\n    }\n\n    if (numAdded >= maxProperties) {\n      normalized[visitKey] = '[MaxProperties ~]';\n      break;\n    }\n\n    // Recursively visit all the child nodes\n    const visitValue = visitable[visitKey];\n    normalized[visitKey] = visit(visitKey, visitValue, remainingDepth - 1, maxProperties, memo);\n\n    numAdded++;\n  }\n\n  // Once we've visited all the branches, remove the parent from memo storage\n  unmemoize(value);\n\n  // Return accumulated values\n  return normalized;\n}\n\n/* eslint-disable complexity */\n/**\n * Stringify the given value. Handles various known special values and types.\n *\n * Not meant to be used on simple primitives which already have a string representation, as it will, for example, turn\n * the number 1231 into \"[Object Number]\", nor on `null`, as it will throw.\n *\n * @param value The value to stringify\n * @returns A stringified representation of the given value\n */\nfunction stringifyValue(\n  key: unknown,\n  // this type is a tiny bit of a cheat, since this function does handle NaN (which is technically a number), but for\n  // our internal use, it'll do\n  value: Exclude<unknown, string | number | boolean | null>,\n): string {\n  try {\n    if (key === 'domain' && value && typeof value === 'object' && (value as { _events: unknown })._events) {\n      return '[Domain]';\n    }\n\n    if (key === 'domainEmitter') {\n      return '[DomainEmitter]';\n    }\n\n    // It's safe to use `global`, `window`, and `document` here in this manner, as we are asserting using `typeof` first\n    // which won't throw if they are not present.\n\n    if (typeof global !== 'undefined' && value === global) {\n      return '[Global]';\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    if (typeof window !== 'undefined' && value === window) {\n      return '[Window]';\n    }\n\n    // eslint-disable-next-line no-restricted-globals\n    if (typeof document !== 'undefined' && value === document) {\n      return '[Document]';\n    }\n\n    if (isVueViewModel(value)) {\n      return '[VueViewModel]';\n    }\n\n    // React's SyntheticEvent thingy\n    if (isSyntheticEvent(value)) {\n      return '[SyntheticEvent]';\n    }\n\n    if (typeof value === 'number' && !Number.isFinite(value)) {\n      return `[${value}]`;\n    }\n\n    if (typeof value === 'function') {\n      return `[Function: ${getFunctionName(value)}]`;\n    }\n\n    if (typeof value === 'symbol') {\n      return `[${String(value)}]`;\n    }\n\n    // stringified BigInts are indistinguishable from regular numbers, so we need to label them to avoid confusion\n    if (typeof value === 'bigint') {\n      return `[BigInt: ${String(value)}]`;\n    }\n\n    // Now that we've knocked out all the special cases and the primitives, all we have left are objects. Simply casting\n    // them to strings means that instances of classes which haven't defined their `toStringTag` will just come out as\n    // `\"[object Object]\"`. If we instead look at the constructor's name (which is the same as the name of the class),\n    // we can make sure that only plain objects come out that way.\n    const objName = getConstructorName(value);\n\n    // Handle HTML Elements\n    if (/^HTML(\\w*)Element$/.test(objName)) {\n      return `[HTMLElement: ${objName}]`;\n    }\n\n    return `[object ${objName}]`;\n  } catch (err) {\n    return `**non-serializable** (${err})`;\n  }\n}\n/* eslint-enable complexity */\n\nfunction getConstructorName(value: unknown): string {\n  const prototype: Prototype | null = Object.getPrototypeOf(value);\n\n  return prototype?.constructor ? prototype.constructor.name : 'null prototype';\n}\n\n/** Calculates bytes size of input string */\nfunction utf8Length(value: string): number {\n  // eslint-disable-next-line no-bitwise\n  return ~-encodeURI(value).split(/%..|./).length;\n}\n\n/** Calculates bytes size of input object */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction jsonSize(value: any): number {\n  return utf8Length(JSON.stringify(value));\n}\n\n/**\n * Normalizes URLs in exceptions and stacktraces to a base path so Sentry can fingerprint\n * across platforms and working directory.\n *\n * @param url The URL to be normalized.\n * @param basePath The application base path.\n * @returns The normalized URL.\n */\nexport function normalizeUrlToBase(url: string, basePath: string): string {\n  const escapedBase = basePath\n    // Backslash to forward\n    .replace(/\\\\/g, '/')\n    // Escape RegExp special characters\n    .replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&');\n\n  let newUrl = url;\n  try {\n    newUrl = decodeURI(url);\n  } catch {\n    // Sometime this breaks\n  }\n  return (\n    newUrl\n      .replace(/\\\\/g, '/')\n      .replace(/webpack:\\/?/g, '') // Remove intermediate base path\n      // eslint-disable-next-line @sentry-internal/sdk/no-regexp-constructor\n      .replace(new RegExp(`(file://)?/*${escapedBase}/*`, 'ig'), 'app:///')\n  );\n}\n\n/**\n * Helper to decycle json objects\n */\nfunction memoBuilder(): MemoFunc {\n  const inner = new WeakSet<object>();\n  function memoize(obj: object): boolean {\n    if (inner.has(obj)) {\n      return true;\n    }\n    inner.add(obj);\n    return false;\n  }\n\n  function unmemoize(obj: object): void {\n    inner.delete(obj);\n  }\n  return [memoize, unmemoize];\n}\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12]}