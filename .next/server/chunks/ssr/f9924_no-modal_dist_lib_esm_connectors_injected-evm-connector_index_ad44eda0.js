module.exports=[65139,a=>{"use strict";a.s([],38088),a.i(38088);var b=a.i(41415),c=a.i(63179),d=a.i(62267),e=a.i(78801),f=a.i(38013),g=a.i(9290),h=a.i(72568),i=a.i(62738);class j extends d.BaseEvmConnector{constructor(a){super(a),(0,b.default)(this,"connectorNamespace",e.CONNECTOR_NAMESPACES.EIP155),(0,b.default)(this,"currentChainNamespace",f.CHAIN_NAMESPACES.EIP155),(0,b.default)(this,"type",g.CONNECTOR_CATEGORY.EXTERNAL),(0,b.default)(this,"name",void 0),(0,b.default)(this,"isInjected",!0),(0,b.default)(this,"status",g.CONNECTOR_STATUS.NOT_READY),(0,b.default)(this,"injectedProvider",null),this.name=a.name,this.injectedProvider=a.provider,this.icon=a.icon}get provider(){return this.status!==g.CONNECTOR_STATUS.NOT_READY&&this.injectedProvider?this.injectedProvider:null}set provider(a){throw Error("Not implemented")}async init(a){await super.init(a);let b=this.coreOptions.chains.find(b=>b.chainId===a.chainId);super.checkInitializationRequirements({chainConfig:b}),this.status=g.CONNECTOR_STATUS.READY,this.emit(g.CONNECTOR_EVENTS.READY,this.name);try{if(h.log.debug(`initializing ${this.name} injected connector`),a.autoConnect&&(this.rehydrated=!0,!await this.connect({chainId:a.chainId,getIdentityToken:a.getIdentityToken})))throw this.rehydrated=!1,i.WalletLoginError.connectionError("Failed to rehydrate.")}catch(a){this.emit(g.CONNECTOR_EVENTS.REHYDRATION_ERROR,a)}}async connect({chainId:a,getIdentityToken:b}){if(super.checkConnectionRequirements(),!this.injectedProvider)throw i.WalletLoginError.connectionError("Injected provider is not available");let c=this.coreOptions.chains.find(b=>b.chainId===a);if(!c)throw i.WalletLoginError.connectionError("Chain config is not available");this.status=g.CONNECTOR_STATUS.CONNECTING,this.emit(g.CONNECTOR_EVENTS.CONNECTING,{connector:this.name});try{let a;if(await this.injectedProvider.request({method:"eth_requestAccounts"}),this.injectedProvider.chainId!==c.chainId)try{await this.switchChain(c,!0)}catch{await this.addChain(c,!0),await this.switchChain(c,!0)}this.status=g.CONNECTOR_STATUS.CONNECTED;let d=a=>{if(0===a.length){var b;this.disconnect(),null!=(b=this.injectedProvider)&&b.removeListener&&this.injectedProvider.removeListener("accountsChanged",d)}};return this.injectedProvider.on("accountsChanged",d),this.emit(g.CONNECTOR_EVENTS.CONNECTED,{connector:this.name,reconnected:this.rehydrated,provider:this.injectedProvider,identityTokenInfo:a}),b&&(a=await this.getIdentityToken()),this.injectedProvider}catch(a){if(this.status=g.CONNECTOR_STATUS.READY,this.rehydrated||this.emit(g.CONNECTOR_EVENTS.ERRORED,a),this.rehydrated=!1,a instanceof i.Web3AuthError)throw a;throw i.WalletLoginError.connectionError(`Failed to login with ${this.name} injected wallet`)}}async disconnect(a={cleanup:!1}){if(!this.injectedProvider)throw i.WalletLoginError.connectionError("Injected provider is not available");await super.disconnectSession(),void 0!==this.injectedProvider.removeAllListeners&&this.injectedProvider.removeAllListeners();try{await this.injectedProvider.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]})}catch{}a.cleanup?(this.status=g.CONNECTOR_STATUS.NOT_READY,this.injectedProvider=null):this.status=g.CONNECTOR_STATUS.READY,await super.disconnect()}async getUserInfo(){if(!this.canAuthorize)throw i.WalletLoginError.notConnectedError("Not connected with wallet, Please login/connect first");return{}}async addChain(a,b=!1){if(!this.injectedProvider)throw i.WalletLoginError.connectionError("Injected provider is not available");await this.injectedProvider.request({method:"wallet_addEthereumChain",params:[{chainId:a.chainId,chainName:a.displayName,rpcUrls:[a.rpcTarget],blockExplorerUrls:[a.blockExplorerUrl],nativeCurrency:{name:a.tickerName,symbol:a.ticker,decimals:a.decimals||18},iconUrls:[a.logo]}]})}async switchChain(a,b=!1){if(!this.injectedProvider)throw i.WalletLoginError.connectionError("Injected provider is not available");super.checkSwitchChainRequirements(a,b),await this.injectedProvider.request({method:"wallet_switchEthereumChain",params:[{chainId:a.chainId}]})}async enableMFA(){throw Error("Method Not implemented")}async manageMFA(){throw Error("Method Not implemented")}}let k=a=>({coreOptions:b})=>new j({name:(0,c.normalizeWalletName)(a.info.name),provider:a.provider,icon:a.info.icon,coreOptions:b});function l(){let a=new Set,b=[],c=()=>{},d=c();return{_listeners:()=>a,clear(){a.forEach(a=>a([],{removed:[...b]})),b=[]},destroy(){this.clear(),a.clear(),d?.()},findProvider:({rdns:a})=>b.find(b=>b.info.rdns===a),getProviders:()=>b,reset(){this.clear(),d?.(),d=c()},subscribe:(c,{emitImmediately:d}={})=>(a.add(c),d&&c(b,{added:b}),()=>a.delete(c))}}a.s(["createMipd",()=>l,"injectedEvmConnector",()=>k],65139)}];

//# sourceMappingURL=f9924_no-modal_dist_lib_esm_connectors_injected-evm-connector_index_ad44eda0.js.map